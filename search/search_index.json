{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Predigame Instructional Platform Pure Code. Pure Fun. Brain candy for the aspiring coder! Overview Predigame is an instructional platform that teaches the basics of coding through the creation of arcade games. The platform was researched and developed by Predicate Academy and used for teaching kids ages 8-17 all the amazingly cool things that can be created with code. Predigame is a minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface that is especially welcoming to first time coders. Predigame allows aspiring coders to familiarize themselves with computational thinking while downplaying many of the language and keyboard nuances that come with using a text-based coding language. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist - specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are directly transferrable in any journey to becoming a software engineer. Unlike other introductory platforms that teach coding concepts through visual (drag and drop) interactions, Predigame is written in Python and Pygame. While the core gaming platform covers a number of common use cases, Predigame is completely extensible and games can be amplified with custom code. Predigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch). It may likely run in on other operating systems, we just haven't tested them (yet). We assume that all users have some basic computer skills: typing, opening/closing windows, as well as an ability to navigate files and folders. Example Game - Zombie Madness Zombie Madness is an instructional implementation that was used by Predicate Academy during their Winter and Sping 2018 seasonal classes. Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code! Click the image below for a video of the game in action! Example Game - Click Ninja Click Ninja was inspired by the app fruit ninja , but it's a little different since we have a mouse and not a touch screen. Click the image below for a video of the game in action! Installing Predigame Install a Text Editor Every coder needs a good text editor. For python development, we recommend using Atom . New to Atom? Check out their documentation . Sorry Pi Users - Atom isn't currently available for Raspbian, so we'd recommend using IDLE or Thonny (both come preinstalled with Raspbian Stretch). Microsoft Windows 10 NOTE: installation will require Administrator permissions New to coding and installing stuff? Check out our Windows Installation Video ! Install Python Predigame has been tested with Python v3.6.4 ( direct download link ). When installing, you'll want to make sure to check the box to have Python added to your PATH (it's off by default). Install Pygame Open a command prompt (search: command prompt ) Type the following command in the command prompt window: python -m pip install -U pygame Look for line Successfully installed ... to indicate a successful installation. Install Predigame Open a command prompt (or reuse the window from the previous step) and type the following command: python -m pip install -U predigame This can take a minute or two to complete. Look for the line Successfully installed ... to indicate a successful installation. macOS NOTE: installation will require Administrator permissions New to coding and installing stuff? Check out our macOS installation video ! Install Python Predigame has been tested with Python v3.6.4 ( direct download link ). Install Pygame Open a Terminal (command search: Terminal or visit this link for help). Type the following command in the terminal: sudo pip3 install -U pygame This command will require an administrator account and a prompt for a password. Look for line Successfully installed ... to indicate a successful installation. Install Predigame Open a command prompt (or reuse the window from the previous step) and type the following command: sudo pip3 install -U predigame This command will require an administrator account and a prompt for a password. The process can take a minute or two to complete. Look for the line Successfully installed ... to indicate a successful installation. Raspberry Pi Good news Pi fans! You're just a pip3 install away from coding your first game! Open a Terminal and type the following command: sudo pip3 install -U predigame New to coding and installing stuff? Check out our Raspberry Pi Installation Video ! Updating Predigame Predigame changes frequently. Run the following command(s) to ensure you have the latest and greatest release. Windows python -m pip uninstall predigame python -m pip install predigame We're not sure pip install -U works correctly on Windows, so it's always good to uninstall first. macOS and Raspberry Pi sudo pip3 install -U predigame Getting Started Now that you have Predigame installed, let's open a command prompt (Windows) or terminal (macOS, Pi) and test out to an existing game to make sure things are working correctly. List available game downloads: pred list Try downloading the clickninja game: pred pull clickninja Assuming that was successful, let's try to start the game! cd clickninja pred clickninja-levels.py The r key can be used to reset the game. Hit Esc to close the window. If you want to run again, the cd clickninja command may not be necessary (if you are already in the clickninja directory). Want to learn more about customizing Click Ninja? Check out the the game tutorial . macOS Certificate Errors Some macOS users may see this error the first time using pred : ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:749) If that happens, run this command to install the certificates and try again: sudo /Applications/Python 3.6/Install Certificates.command Coding Your First Game Our first game is going to be a digital picture frame. It's not TECHNICALLY a game, rather a fun example that showcases some of the flexibilities and power of Predigame. Open a command prompt (Windows) or terminal (macOS, Pi) and run the following command to create a new game: pred new hello Note For windows users, it may be easier to run cd Desktop prior to pred new (files and folders stored on the desktop will be a little easier to find). This command will create a new directory hello and game template hello/game.py as well as some subdirectories that will be useful to hold custom images, backgrounds, and sounds. Using your favorite code editor, open the file game.py . You'll notice the game already has a few lines of code (we'll discuss what those mean next). Try adding this line to the bottom of the file: background() So the completed code example should look like: WIDTH = 30 HEIGHT = 20 TITLE = 'Simple Game' background() Save your changes. Then in the terminal, you'll want to run: pred game.py Did you see the background picture? Make sure you cd hello prior to running pred as you need to be in the same directory as your python files. There you go! First \"game\" down. Take a look at the Picture Frame example for some other cool coding additions. API Docs Predigame API documentation can be found here: http://predigame.io/api . Not sure what this means? Don't worry. We'll cover this later! Support Find a bug? Have a question? Visit our Support Forum: https://groups.google.com/a/predicate.us/forum/#!forum/supportloc GitHub User? Fork our repos - https://github.com/predigame . We happily take pull requests :)","title":"Home"},{"location":"#predigame-instructional-platform","text":"Pure Code. Pure Fun. Brain candy for the aspiring coder!","title":"Predigame Instructional Platform"},{"location":"#overview","text":"Predigame is an instructional platform that teaches the basics of coding through the creation of arcade games. The platform was researched and developed by Predicate Academy and used for teaching kids ages 8-17 all the amazingly cool things that can be created with code. Predigame is a minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface that is especially welcoming to first time coders. Predigame allows aspiring coders to familiarize themselves with computational thinking while downplaying many of the language and keyboard nuances that come with using a text-based coding language. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist - specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are directly transferrable in any journey to becoming a software engineer. Unlike other introductory platforms that teach coding concepts through visual (drag and drop) interactions, Predigame is written in Python and Pygame. While the core gaming platform covers a number of common use cases, Predigame is completely extensible and games can be amplified with custom code. Predigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch). It may likely run in on other operating systems, we just haven't tested them (yet). We assume that all users have some basic computer skills: typing, opening/closing windows, as well as an ability to navigate files and folders.","title":"Overview"},{"location":"#example-game-zombie-madness","text":"Zombie Madness is an instructional implementation that was used by Predicate Academy during their Winter and Sping 2018 seasonal classes. Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code! Click the image below for a video of the game in action!","title":"Example Game - Zombie Madness"},{"location":"#example-game-click-ninja","text":"Click Ninja was inspired by the app fruit ninja , but it's a little different since we have a mouse and not a touch screen. Click the image below for a video of the game in action!","title":"Example Game - Click Ninja"},{"location":"#installing-predigame","text":"","title":"Installing Predigame"},{"location":"#install-a-text-editor","text":"Every coder needs a good text editor. For python development, we recommend using Atom . New to Atom? Check out their documentation . Sorry Pi Users - Atom isn't currently available for Raspbian, so we'd recommend using IDLE or Thonny (both come preinstalled with Raspbian Stretch).","title":"Install a Text Editor"},{"location":"#microsoft-windows-10","text":"NOTE: installation will require Administrator permissions New to coding and installing stuff? Check out our Windows Installation Video ! Install Python Predigame has been tested with Python v3.6.4 ( direct download link ). When installing, you'll want to make sure to check the box to have Python added to your PATH (it's off by default). Install Pygame Open a command prompt (search: command prompt ) Type the following command in the command prompt window: python -m pip install -U pygame Look for line Successfully installed ... to indicate a successful installation. Install Predigame Open a command prompt (or reuse the window from the previous step) and type the following command: python -m pip install -U predigame This can take a minute or two to complete. Look for the line Successfully installed ... to indicate a successful installation.","title":"Microsoft Windows 10"},{"location":"#macos","text":"NOTE: installation will require Administrator permissions New to coding and installing stuff? Check out our macOS installation video ! Install Python Predigame has been tested with Python v3.6.4 ( direct download link ). Install Pygame Open a Terminal (command search: Terminal or visit this link for help). Type the following command in the terminal: sudo pip3 install -U pygame This command will require an administrator account and a prompt for a password. Look for line Successfully installed ... to indicate a successful installation. Install Predigame Open a command prompt (or reuse the window from the previous step) and type the following command: sudo pip3 install -U predigame This command will require an administrator account and a prompt for a password. The process can take a minute or two to complete. Look for the line Successfully installed ... to indicate a successful installation.","title":"macOS"},{"location":"#raspberry-pi","text":"Good news Pi fans! You're just a pip3 install away from coding your first game! Open a Terminal and type the following command: sudo pip3 install -U predigame New to coding and installing stuff? Check out our Raspberry Pi Installation Video !","title":"Raspberry Pi"},{"location":"#updating-predigame","text":"Predigame changes frequently. Run the following command(s) to ensure you have the latest and greatest release.","title":"Updating Predigame"},{"location":"#windows","text":"python -m pip uninstall predigame python -m pip install predigame We're not sure pip install -U works correctly on Windows, so it's always good to uninstall first.","title":"Windows"},{"location":"#macos-and-raspberry-pi","text":"sudo pip3 install -U predigame","title":"macOS and Raspberry Pi"},{"location":"#getting-started","text":"Now that you have Predigame installed, let's open a command prompt (Windows) or terminal (macOS, Pi) and test out to an existing game to make sure things are working correctly. List available game downloads: pred list Try downloading the clickninja game: pred pull clickninja Assuming that was successful, let's try to start the game! cd clickninja pred clickninja-levels.py The r key can be used to reset the game. Hit Esc to close the window. If you want to run again, the cd clickninja command may not be necessary (if you are already in the clickninja directory). Want to learn more about customizing Click Ninja? Check out the the game tutorial .","title":"Getting Started"},{"location":"#macos-certificate-errors","text":"Some macOS users may see this error the first time using pred : ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:749) If that happens, run this command to install the certificates and try again: sudo /Applications/Python 3.6/Install Certificates.command","title":"macOS Certificate Errors"},{"location":"#coding-your-first-game","text":"Our first game is going to be a digital picture frame. It's not TECHNICALLY a game, rather a fun example that showcases some of the flexibilities and power of Predigame. Open a command prompt (Windows) or terminal (macOS, Pi) and run the following command to create a new game: pred new hello Note For windows users, it may be easier to run cd Desktop prior to pred new (files and folders stored on the desktop will be a little easier to find). This command will create a new directory hello and game template hello/game.py as well as some subdirectories that will be useful to hold custom images, backgrounds, and sounds. Using your favorite code editor, open the file game.py . You'll notice the game already has a few lines of code (we'll discuss what those mean next). Try adding this line to the bottom of the file: background() So the completed code example should look like: WIDTH = 30 HEIGHT = 20 TITLE = 'Simple Game' background() Save your changes. Then in the terminal, you'll want to run: pred game.py Did you see the background picture? Make sure you cd hello prior to running pred as you need to be in the same directory as your python files. There you go! First \"game\" down. Take a look at the Picture Frame example for some other cool coding additions.","title":"Coding Your First Game"},{"location":"#api-docs","text":"Predigame API documentation can be found here: http://predigame.io/api . Not sure what this means? Don't worry. We'll cover this later!","title":"API Docs"},{"location":"#support","text":"Find a bug? Have a question? Visit our Support Forum: https://groups.google.com/a/predicate.us/forum/#!forum/supportloc GitHub User? Fork our repos - https://github.com/predigame . We happily take pull requests :)","title":"Support"},{"location":"about/","text":"The Predicate Project: Rethinking Technology Education Education should prepare young people for jobs that do not yet exist, using technologies that have not been invented, to solve problems of which we are not yet aware. - Richard Riley When I was in 10th grade I was \"academically floundering\" - a \"C\" and \"D\" student at best. No drive to do well in school. I clearly didn't understand nor did I care about the big picture. Then I took a technology class that was given by a former metal shop teacher who had a grasp of the future. This was back in the early 1990s and the computing field wasn\u2019t much at the time. We made an intercom \u2013 no, it wasn\u2019t two cans and a string \u2013 rather, it was a silk-screened circuit board. We drilled all the holes, soldered the electronic components (while also learning how each of those components worked in unison to deliver a capability). The highlight for me was bringing it home and installing MY creation in my bedroom. Even today, I remember that class vividly \u2013 it had an impact, that 25 years later continues to mold my life. I have a tremendous appreciation for the teachers who are some of the earliest role models for our children. Day in and day out, they work on the educational front lines \u2013 lecturing, encouraging, mentoring, correcting \u2013 and they see it all. A good teacher can positively impact a child for life. As a parent and technology professional, I\u2019ve often battled with the question \u2013 are we doing enough to prepare our children for the future? My day job is a Research Director at Two Six Labs \u2013 a company that pushes the boundaries of the possible to protect the future. Our mission requires that we hire some amazingly talented people and it should come as no surprise that fueling the hiring needs of a growing organization can be as challenging as creating breakthrough technologies. For today\u2019s 10-year-old in 5th grade \u2013 there\u2019s a solid seven years remaining in primary education and potentially another four (maybe more) before hitting the workforce. Adding it all up, if all these numbers hold and my math is correct, a 5th grader in 2018 would graduate high school in 2025, and college in 2029. While it seems like a long way ahead, there are things we can do today to prepare our children for the future. The challenge is that for all of the technological innovations, we\u2019ve actually made it harder for our children to learn about technology. We live in consumption driven times and, for most children, technology is only \u201cseen\u201d from the lens of a user. There is, unfortunately, an established expectation for immediate results and an equal instantaneous cloud of discouragement and frustration when something doesn\u2019t work as expected. At our home, simply the loss of electricity is a reminder of our childrens\u2019 lens through which they see technology. However, for every game, every Netflix stream, app, website, robotic vacuum cleaner, and drone, there is someone whose job it is to design the next big idea and someone who makes that idea come to life. We need to provide a different lens for seeing technology \u2013 from that of the creator. In January 2016 my wife and I started Predicate Academy \u2013 a \u201cboutique\u201d school that teaches coding to kids ages 8 and up in a small Southern New Jersey town. Prior to Predicate, I had no teaching experience, but I\u2019m a problem solver at heart, and I felt increasingly motivated to figure out how to \u201cfix\u201d technology education. My vision for Predicate was to create an environment where we change the way children learn about technology. To be honest, I had no idea how I was going to accomplish this challenge, but I\u2019ve been dissatisfied with the void of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. So that was my starting point. I was particularly attracted to the work being done by the Raspberry Pi Foundation \u2013 they use many of the same \u201ctools of the trade\u201d \u2013 Linux, command line, modern programming languages - that are used in the field. And the devices are only $35USD, so everybody can own one, even if coding isn\u2019t their thing. So, we bought Pis, lots of Pis! Since 2016, we\u2019ve put more than 1000 Pis out in the wild. An interesting paradox at Predicate is that while we focus on education, our aspiring innovators do not see Predicate Academy as a school. Why not? Frequent responses are: \u201cit\u2019s coding\u201d, \u201cwe make games\u201d, \u201cit\u2019s fun\u201d, \u201cthere is no homework\u201d. I believe I\u2019ve successfully exploited this belief by being able to bury some dense mathematical and physics concepts in the context of \u201ccoding\u201d. Computer Science is multidisciplinary field with roots in Mathematics and Physics, and going back to its roots, is rich with applied educational value. In any given week some of our classes would be converting between seconds and milliseconds, writing algebraic formulas to make a LED pulse, computing Euclidean distance, and even understanding the frequency spectrum. But teaching is incredibly hard work! While I only hold a few classes a week at Predicate, a technical glitch can wreak chaos on a class. Through it all, though, one of the most unexpected surprises is to see the weekly progression of our aspiring innovators. Their curiosity and excitement is equally contagious \u2013 far more than I would have ever estimated. I have a handful of kids that have assembled a wealth of command line foo and a few others that have mastered nmap and ssh (so much so I had to change our in-class code deployment processes). We have some very talented future technologists and it\u2019s been a true honor to be a part of their educational journey. I genuinely believe that with every passing class, we are becoming increasingly aware of better ways to deliver technology education. Direct feedback from our innovators and their parents has offered continued motivation to see our vision through. In many ways, I\u2019m reliving an educational experience I had many years ago and it\u2019s been great to see the impact that Predicate has had in our community. Predicate has allowed us to see excitement in our budding inventor \u2013 more than any other extracurricular activity he has tried! Drew may be quiet while concentrating in coding class, but then he comes home and runs to set up the latest project declaring, \u201cYou HAVE to see this,\u201d to the whole family! What an amazing and smart way to spread the love of coding and computers to our future inventors, scientists and leaders! Kevin\u2019s experience at Predicate Academy has been amazing! He has been able to apply what he has learned in his Journey sessions to create a video game in his high school\u2019s Computer System and Video Game Design class. Kevin designed a fully interactive game that required coding and creating sprites, sounds, backgrounds, objects, controllers, and levels. The game has three lives and secret Easter Egg levels. If a player passes all the levels, the game can provide up to thirty minutes of entertainment! We are thrilled that Kevin is a part of something so special at Predicate Academy! Not only is he gaining valuable real-life skills to take into the classroom and world, but Predicate has given him the knowledge and confidence to share these skills with his high school classmates! Some time ago, Ryan decided that he wanted to be a coder when he grew up. I knew he liked playing video games and Minecraft mods, so I guess that\u2019s where he got the idea that he wanted to be a coder. With the help of a junior programming book, we tried to do a little programming at home, but I was not very successful helping him to understand the concepts or make it applicable to his interests. We came across a Facebook mention of a Predicate Academy open house and went to check it out. Mr. Mike showed us the Python programming and physical computing interaction with the Raspberry Pi and Ryan was immediately hooked. The computing projects at Predicate Academy provide him with just the right mix of challenge, skill development and fun. Ryan looks forward to going to class every week and he can\u2019t wait to continue learning how to code at Predicate Academy! While we have been teaching our aspiring innovators how to code, we\u2019ve also been studying how children respond to these concepts (and, well, education in general). Painting in broad strokes, a number of consistent themes surfaced in our classes: Most kids (at least in our area) are familiar with coding prior to coming to Predicate, but it is often limited to Computer Science Education Week and the Hour of Code. Typing skills are wildly varying and navigation around special keys (especially those used in most coding languages) is a challenge. I\u2019m always amused when kids come in and ask: \u201cMr. Mike, are we going to do any typing today in coding class?\u201d. Familiarity on a topic can bias attention. I\u2019ll deem this \u201cMinecraft Fatigue\u201d \u2013 a growing number of 12-year olds are increasingly disinterested in all things related to Minecraft. Want to demonstrate loops and 3-dimensional spaces? It better not be done in Minecraft. Kids \u201cthink\u201d they can multitask in front of a computer. That is, they think they can surf the web while also following along to a technical concept presentation. In general, I can have about 10 minutes of attention before the multitasking gears kick in. Over the last three years, we have established a fairly decent understanding of our limits \u2013technically, mentally, even emotionally \u2013 that allow us to shape technology education in a way that keeps the classes engaged while also ensuring they are actively learning new concepts. But there is a consistently large void in meeting the expectations of children who are quick to default into \u201cconsumption mode\u201d. Why would they be interested in coding \u201cpong\u201d when they can go home and play Fortnite? This is a regular barrier for success at Predicate and I\u2019d argue it hampers progression for technology education in general. Sustaining motivation in our kids is a key factor for them to stay engaged. I do not see this as an education problem but rather a technology problem \u2013 complexity that can be achieved through abstraction. Over the past year, we\u2019ve been working on an instructional platform that teaches the basics of coding through the creation of arcade games. The aptly named \u201cPredigame\u201d was originally developed by @Gabe-Linux as a way to introduce text-based coding to our younger innovators. Their response fueled continued work on the project. Today, Predigame is minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface allowing aspiring coders to familiarize themselves with computational thinking while downplaying many of the nuances that come with giving instructions to a computer. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist. Specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are directly transferrable in any journey to becoming a software engineer. We\u2019re really excited to offer Predigame predigame.io to the open source community as a solution to address the needs of intermediate coders in search of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. Predigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch). Give it a shot and let\u2019s change the way our children learn about technology! Michael Orr ( @predicatemike , @mrsqueeze ) Parent, Technologist, Sunday Sound Guy, Teacher","title":"About"},{"location":"about/#the-predicate-project-rethinking-technology-education","text":"Education should prepare young people for jobs that do not yet exist, using technologies that have not been invented, to solve problems of which we are not yet aware. - Richard Riley When I was in 10th grade I was \"academically floundering\" - a \"C\" and \"D\" student at best. No drive to do well in school. I clearly didn't understand nor did I care about the big picture. Then I took a technology class that was given by a former metal shop teacher who had a grasp of the future. This was back in the early 1990s and the computing field wasn\u2019t much at the time. We made an intercom \u2013 no, it wasn\u2019t two cans and a string \u2013 rather, it was a silk-screened circuit board. We drilled all the holes, soldered the electronic components (while also learning how each of those components worked in unison to deliver a capability). The highlight for me was bringing it home and installing MY creation in my bedroom. Even today, I remember that class vividly \u2013 it had an impact, that 25 years later continues to mold my life. I have a tremendous appreciation for the teachers who are some of the earliest role models for our children. Day in and day out, they work on the educational front lines \u2013 lecturing, encouraging, mentoring, correcting \u2013 and they see it all. A good teacher can positively impact a child for life. As a parent and technology professional, I\u2019ve often battled with the question \u2013 are we doing enough to prepare our children for the future? My day job is a Research Director at Two Six Labs \u2013 a company that pushes the boundaries of the possible to protect the future. Our mission requires that we hire some amazingly talented people and it should come as no surprise that fueling the hiring needs of a growing organization can be as challenging as creating breakthrough technologies. For today\u2019s 10-year-old in 5th grade \u2013 there\u2019s a solid seven years remaining in primary education and potentially another four (maybe more) before hitting the workforce. Adding it all up, if all these numbers hold and my math is correct, a 5th grader in 2018 would graduate high school in 2025, and college in 2029. While it seems like a long way ahead, there are things we can do today to prepare our children for the future. The challenge is that for all of the technological innovations, we\u2019ve actually made it harder for our children to learn about technology. We live in consumption driven times and, for most children, technology is only \u201cseen\u201d from the lens of a user. There is, unfortunately, an established expectation for immediate results and an equal instantaneous cloud of discouragement and frustration when something doesn\u2019t work as expected. At our home, simply the loss of electricity is a reminder of our childrens\u2019 lens through which they see technology. However, for every game, every Netflix stream, app, website, robotic vacuum cleaner, and drone, there is someone whose job it is to design the next big idea and someone who makes that idea come to life. We need to provide a different lens for seeing technology \u2013 from that of the creator. In January 2016 my wife and I started Predicate Academy \u2013 a \u201cboutique\u201d school that teaches coding to kids ages 8 and up in a small Southern New Jersey town. Prior to Predicate, I had no teaching experience, but I\u2019m a problem solver at heart, and I felt increasingly motivated to figure out how to \u201cfix\u201d technology education. My vision for Predicate was to create an environment where we change the way children learn about technology. To be honest, I had no idea how I was going to accomplish this challenge, but I\u2019ve been dissatisfied with the void of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. So that was my starting point. I was particularly attracted to the work being done by the Raspberry Pi Foundation \u2013 they use many of the same \u201ctools of the trade\u201d \u2013 Linux, command line, modern programming languages - that are used in the field. And the devices are only $35USD, so everybody can own one, even if coding isn\u2019t their thing. So, we bought Pis, lots of Pis! Since 2016, we\u2019ve put more than 1000 Pis out in the wild. An interesting paradox at Predicate is that while we focus on education, our aspiring innovators do not see Predicate Academy as a school. Why not? Frequent responses are: \u201cit\u2019s coding\u201d, \u201cwe make games\u201d, \u201cit\u2019s fun\u201d, \u201cthere is no homework\u201d. I believe I\u2019ve successfully exploited this belief by being able to bury some dense mathematical and physics concepts in the context of \u201ccoding\u201d. Computer Science is multidisciplinary field with roots in Mathematics and Physics, and going back to its roots, is rich with applied educational value. In any given week some of our classes would be converting between seconds and milliseconds, writing algebraic formulas to make a LED pulse, computing Euclidean distance, and even understanding the frequency spectrum. But teaching is incredibly hard work! While I only hold a few classes a week at Predicate, a technical glitch can wreak chaos on a class. Through it all, though, one of the most unexpected surprises is to see the weekly progression of our aspiring innovators. Their curiosity and excitement is equally contagious \u2013 far more than I would have ever estimated. I have a handful of kids that have assembled a wealth of command line foo and a few others that have mastered nmap and ssh (so much so I had to change our in-class code deployment processes). We have some very talented future technologists and it\u2019s been a true honor to be a part of their educational journey. I genuinely believe that with every passing class, we are becoming increasingly aware of better ways to deliver technology education. Direct feedback from our innovators and their parents has offered continued motivation to see our vision through. In many ways, I\u2019m reliving an educational experience I had many years ago and it\u2019s been great to see the impact that Predicate has had in our community. Predicate has allowed us to see excitement in our budding inventor \u2013 more than any other extracurricular activity he has tried! Drew may be quiet while concentrating in coding class, but then he comes home and runs to set up the latest project declaring, \u201cYou HAVE to see this,\u201d to the whole family! What an amazing and smart way to spread the love of coding and computers to our future inventors, scientists and leaders! Kevin\u2019s experience at Predicate Academy has been amazing! He has been able to apply what he has learned in his Journey sessions to create a video game in his high school\u2019s Computer System and Video Game Design class. Kevin designed a fully interactive game that required coding and creating sprites, sounds, backgrounds, objects, controllers, and levels. The game has three lives and secret Easter Egg levels. If a player passes all the levels, the game can provide up to thirty minutes of entertainment! We are thrilled that Kevin is a part of something so special at Predicate Academy! Not only is he gaining valuable real-life skills to take into the classroom and world, but Predicate has given him the knowledge and confidence to share these skills with his high school classmates! Some time ago, Ryan decided that he wanted to be a coder when he grew up. I knew he liked playing video games and Minecraft mods, so I guess that\u2019s where he got the idea that he wanted to be a coder. With the help of a junior programming book, we tried to do a little programming at home, but I was not very successful helping him to understand the concepts or make it applicable to his interests. We came across a Facebook mention of a Predicate Academy open house and went to check it out. Mr. Mike showed us the Python programming and physical computing interaction with the Raspberry Pi and Ryan was immediately hooked. The computing projects at Predicate Academy provide him with just the right mix of challenge, skill development and fun. Ryan looks forward to going to class every week and he can\u2019t wait to continue learning how to code at Predicate Academy! While we have been teaching our aspiring innovators how to code, we\u2019ve also been studying how children respond to these concepts (and, well, education in general). Painting in broad strokes, a number of consistent themes surfaced in our classes: Most kids (at least in our area) are familiar with coding prior to coming to Predicate, but it is often limited to Computer Science Education Week and the Hour of Code. Typing skills are wildly varying and navigation around special keys (especially those used in most coding languages) is a challenge. I\u2019m always amused when kids come in and ask: \u201cMr. Mike, are we going to do any typing today in coding class?\u201d. Familiarity on a topic can bias attention. I\u2019ll deem this \u201cMinecraft Fatigue\u201d \u2013 a growing number of 12-year olds are increasingly disinterested in all things related to Minecraft. Want to demonstrate loops and 3-dimensional spaces? It better not be done in Minecraft. Kids \u201cthink\u201d they can multitask in front of a computer. That is, they think they can surf the web while also following along to a technical concept presentation. In general, I can have about 10 minutes of attention before the multitasking gears kick in. Over the last three years, we have established a fairly decent understanding of our limits \u2013technically, mentally, even emotionally \u2013 that allow us to shape technology education in a way that keeps the classes engaged while also ensuring they are actively learning new concepts. But there is a consistently large void in meeting the expectations of children who are quick to default into \u201cconsumption mode\u201d. Why would they be interested in coding \u201cpong\u201d when they can go home and play Fortnite? This is a regular barrier for success at Predicate and I\u2019d argue it hampers progression for technology education in general. Sustaining motivation in our kids is a key factor for them to stay engaged. I do not see this as an education problem but rather a technology problem \u2013 complexity that can be achieved through abstraction. Over the past year, we\u2019ve been working on an instructional platform that teaches the basics of coding through the creation of arcade games. The aptly named \u201cPredigame\u201d was originally developed by @Gabe-Linux as a way to introduce text-based coding to our younger innovators. Their response fueled continued work on the project. Today, Predigame is minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface allowing aspiring coders to familiarize themselves with computational thinking while downplaying many of the nuances that come with giving instructions to a computer. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist. Specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are directly transferrable in any journey to becoming a software engineer. We\u2019re really excited to offer Predigame predigame.io to the open source community as a solution to address the needs of intermediate coders in search of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. Predigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch). Give it a shot and let\u2019s change the way our children learn about technology! Michael Orr ( @predicatemike , @mrsqueeze ) Parent, Technologist, Sunday Sound Guy, Teacher","title":"The Predicate Project: Rethinking Technology Education"},{"location":"examples/actors/","text":"Actor Framework Predigame Actors are Sprites that perform certain actions - mostly in the form of animations that make the game more realistic. Actors can perform any number of actions (walk, run, jump, attack) which are usually left up to the artist's creation of the sprite. Here are a few example Actors: Asset Licenses All static artwork has been obtained from OpenGameArt or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development. Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal: pred pull actors Then change into the actors directory. cd actors How Actors Work The artwork we use for actors are called four directional sprites in that each of the actions are repeated in each direction of movement (up, down, left, right). Actor animations may seem a bit complicated under the hood, but it is nothing more than just a sequence of still images that are refreshed at a fast enough rate to give the illusion of animation . In Predigame we store actors as .pga files in the actors directory. Every .pga file of actions and directions as highlighted in the picture below: Each of the highlighted png files capture a single frame. And when those frames are rotated fast enough the actor (in this case the zombie) appears to be attacking! Pretty cool, right? Now let's explore some animations. We provided a simple animation utility that enumerates through all possible animations for a given actor (just hit the space bar). Want to speed up or slow down the animation? Try using the - and = keys. Here's a few examples for running this utility: pred animation.py Bee pred animation.py Skeleton pred animation.py Soldier-1 pred animation.py Viking pred animation.py Witch pred animation.py Zombie-1 Next Steps Want to see actors in action? Take a look at the Making Bacon game.","title":"Actor Framework"},{"location":"examples/actors/#actor-framework","text":"Predigame Actors are Sprites that perform certain actions - mostly in the form of animations that make the game more realistic. Actors can perform any number of actions (walk, run, jump, attack) which are usually left up to the artist's creation of the sprite. Here are a few example Actors:","title":"Actor Framework"},{"location":"examples/actors/#asset-licenses","text":"All static artwork has been obtained from OpenGameArt or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development.","title":"Asset Licenses"},{"location":"examples/actors/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/actors/#getting-started","text":"To get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal: pred pull actors Then change into the actors directory. cd actors","title":"Getting Started"},{"location":"examples/actors/#how-actors-work","text":"The artwork we use for actors are called four directional sprites in that each of the actions are repeated in each direction of movement (up, down, left, right). Actor animations may seem a bit complicated under the hood, but it is nothing more than just a sequence of still images that are refreshed at a fast enough rate to give the illusion of animation . In Predigame we store actors as .pga files in the actors directory. Every .pga file of actions and directions as highlighted in the picture below: Each of the highlighted png files capture a single frame. And when those frames are rotated fast enough the actor (in this case the zombie) appears to be attacking! Pretty cool, right? Now let's explore some animations. We provided a simple animation utility that enumerates through all possible animations for a given actor (just hit the space bar). Want to speed up or slow down the animation? Try using the - and = keys. Here's a few examples for running this utility: pred animation.py Bee pred animation.py Skeleton pred animation.py Soldier-1 pred animation.py Viking pred animation.py Witch pred animation.py Zombie-1","title":"How Actors Work"},{"location":"examples/actors/#next-steps","text":"Want to see actors in action? Take a look at the Making Bacon game.","title":"Next Steps"},{"location":"examples/bacon/","text":"Making Bacon A simple maze game that demonstrates some cool things we can do with actors. Create a new file named bacon.py and start with our standard first three lines of code: Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Download Existing Game (Optional) We have a version of this game already done and ready to go. Just run the following command: pred pull bacon Then read the rest of the tutorial and follow along. Getting Started To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new bacon Now in the text editor, find and open the file bacon/game.py . Fix up your code so it looks like the example below: WIDTH = 30 HEIGHT = 18 TITLE = 'Making Bacon' Like before, these lines doesn't do much just yet. Here's a line to add a simple background ( remember backgrounds are retrieved from the backgrounds/ directory ) # use a grass background BACKGROUND = 'grass' Next we'll define a constant for the number of piggies to create. This line of code will not have any impact just yet. # how many piggies to create PIGGIES = 10 Now let's create a maze with stone images. Remember that we must have a stone in image in our images directory. maze(callback=partial(image, 'stone')) CHECKPOINT - try saving and running your code at this point. You should see something like the below picture. Alternatively, it's also possible to create a maze with just black rectangles instead of stone images. maze(callback=partial(shape, RECT, BLACK)) If all looks good with the maze, let's add our player actor. We're going for Soldier-2 . The actor will be assigned to move on keyboard arrows and every keyboard movement will call the evaluate callback. This is code that we can use to \"evaluate\" each move to make sure the player can't walk through walls. # a callback that keeps the player from running # into walls. def evaluate(action, sprite, pos): obj = at(pos) if obj and obj.tag == 'wall': return False else: return True # create a soldier on the bottom left grid cell player = actor('Soldier-2', (0, HEIGHT-1), tag='player', abortable=True) # have the solider attach to the keyboard arrows # each move is \"evaluated\" to make sure the player # doesn't walk through the wall player.keys(precondition=evaluate) # player moves at a speed of 5 with an animation rate of 2 # which flips the sprite image every other frame player.speed(5).rate(2).move_to((0, HEIGHT-1)) Let's give this a shot. Try running the code to ensure that the player can navigate the maze maze without being able to walk through walls. The Predigame platform includes an abstraction for respecting maze walls, so defining an evaluate function isn't necessary. Instead you an have the line: # have the solider attach to the keyboard arrows # each move is \"evaluated\" to make sure the player # doesn't walk through the wall player.keys(precondition=player_physics) If this works, try adding some piggies. Here is one case where the PIGGIES constant will be used. # create a piggy function def create_piggy(num): for x in range(num): pos = rand_pos() piggy = actor('Porter', pos, tag='piggy') piggy.move_to((pos)) # graze is a random walk piggy.wander(partial(graze, piggy), time=0.75) # create some piggies create_piggy(PIGGIES) Porter is an animated actor. There is a special callback function wander that allows the computer to control the movement of an actor. The wander is called for every movement, in the case of our piggy, calls the Predigame internal graze callback function which is a random and undirected movement. Try running saving these updates and running the game. We'll see the maze, our player, and now some piggies! It's possible to speed up the piggies by adjusting the time attribute for the random walk. The final part of our game is shooting! We'll create a shoot callback that is assigned to the space bar. It looks a little like an air shot, but the piggy effects are pretty cool. # shoot a weapon def shoot(): player.act(SHOOT, loop=1) #find the next object that is facing the player target = player.next_object() # if it's a piggy and that piggy is alive if target and target.tag == 'piggy' and target.health > 0: # kill the piggy and make it disappear in 3 seconds target.kill(delay=3) # tally the kill score(1) # check to see if there are any piggys left if len(get('piggy')) == 0: text('Time for some BACON!! (%s secs)' % time(), color=BLACK) gameover() # register space to shoot keydown('space', shoot) #we're keeping score score() # register the 'r' key for resetting the game keydown('r', reset) Notice we use the PIGGIES constant a second time? That's why we made it a constant. Our game needs to track all the piggies and will stop playing when PIGGIES piggies have been killed. NOTE: this code will not work if more points are assigned for each dead piggy!","title":"Making Bacon"},{"location":"examples/bacon/#making-bacon","text":"A simple maze game that demonstrates some cool things we can do with actors. Create a new file named bacon.py and start with our standard first three lines of code:","title":"Making Bacon"},{"location":"examples/bacon/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/bacon/#download-existing-game-optional","text":"We have a version of this game already done and ready to go. Just run the following command: pred pull bacon Then read the rest of the tutorial and follow along.","title":"Download Existing Game (Optional)"},{"location":"examples/bacon/#getting-started","text":"To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new bacon Now in the text editor, find and open the file bacon/game.py . Fix up your code so it looks like the example below: WIDTH = 30 HEIGHT = 18 TITLE = 'Making Bacon' Like before, these lines doesn't do much just yet. Here's a line to add a simple background ( remember backgrounds are retrieved from the backgrounds/ directory ) # use a grass background BACKGROUND = 'grass' Next we'll define a constant for the number of piggies to create. This line of code will not have any impact just yet. # how many piggies to create PIGGIES = 10 Now let's create a maze with stone images. Remember that we must have a stone in image in our images directory. maze(callback=partial(image, 'stone')) CHECKPOINT - try saving and running your code at this point. You should see something like the below picture. Alternatively, it's also possible to create a maze with just black rectangles instead of stone images. maze(callback=partial(shape, RECT, BLACK)) If all looks good with the maze, let's add our player actor. We're going for Soldier-2 . The actor will be assigned to move on keyboard arrows and every keyboard movement will call the evaluate callback. This is code that we can use to \"evaluate\" each move to make sure the player can't walk through walls. # a callback that keeps the player from running # into walls. def evaluate(action, sprite, pos): obj = at(pos) if obj and obj.tag == 'wall': return False else: return True # create a soldier on the bottom left grid cell player = actor('Soldier-2', (0, HEIGHT-1), tag='player', abortable=True) # have the solider attach to the keyboard arrows # each move is \"evaluated\" to make sure the player # doesn't walk through the wall player.keys(precondition=evaluate) # player moves at a speed of 5 with an animation rate of 2 # which flips the sprite image every other frame player.speed(5).rate(2).move_to((0, HEIGHT-1)) Let's give this a shot. Try running the code to ensure that the player can navigate the maze maze without being able to walk through walls. The Predigame platform includes an abstraction for respecting maze walls, so defining an evaluate function isn't necessary. Instead you an have the line: # have the solider attach to the keyboard arrows # each move is \"evaluated\" to make sure the player # doesn't walk through the wall player.keys(precondition=player_physics) If this works, try adding some piggies. Here is one case where the PIGGIES constant will be used. # create a piggy function def create_piggy(num): for x in range(num): pos = rand_pos() piggy = actor('Porter', pos, tag='piggy') piggy.move_to((pos)) # graze is a random walk piggy.wander(partial(graze, piggy), time=0.75) # create some piggies create_piggy(PIGGIES) Porter is an animated actor. There is a special callback function wander that allows the computer to control the movement of an actor. The wander is called for every movement, in the case of our piggy, calls the Predigame internal graze callback function which is a random and undirected movement. Try running saving these updates and running the game. We'll see the maze, our player, and now some piggies! It's possible to speed up the piggies by adjusting the time attribute for the random walk. The final part of our game is shooting! We'll create a shoot callback that is assigned to the space bar. It looks a little like an air shot, but the piggy effects are pretty cool. # shoot a weapon def shoot(): player.act(SHOOT, loop=1) #find the next object that is facing the player target = player.next_object() # if it's a piggy and that piggy is alive if target and target.tag == 'piggy' and target.health > 0: # kill the piggy and make it disappear in 3 seconds target.kill(delay=3) # tally the kill score(1) # check to see if there are any piggys left if len(get('piggy')) == 0: text('Time for some BACON!! (%s secs)' % time(), color=BLACK) gameover() # register space to shoot keydown('space', shoot) #we're keeping score score() # register the 'r' key for resetting the game keydown('r', reset) Notice we use the PIGGIES constant a second time? That's why we made it a constant. Our game needs to track all the piggies and will stop playing when PIGGIES piggies have been killed. NOTE: this code will not work if more points are assigned for each dead piggy!","title":"Getting Started"},{"location":"examples/clickninja/","text":"The Click Ninja Click Ninja was inspired by the app fruit ninja , but a little different since we have a mouse. As coders, we write the code and control how the game operates. Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal: pred pull clickninja Then change into the clickninja directory. cd clickninja Instructional Coverage We're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform. Predigame Concepts Covered: Callbacks (timing and mouse) Levels Image Sprite Effects Sound Effects The game consists of three python (only one is needed to run the game): clickninja.py - You'll create this file as part of this tutorial. clickninja-final.py - A \"camera ready\" version of the game. clickninja-levels.py - An extension of clickninja-final.py but with level support. Running the Game We recommend running all predigames from the command prompt/console/terminal. Be sure to cd into your game directory run: my_machine$ pred clickninja.py If you want to give one of the complete versions a spin, run one of these commands: my_machine$ pred clickninja-final.py my_machine$ pred clickninja-levels.py Basic Game The fundamentals for click ninja are pretty basic. Open a text editor and copy in the follow code. This will create a window of 20x14 blocks and a title of 'Click Ninja' WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' Save your changes. Let's call the file clickninja.py . Try running the game from the terminal using the pred command (you'll want to run this command from the directory where you saved the file). pred clickninja.py This game doesn't do much just yet. Just an empty window titled \"Click Ninja\". So boring. Let's add some more code. We added a bunch of comments to describe the purpose of each line. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' # the \"main\" part of our game def spawn(): # pick a random color target = choice([BLACK, ORANGE, AQUA, NAVY]) # a virual \"arc\" -- three positions where # the object will move # arc[0] bottom/off screen # arc[1] top of the arc # arc[2] bottom/off screen arc = rand_arc() # draw our sprite s = shape(CIRCLE, target, arc[0]) # move to second and third points of arc # destroy if not hit s.move_to(arc[1], arc[2], callback = s.destroy) #tell this code to run again -- sometime between 100ms to 3secs callback(spawn, rand(0.1, 3)) # keep score (top left) score(color = PURPLE) # start the game in 1 second callback(spawn, 1) # register the 'r' key to reset the game keydown('r', reset) Let's try our game now. We'll start to see a little more action. It looks a little like juggling, but we can't click on any of the circles. Notice that the last line of code will cause our game to reset if the 'r' key is pressed - this will be important a few steps later. Callback Functions When we code a game we sometimes need to create actions that will eventually occur . Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game. The Python program language requires that we specify our functions before registering them in the code. Let's look at a simple callback example. def destroy(s): s.destroy() This function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered. s = shape(CIRCLE, target, arc[0]).clicked(destroy) That's right.. We can basically add a .clicked(destroy) to the end of our shape definition and register a callback function that won't get called until the player clicks on the circle. Here's the full code now (we took out all the comments to make it a little easier to read). Let's give it a quick test. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): s.destroy() def spawn(): target = choice([BLACK, ORANGE, AQUA, NAVY]) arc = rand_arc() s = shape(CIRCLE, target, arc[0]).clicked(destroy) s.move_to(arc[1], arc[2], callback = s.destroy) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset) Keeping Score We can modify our destroy callback function to score the number of things we destroy. It's just requires adding a line of code. def destroy(s): # vvvv - add the line below - vvvv score(1) # ^^^^ - add the line above - ^^^^ s.destroy() Version 1: Keep Alive At this point we almost have a fully functional game. We just need to add a keep alive function. That is, we want to make sure we stop the game if we don't click on a circle. Look for this line of code in our game: s.move_to(arc[1], arc[2], callback= s.destroy) The way this code is written, the callback function s.destroy will be called if nothing else happens to the shape. Let's create a new callback function failure(s) that will pause the game. Notice we'll use something called a lambda. We'll be sure to discuss what that means at a later point. s.move_to(arc[1], arc[2], callback = lambda: failure(s)) Let's make sure we create the failure function. We'll put that right under our destroy callback function. def failure(s): text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) That's it! Here's the complete code if you need it. Go ahead and enjoy Version 1. How many circles can you click? WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(1) s.destroy() def failure(s): text('You Survived %s seconds' % time(), MAROON) gameover() def spawn(): target = choice([BLACK, ORANGE, AQUA, NAVY]) arc = rand_arc() s = shape(CIRCLE, target, arc[0]).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset) Version 2: Throwing Food Let's swap out circles for pictures of food. The predigame platform makes it easy to load pictures in your game. Just copy them to an images subdirectory. The click ninja includes a few food images to get started. Let's see what we have. my_machine$ ls images bananas.png cherries.png ham.png icee.png pizza.png taco.png bomb.png fries.png hotdog.png olives.png redsplat.png Let's say we want to load the hotdog image. We can do that with a single line of code. image('hotdog', (x, y), size=size) We'll see that to load the image we need the first part of the file, the initial x and y coordinates, and the size (default is 1.0 ). Notice that we don't need to include the images directory or the .png file extension. Predigame takes care of that for us. So, now let's replace the circles with images. To do that we're going to rewrite our spawn() function. def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) arc = rand_arc() s = image(target, arc[0], size=size) s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) In addition to drawing images, notice that we also have variables for speed and size . As our code runs anytime we'll draw a random target with a random speed and random size. Notice the randint functions, such as randint(2, 10) . This will randomly pick a number between 2 and 10. Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(1) s.destroy() def failure(s): text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) arc = rand_arc() s = image(target, arc[0], size=size) s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset) Version 3: Bombs Away Instead of just drawing food, let's throw some bombs too! Unlike food, our players can't click on a bomb or else.. well, game over! For starters, let's assume there is a 25% (1 out of 4) chance a bomb will be thrown. In code we'll want to add two lines in our spawn() function. target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) # vvv - add this code - vvv if randint(1, 4) == 2: target = 'bomb' # ^^^ - add this code - ^^^ The two lines we just added will replace the target variable with bomb with a 25% probability. Now, we said the player can't click on a bomb (game over otherwise) and, unlike food, if they don't click, we don't want to stop the game (because not clicking the bomb is what we want). This means we'll need to change the following lines: # old code s = image(target, arc[0], size=size) s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) And check to see if target is a bomb. # new code s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(1) s.destroy() def failure(s): text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset) Version 4: Better Score Our game ends quickly when we make a single mistake and that can make for a frustrating experience for even the best player. Let's improve our scoring with a few basic rules: Reward the player five points for clicking food Penalize the player twenty points for missing a food item Halt the game when the number of points falls below zero Halt the game if the player clicks on a bomb Here's our improved destroy and failure functions. Change your functions so they look like these: def destroy(s): score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: text('You Survived %s seconds' % time(), MAROON) gameover() Notice that in failure we added the line if s.name == 'bomb' or score() < 0: ? Since our failure function is called if we don't click on a food or if we click on a bomb, we need to make sure that we end the game immediately if the player clicks on the bomb. It's a simple adjustment that will allow our code to be general enough for multiple cases. Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset) Version 5: The Bonus Taco Just like a bomb, we can add a bonus taco that flies across the screen. We don't want to award our player too much, so we'll give the taco a 10% (1 out of 10) probability of showing on the screen. Here's what we'll need to change: if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' And if we pick a taco for a target, we'll need to change how the taco moves as we want it to fly across - not in an arc formation. if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) elif target == 'taco': s.speed(5).clicked(destroy) s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) Now when a user clicks on a taco, we want to reward some bonus points, so we'll need to tweak the destroy function. def destroy(s): if s.name == 'taco': score(50) else: score(5) s.destroy() Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): if s.name == 'taco': score(50) else: score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) elif target == 'taco': s.speed(5).clicked(destroy) s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset) Other Fun Things Spinning Sprites We can code any image object to spin... s.speed(speed).spin().clicked(failure) And the spin function can be given a number to control the rate # fast spinning s.speed(speed).spin(0.1).clicked(failure) # or # slow spinning s.speed(speed).spin(2.0).clicked(failure) Background Wallpaper A white background can get a little boring. Try adding this line to the top of your code: TITLE = 'Click Ninja' # load 'background/board.jpg' as the wallpaper BACKGROUND = 'board' BACKGROUND files are stored in the background directory. Sound Effects Just like images, predigame supports sound effects. We've preloaded a few for the game. For instance, you can add a launching sound to the spawn() function: target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' sound('launch') You can add effects to when a user clicks on a food item or even looses. def destroy(s): sound('swoosh') if s.name == 'taco': score(50) else: score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: sound('scream') text('You Survived %s seconds' % time(), MAROON) gameover() Effects While it's cool to click away on our food. We can also introduce a fading effect that makes it slowly dissolve on contact. To do this, simply change the last line in the destroy function. def destroy(s): sound('swoosh') if s.name == 'taco': score(50) else: score(5) # s.destroy() # have the sprite fade out in 750 ms s.fade(0.75) Red Splat on Contact Another fun thing is to leave a splat mark behind for each food item the player strikes. To do this, it's a simple extension to the destroy callback function. def destroy(s): sound('swoosh') if s.name == 'taco': score(50) else: score(5) # draw a splatting image at the position of the strike # make it fade away after 10 seconds image('redsplat', s.event_pos, 2).fade(1.0) s.destroy() Here the s variable (which is short for sprite) has a position. So we want to draw the red splat image at the location of the strike. Exploding Bombs Accidents happen! If the player accidentally clicks on a bomb, we should have them explode. It's a simple modification to the failure function. def failure(s): score(-20) # make the bomb explode if s.name == 'bomb': s.destroy() image('explode', s.center, 10).pulse(0.05) if s.name == 'bomb' or score() < 0: sound('scream') text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) The key to the explosion is the .pulse(0.05) function call. The game will quickly pause, but the pulse is fast enough to provide an explosion effect. Levels! Click Ninja is 1000x better when you add levels! We won't get into the coding specifics for levels here - that'll be covered in other Predigame examples, but here is a leveled version of the code, with plenty of inline comments: WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja (Leveled Edition)' # handle to current level (used by generic functions) current_level = None def destroy(s): sound('swoosh') current_level.hit() if s.name == 'taco': score(50) else: score(5) # draw a splatting image at the center position of the image image('redsplat', center=s.event_pos, size=2).fade(1.0) # add a fade out effect s.fade(0.25) def failure(s): score(-20) if s.name == 'bomb': s.destroy() image('explode', center=s.center, size=10).pulse(0.05) if s.name == 'bomb' or score() < 0: sound('scream') text('You Survived %s seconds' % current_level.get_duration(), MAROON) callback(gameover, 0.01) def spawn(min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=1, max_rate=1): \"\"\" leveled version includes min/max parameters \"\"\" size = rand(min_size, max_size) speed = rand(min_speed,max_speed) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' sound('launch') arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).spin(1).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) elif target == 'taco': s.speed(5).spin().clicked(destroy) s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(partial(spawn, min_speed=min_speed, max_speed=max_speed, min_rate=min_rate, max_rate=max_rate, min_size=min_size, max_size=max_size), rand(min_rate, max_rate)) class NinjaLevel(Level): \"\"\" defines the behavior of a single level \"\"\" def __init__(self, level=1, total_hits=0, duration=0, min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=3, max_rate=3): self.level = level self.min_size = min_size # prevent sizes from getting too small if self.min_size < 0.1: self.min_size = 0.1 self.min_speed = min_speed # prevent speed from getting too small if self.min_speed < 0.1: self.min_speed = 0.1 self.min_rate = min_rate # prevent launch rates from getting too small if self.min_rate < 0: self.min_rate = 0 self.max_size = max_size self.max_speed = max_speed self.max_rate = max_rate self.hits = 0 self.total_hits = total_hits self.duration = duration def hit(self): self.hits += 1 self.total_hits += 1 score(self.total_hits, pos=LOWER_LEFT) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" global current_level current_level = self # BACKGROUND (randomly selected) background() # SCORE BOARD score(0, prefix='Score: ') score(self.total_hits, pos=LOWER_LEFT, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ') # START LEVEL callback(partial(spawn, min_speed=self.min_speed, max_speed=self.max_speed, min_rate=self.min_rate, max_rate=self.max_rate, min_size=self.min_size, max_size=self.max_size), 1) # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" 10 hits are required to complete a level \"\"\" if self.hits == 10: return True else: return False def next(self): \"\"\" load the next level \"\"\" return NinjaLevel(level=self.level+1, total_hits=self.total_hits, duration=score(pos=LOWER_RIGHT), min_speed=self.min_speed-0.1, max_speed=self.max_speed+0.5, min_rate=self.min_rate-0.5, max_rate=self.max_rate-0.1, min_size=self.min_size-0.5, max_size=self.max_size) level(NinjaLevel(1))","title":"Click Ninja"},{"location":"examples/clickninja/#the-click-ninja","text":"Click Ninja was inspired by the app fruit ninja , but a little different since we have a mouse. As coders, we write the code and control how the game operates.","title":"The Click Ninja"},{"location":"examples/clickninja/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/clickninja/#getting-started","text":"To get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal: pred pull clickninja Then change into the clickninja directory. cd clickninja","title":"Getting Started"},{"location":"examples/clickninja/#instructional-coverage","text":"We're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform. Predigame Concepts Covered: Callbacks (timing and mouse) Levels Image Sprite Effects Sound Effects The game consists of three python (only one is needed to run the game): clickninja.py - You'll create this file as part of this tutorial. clickninja-final.py - A \"camera ready\" version of the game. clickninja-levels.py - An extension of clickninja-final.py but with level support.","title":"Instructional Coverage"},{"location":"examples/clickninja/#running-the-game","text":"We recommend running all predigames from the command prompt/console/terminal. Be sure to cd into your game directory run: my_machine$ pred clickninja.py If you want to give one of the complete versions a spin, run one of these commands: my_machine$ pred clickninja-final.py my_machine$ pred clickninja-levels.py","title":"Running the Game"},{"location":"examples/clickninja/#basic-game","text":"The fundamentals for click ninja are pretty basic. Open a text editor and copy in the follow code. This will create a window of 20x14 blocks and a title of 'Click Ninja' WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' Save your changes. Let's call the file clickninja.py . Try running the game from the terminal using the pred command (you'll want to run this command from the directory where you saved the file). pred clickninja.py This game doesn't do much just yet. Just an empty window titled \"Click Ninja\". So boring. Let's add some more code. We added a bunch of comments to describe the purpose of each line. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' # the \"main\" part of our game def spawn(): # pick a random color target = choice([BLACK, ORANGE, AQUA, NAVY]) # a virual \"arc\" -- three positions where # the object will move # arc[0] bottom/off screen # arc[1] top of the arc # arc[2] bottom/off screen arc = rand_arc() # draw our sprite s = shape(CIRCLE, target, arc[0]) # move to second and third points of arc # destroy if not hit s.move_to(arc[1], arc[2], callback = s.destroy) #tell this code to run again -- sometime between 100ms to 3secs callback(spawn, rand(0.1, 3)) # keep score (top left) score(color = PURPLE) # start the game in 1 second callback(spawn, 1) # register the 'r' key to reset the game keydown('r', reset) Let's try our game now. We'll start to see a little more action. It looks a little like juggling, but we can't click on any of the circles. Notice that the last line of code will cause our game to reset if the 'r' key is pressed - this will be important a few steps later.","title":"Basic Game"},{"location":"examples/clickninja/#callback-functions","text":"When we code a game we sometimes need to create actions that will eventually occur . Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game. The Python program language requires that we specify our functions before registering them in the code. Let's look at a simple callback example. def destroy(s): s.destroy() This function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered. s = shape(CIRCLE, target, arc[0]).clicked(destroy) That's right.. We can basically add a .clicked(destroy) to the end of our shape definition and register a callback function that won't get called until the player clicks on the circle. Here's the full code now (we took out all the comments to make it a little easier to read). Let's give it a quick test. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): s.destroy() def spawn(): target = choice([BLACK, ORANGE, AQUA, NAVY]) arc = rand_arc() s = shape(CIRCLE, target, arc[0]).clicked(destroy) s.move_to(arc[1], arc[2], callback = s.destroy) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset)","title":"Callback Functions"},{"location":"examples/clickninja/#keeping-score","text":"We can modify our destroy callback function to score the number of things we destroy. It's just requires adding a line of code. def destroy(s): # vvvv - add the line below - vvvv score(1) # ^^^^ - add the line above - ^^^^ s.destroy()","title":"Keeping Score"},{"location":"examples/clickninja/#version-1-keep-alive","text":"At this point we almost have a fully functional game. We just need to add a keep alive function. That is, we want to make sure we stop the game if we don't click on a circle. Look for this line of code in our game: s.move_to(arc[1], arc[2], callback= s.destroy) The way this code is written, the callback function s.destroy will be called if nothing else happens to the shape. Let's create a new callback function failure(s) that will pause the game. Notice we'll use something called a lambda. We'll be sure to discuss what that means at a later point. s.move_to(arc[1], arc[2], callback = lambda: failure(s)) Let's make sure we create the failure function. We'll put that right under our destroy callback function. def failure(s): text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) That's it! Here's the complete code if you need it. Go ahead and enjoy Version 1. How many circles can you click? WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(1) s.destroy() def failure(s): text('You Survived %s seconds' % time(), MAROON) gameover() def spawn(): target = choice([BLACK, ORANGE, AQUA, NAVY]) arc = rand_arc() s = shape(CIRCLE, target, arc[0]).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset)","title":"Version 1: Keep Alive"},{"location":"examples/clickninja/#version-2-throwing-food","text":"Let's swap out circles for pictures of food. The predigame platform makes it easy to load pictures in your game. Just copy them to an images subdirectory. The click ninja includes a few food images to get started. Let's see what we have. my_machine$ ls images bananas.png cherries.png ham.png icee.png pizza.png taco.png bomb.png fries.png hotdog.png olives.png redsplat.png Let's say we want to load the hotdog image. We can do that with a single line of code. image('hotdog', (x, y), size=size) We'll see that to load the image we need the first part of the file, the initial x and y coordinates, and the size (default is 1.0 ). Notice that we don't need to include the images directory or the .png file extension. Predigame takes care of that for us. So, now let's replace the circles with images. To do that we're going to rewrite our spawn() function. def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) arc = rand_arc() s = image(target, arc[0], size=size) s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) In addition to drawing images, notice that we also have variables for speed and size . As our code runs anytime we'll draw a random target with a random speed and random size. Notice the randint functions, such as randint(2, 10) . This will randomly pick a number between 2 and 10. Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(1) s.destroy() def failure(s): text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) arc = rand_arc() s = image(target, arc[0], size=size) s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset)","title":"Version 2: Throwing Food"},{"location":"examples/clickninja/#version-3-bombs-away","text":"Instead of just drawing food, let's throw some bombs too! Unlike food, our players can't click on a bomb or else.. well, game over! For starters, let's assume there is a 25% (1 out of 4) chance a bomb will be thrown. In code we'll want to add two lines in our spawn() function. target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) # vvv - add this code - vvv if randint(1, 4) == 2: target = 'bomb' # ^^^ - add this code - ^^^ The two lines we just added will replace the target variable with bomb with a 25% probability. Now, we said the player can't click on a bomb (game over otherwise) and, unlike food, if they don't click, we don't want to stop the game (because not clicking the bomb is what we want). This means we'll need to change the following lines: # old code s = image(target, arc[0], size=size) s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) And check to see if target is a bomb. # new code s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(1) s.destroy() def failure(s): text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset)","title":"Version 3: Bombs Away"},{"location":"examples/clickninja/#version-4-better-score","text":"Our game ends quickly when we make a single mistake and that can make for a frustrating experience for even the best player. Let's improve our scoring with a few basic rules: Reward the player five points for clicking food Penalize the player twenty points for missing a food item Halt the game when the number of points falls below zero Halt the game if the player clicks on a bomb Here's our improved destroy and failure functions. Change your functions so they look like these: def destroy(s): score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: text('You Survived %s seconds' % time(), MAROON) gameover() Notice that in failure we added the line if s.name == 'bomb' or score() < 0: ? Since our failure function is called if we don't click on a food or if we click on a bomb, we need to make sure that we end the game immediately if the player clicks on the bomb. It's a simple adjustment that will allow our code to be general enough for multiple cases. Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset)","title":"Version 4: Better Score"},{"location":"examples/clickninja/#version-5-the-bonus-taco","text":"Just like a bomb, we can add a bonus taco that flies across the screen. We don't want to award our player too much, so we'll give the taco a 10% (1 out of 10) probability of showing on the screen. Here's what we'll need to change: if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' And if we pick a taco for a target, we'll need to change how the taco moves as we want it to fly across - not in an arc formation. if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) elif target == 'taco': s.speed(5).clicked(destroy) s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) Now when a user clicks on a taco, we want to reward some bonus points, so we'll need to tweak the destroy function. def destroy(s): if s.name == 'taco': score(50) else: score(5) s.destroy() Let's try running our code. Here's the complete version. WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja' def destroy(s): if s.name == 'taco': score(50) else: score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) def spawn(): speed = randint(2, 10) size = randint(1,4) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) elif target == 'taco': s.speed(5).clicked(destroy) s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(spawn, rand(0.1, 3)) score(color = PURPLE) callback(spawn, 1) keydown('r', reset)","title":"Version 5: The Bonus Taco"},{"location":"examples/clickninja/#other-fun-things","text":"","title":"Other Fun Things"},{"location":"examples/clickninja/#spinning-sprites","text":"We can code any image object to spin... s.speed(speed).spin().clicked(failure) And the spin function can be given a number to control the rate # fast spinning s.speed(speed).spin(0.1).clicked(failure) # or # slow spinning s.speed(speed).spin(2.0).clicked(failure)","title":"Spinning Sprites"},{"location":"examples/clickninja/#background-wallpaper","text":"A white background can get a little boring. Try adding this line to the top of your code: TITLE = 'Click Ninja' # load 'background/board.jpg' as the wallpaper BACKGROUND = 'board' BACKGROUND files are stored in the background directory.","title":"Background Wallpaper"},{"location":"examples/clickninja/#sound-effects","text":"Just like images, predigame supports sound effects. We've preloaded a few for the game. For instance, you can add a launching sound to the spawn() function: target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' sound('launch') You can add effects to when a user clicks on a food item or even looses. def destroy(s): sound('swoosh') if s.name == 'taco': score(50) else: score(5) s.destroy() def failure(s): score(-20) if s.name == 'bomb' or score() < 0: sound('scream') text('You Survived %s seconds' % time(), MAROON) gameover()","title":"Sound Effects"},{"location":"examples/clickninja/#effects","text":"While it's cool to click away on our food. We can also introduce a fading effect that makes it slowly dissolve on contact. To do this, simply change the last line in the destroy function. def destroy(s): sound('swoosh') if s.name == 'taco': score(50) else: score(5) # s.destroy() # have the sprite fade out in 750 ms s.fade(0.75)","title":"Effects"},{"location":"examples/clickninja/#red-splat-on-contact","text":"Another fun thing is to leave a splat mark behind for each food item the player strikes. To do this, it's a simple extension to the destroy callback function. def destroy(s): sound('swoosh') if s.name == 'taco': score(50) else: score(5) # draw a splatting image at the position of the strike # make it fade away after 10 seconds image('redsplat', s.event_pos, 2).fade(1.0) s.destroy() Here the s variable (which is short for sprite) has a position. So we want to draw the red splat image at the location of the strike.","title":"Red Splat on Contact"},{"location":"examples/clickninja/#exploding-bombs","text":"Accidents happen! If the player accidentally clicks on a bomb, we should have them explode. It's a simple modification to the failure function. def failure(s): score(-20) # make the bomb explode if s.name == 'bomb': s.destroy() image('explode', s.center, 10).pulse(0.05) if s.name == 'bomb' or score() < 0: sound('scream') text('You Survived %s seconds' % time(), MAROON) callback(gameover, 0.01) The key to the explosion is the .pulse(0.05) function call. The game will quickly pause, but the pulse is fast enough to provide an explosion effect.","title":"Exploding Bombs"},{"location":"examples/clickninja/#levels","text":"Click Ninja is 1000x better when you add levels! We won't get into the coding specifics for levels here - that'll be covered in other Predigame examples, but here is a leveled version of the code, with plenty of inline comments: WIDTH = 20 HEIGHT = 14 TITLE = 'Click Ninja (Leveled Edition)' # handle to current level (used by generic functions) current_level = None def destroy(s): sound('swoosh') current_level.hit() if s.name == 'taco': score(50) else: score(5) # draw a splatting image at the center position of the image image('redsplat', center=s.event_pos, size=2).fade(1.0) # add a fade out effect s.fade(0.25) def failure(s): score(-20) if s.name == 'bomb': s.destroy() image('explode', center=s.center, size=10).pulse(0.05) if s.name == 'bomb' or score() < 0: sound('scream') text('You Survived %s seconds' % current_level.get_duration(), MAROON) callback(gameover, 0.01) def spawn(min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=1, max_rate=1): \"\"\" leveled version includes min/max parameters \"\"\" size = rand(min_size, max_size) speed = rand(min_speed,max_speed) target = choice(['bananas', 'cherries', 'olives', 'ham', 'hotdog', 'fries','icee', 'pizza']) if randint(1, 4) == 2: target = 'bomb' if randint(1, 10) == 5: target = 'taco' sound('launch') arc = rand_arc() s = image(target, arc[0], size=size) if target == 'bomb': s.speed(speed).spin(1).clicked(failure) s.move_to(arc[1], arc[2], callback = s.destroy) elif target == 'taco': s.speed(5).spin().clicked(destroy) s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy) else: s.speed(speed).clicked(destroy) s.move_to(arc[1], arc[2], callback = lambda: failure(s)) callback(partial(spawn, min_speed=min_speed, max_speed=max_speed, min_rate=min_rate, max_rate=max_rate, min_size=min_size, max_size=max_size), rand(min_rate, max_rate)) class NinjaLevel(Level): \"\"\" defines the behavior of a single level \"\"\" def __init__(self, level=1, total_hits=0, duration=0, min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=3, max_rate=3): self.level = level self.min_size = min_size # prevent sizes from getting too small if self.min_size < 0.1: self.min_size = 0.1 self.min_speed = min_speed # prevent speed from getting too small if self.min_speed < 0.1: self.min_speed = 0.1 self.min_rate = min_rate # prevent launch rates from getting too small if self.min_rate < 0: self.min_rate = 0 self.max_size = max_size self.max_speed = max_speed self.max_rate = max_rate self.hits = 0 self.total_hits = total_hits self.duration = duration def hit(self): self.hits += 1 self.total_hits += 1 score(self.total_hits, pos=LOWER_LEFT) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" global current_level current_level = self # BACKGROUND (randomly selected) background() # SCORE BOARD score(0, prefix='Score: ') score(self.total_hits, pos=LOWER_LEFT, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ') # START LEVEL callback(partial(spawn, min_speed=self.min_speed, max_speed=self.max_speed, min_rate=self.min_rate, max_rate=self.max_rate, min_size=self.min_size, max_size=self.max_size), 1) # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" 10 hits are required to complete a level \"\"\" if self.hits == 10: return True else: return False def next(self): \"\"\" load the next level \"\"\" return NinjaLevel(level=self.level+1, total_hits=self.total_hits, duration=score(pos=LOWER_RIGHT), min_speed=self.min_speed-0.1, max_speed=self.max_speed+0.5, min_rate=self.min_rate-0.5, max_rate=self.max_rate-0.1, min_size=self.min_size-0.5, max_size=self.max_size) level(NinjaLevel(1))","title":"Levels!"},{"location":"examples/fireworks/","text":"Fireworks! A relatively simple and fun Predigame example that highlights image sprites, callbacks, and sound effects. Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit http://predigame.io for installation instructions. Download Existing Game (Optional) We have a version of this game already done and ready to go. Just run the following command: pred pull fireworks Then read the rest of the tutorial and follow along. Getting Started To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new fireworks Now in the text editor, find and open the file fireworks/game.py . Now let's get started! For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and window title: WIDTH = 30 HEIGHT = 20 TITLE = 'Fireworks!' Since fireworks normally launch in the evening, we'll paint our background black. # make the background black BACKGROUND = (0,0,0) This defines the background using a RGB (RED, GREEN, BLUE) tuple. We also have some constants defined for common colors, so setting the line this way would have the same effect: # make the background black BACKGROUND = BLACK For your game, you may wish to use a background image instead. That's possible provided that the image is stored in the backgrounds/ directory. Then the code would look something like this ( NOTE that we don't use file extensions for images, backgrounds, and sounds ). # use a background image BACKGROUND = 'castle_at_night' The core of the game consists of two callbacks. First is a one to launch the firework and the second to create the explosion effect. Let's cover launching first: def launch(): # play a sound sound('fireworks') # create a random position with some padding to keep away from edges p = rand_pos(x_padding=5, y_padding=10) # create a really small yellow circle # position circle at point p's x coordinate but under the viewable area s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1) # move the sprite to the designated area # callback (destroy) will be invoked when sprite arrives at destination s.speed(15).move_to(p, callback=s.destroy) # schedule to have the launch function called again.. # some random time between 0 and 3 seconds callback(launch, rand(0, 3)) # start show in 1 second! callback(launch, 1) Now let's give it a test run! pred game.py You'll notice that fireworks launch and sound effects are playing, but there is no explosion ! That's due to this line: s.speed(15).move_to(p, callback=s.destroy) Once the yellow circle sprite moves to point p the callback s.destroy is invoked. As the name implies, that simply destroys the sprite. Now let's handle the explosion. We'll define a function to handle that effect: def explode(s): s.destroy() # pick a random number between 1 and 5 num = randint(1, 5) # load the fireworks image sprite img = image('fireworks-'+str(num), s.pos, size=0.5) # make the image pulse (get big), destroy between 0.1 and 4 seconds img.pulse(time=4, size=10).destruct(rand(0.1,4)) In our example, we currently have five fireworks images in our images/ directory: fireworks-1.png fireworks-2.png fireworks-3.png fireworks-4.png fireworks-5.png Go ahead a find some fireworks of your own. Transparent images always work best. You'll want to label them similar to how we did so it's easy to randomly pick one of the images. The randint(1,5) line simply picks a number between 1 and 5 at random. The image will initially render at roughly sized at one half a grid cell. The image will slowly pulse with a four second interval. Note that the image will destruct between 0.1 and 4 seconds, so this basically means the firework will expand and never contract. With the explosion defined, we'll now want to go back and reset the yellow sprite callback to use our new explode function: s.speed(15).move_to(p, callback=partial(explode, s)) Here's the completed version (without comments): WIDTH = 30 HEIGHT = 20 TITLE = 'Fireworks!' BACKGROUND = (0,0,0) def explode(s): s.destroy() num = randint(1, 5) img = image('fireworks-'+str(num), s.pos, size=0.5) img.pulse(time=4, size=10).destruct(rand(0.1,4)) def launch(): sound('fireworks') p = rand_pos(x_padding=5, y_padding=10) s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1) s.speed(15).move_to(p, callback=partial(explode, s)) callback(launch, rand(0, 3)) callback(launch, 1) Save your changes and enjoy the show! pred game.py","title":"Fireworks!"},{"location":"examples/fireworks/#fireworks","text":"A relatively simple and fun Predigame example that highlights image sprites, callbacks, and sound effects.","title":"Fireworks!"},{"location":"examples/fireworks/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/fireworks/#download-existing-game-optional","text":"We have a version of this game already done and ready to go. Just run the following command: pred pull fireworks Then read the rest of the tutorial and follow along.","title":"Download Existing Game (Optional)"},{"location":"examples/fireworks/#getting-started","text":"To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new fireworks Now in the text editor, find and open the file fireworks/game.py . Now let's get started! For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and window title: WIDTH = 30 HEIGHT = 20 TITLE = 'Fireworks!' Since fireworks normally launch in the evening, we'll paint our background black. # make the background black BACKGROUND = (0,0,0) This defines the background using a RGB (RED, GREEN, BLUE) tuple. We also have some constants defined for common colors, so setting the line this way would have the same effect: # make the background black BACKGROUND = BLACK For your game, you may wish to use a background image instead. That's possible provided that the image is stored in the backgrounds/ directory. Then the code would look something like this ( NOTE that we don't use file extensions for images, backgrounds, and sounds ). # use a background image BACKGROUND = 'castle_at_night' The core of the game consists of two callbacks. First is a one to launch the firework and the second to create the explosion effect. Let's cover launching first: def launch(): # play a sound sound('fireworks') # create a random position with some padding to keep away from edges p = rand_pos(x_padding=5, y_padding=10) # create a really small yellow circle # position circle at point p's x coordinate but under the viewable area s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1) # move the sprite to the designated area # callback (destroy) will be invoked when sprite arrives at destination s.speed(15).move_to(p, callback=s.destroy) # schedule to have the launch function called again.. # some random time between 0 and 3 seconds callback(launch, rand(0, 3)) # start show in 1 second! callback(launch, 1) Now let's give it a test run! pred game.py You'll notice that fireworks launch and sound effects are playing, but there is no explosion ! That's due to this line: s.speed(15).move_to(p, callback=s.destroy) Once the yellow circle sprite moves to point p the callback s.destroy is invoked. As the name implies, that simply destroys the sprite. Now let's handle the explosion. We'll define a function to handle that effect: def explode(s): s.destroy() # pick a random number between 1 and 5 num = randint(1, 5) # load the fireworks image sprite img = image('fireworks-'+str(num), s.pos, size=0.5) # make the image pulse (get big), destroy between 0.1 and 4 seconds img.pulse(time=4, size=10).destruct(rand(0.1,4)) In our example, we currently have five fireworks images in our images/ directory: fireworks-1.png fireworks-2.png fireworks-3.png fireworks-4.png fireworks-5.png Go ahead a find some fireworks of your own. Transparent images always work best. You'll want to label them similar to how we did so it's easy to randomly pick one of the images. The randint(1,5) line simply picks a number between 1 and 5 at random. The image will initially render at roughly sized at one half a grid cell. The image will slowly pulse with a four second interval. Note that the image will destruct between 0.1 and 4 seconds, so this basically means the firework will expand and never contract. With the explosion defined, we'll now want to go back and reset the yellow sprite callback to use our new explode function: s.speed(15).move_to(p, callback=partial(explode, s)) Here's the completed version (without comments): WIDTH = 30 HEIGHT = 20 TITLE = 'Fireworks!' BACKGROUND = (0,0,0) def explode(s): s.destroy() num = randint(1, 5) img = image('fireworks-'+str(num), s.pos, size=0.5) img.pulse(time=4, size=10).destruct(rand(0.1,4)) def launch(): sound('fireworks') p = rand_pos(x_padding=5, y_padding=10) s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1) s.speed(15).move_to(p, callback=partial(explode, s)) callback(launch, rand(0, 3)) callback(launch, 1) Save your changes and enjoy the show! pred game.py","title":"Getting Started"},{"location":"examples/levels/","text":"Levels Predigame utilizes Python Classes to implement a game with levels. If you're new to the class abstraction be sure to click on the previous link and learn about a pretty cool way of organizing your code. A Predigame level consists of three key ingredients: a setup() member containing any code that should run prior to the start of a given level. a completed() member that assesses if a given objective has been established. a next() member that instructs Predigame on the next level to load. With that in mind, let's take a look at two mini-game examples. Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new levels Now in the text editor, find and open the file levels/game.py . Now let's get started! Statically Defined Levels This example is pretty basic. We introduce game with two statically defined levels - level 1 draws one circle, level 2 draws two circles. Yup. Pretty basic, but it illustrates the mechanics of what it takes to create a level. # This is a simple game with two levels WIDTH = 30 HEIGHT = 20 TITLE = 'Simple Two Level Example' # hold a reference to the current level current_level = None # support functions used in every level def pop(s): # destroy the circle s.destroy() # tally the hit current_level.hit() class PopLevel1(Level): def __init__(self, duration): self.hits = 0 self.duration = duration def hit(self): # update the number of hits self.hits += 1 # refresh the score score(self.hits) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" # Hold a reference to this level global current_level current_level = self # create one target at a random location shape(CIRCLE).clicked(pop) # SCORE BOARD score(0, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" level is complete when all targets have been destroyed \"\"\" # completed if one circle clicked if self.hits == 1: return True else: return False def next(self): \"\"\" load the next level \"\"\" # preserve the time return PopLevel2(duration=score(pos=LOWER_RIGHT)) class PopLevel2(Level): def __init__(self, duration): self.hits = 0 self.duration = duration def hit(self): # update the number of hits self.hits += 1 # refresh the score score(self.hits) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" # Hold a reference to this level global current_level current_level = self # create two circles at random locations shape(CIRCLE).clicked(pop) shape(CIRCLE).clicked(pop) # SCORE BOARD score(0, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" level is complete when all targets have been destroyed \"\"\" # completed if two circles clicked if self.hits == 2: return True else: return False def next(self): \"\"\" end the game.. there is no next level \"\"\" text(\"YOU SOLVED ALL LEVELS!\") gameover() # start the game at level 1 level(PopLevel1(1)) Dynamic Levels This example builds on the previous but now increases the number of circles that are drawn with each level. We've also introduced a countdown timer. The objective of this game is to see how many levels the player can reach by clicking all circles within 10 seconds. You'll notice that there is much less code in this examples. Dynamic levels are fun! # Create a basic game that demonstrates how to create levels # In each level, the player has to pop all the circles in 10 seconds # A new circle will be added for each level WIDTH = 30 HEIGHT = 20 TITLE = 'Simple Levels Example' current_level = None def timer(): text(\"You survived \" + str(current_level.get_duration()) + \" seconds.\") gameover() def pop(s): s.destroy() current_level.hit() class PopLevel(Level): def __init__(self, level=1, duration=0): self.level = level self.hits = 0 self.time_remaining = 10 self.duration = duration def hit(self): # update the number of hits self.hits += 1 # refresh the score score(self.hits) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" # Hold a reference to this level global current_level current_level = self # TARGETS for x in range(self.level): shape(CIRCLE).clicked(pop) # SCORE BOARD score(0, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_LEFT, color=BLACK, value=self.time_remaining, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Remaining: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ') # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" level is complete when all targets have been destroyed \"\"\" if self.hits == self.level: return True else: return False def next(self): \"\"\" load the next level \"\"\" return PopLevel(level=self.level+1, duration=score(pos=LOWER_RIGHT)) level(PopLevel(1)) Next Steps Want to see levels in action? Take a look at the Click Ninja and Zombie Madness games.","title":"Levels"},{"location":"examples/levels/#levels","text":"Predigame utilizes Python Classes to implement a game with levels. If you're new to the class abstraction be sure to click on the previous link and learn about a pretty cool way of organizing your code. A Predigame level consists of three key ingredients: a setup() member containing any code that should run prior to the start of a given level. a completed() member that assesses if a given objective has been established. a next() member that instructs Predigame on the next level to load. With that in mind, let's take a look at two mini-game examples.","title":"Levels"},{"location":"examples/levels/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/levels/#getting-started","text":"To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new levels Now in the text editor, find and open the file levels/game.py . Now let's get started!","title":"Getting Started"},{"location":"examples/levels/#statically-defined-levels","text":"This example is pretty basic. We introduce game with two statically defined levels - level 1 draws one circle, level 2 draws two circles. Yup. Pretty basic, but it illustrates the mechanics of what it takes to create a level. # This is a simple game with two levels WIDTH = 30 HEIGHT = 20 TITLE = 'Simple Two Level Example' # hold a reference to the current level current_level = None # support functions used in every level def pop(s): # destroy the circle s.destroy() # tally the hit current_level.hit() class PopLevel1(Level): def __init__(self, duration): self.hits = 0 self.duration = duration def hit(self): # update the number of hits self.hits += 1 # refresh the score score(self.hits) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" # Hold a reference to this level global current_level current_level = self # create one target at a random location shape(CIRCLE).clicked(pop) # SCORE BOARD score(0, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" level is complete when all targets have been destroyed \"\"\" # completed if one circle clicked if self.hits == 1: return True else: return False def next(self): \"\"\" load the next level \"\"\" # preserve the time return PopLevel2(duration=score(pos=LOWER_RIGHT)) class PopLevel2(Level): def __init__(self, duration): self.hits = 0 self.duration = duration def hit(self): # update the number of hits self.hits += 1 # refresh the score score(self.hits) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" # Hold a reference to this level global current_level current_level = self # create two circles at random locations shape(CIRCLE).clicked(pop) shape(CIRCLE).clicked(pop) # SCORE BOARD score(0, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" level is complete when all targets have been destroyed \"\"\" # completed if two circles clicked if self.hits == 2: return True else: return False def next(self): \"\"\" end the game.. there is no next level \"\"\" text(\"YOU SOLVED ALL LEVELS!\") gameover() # start the game at level 1 level(PopLevel1(1))","title":"Statically Defined Levels"},{"location":"examples/levels/#dynamic-levels","text":"This example builds on the previous but now increases the number of circles that are drawn with each level. We've also introduced a countdown timer. The objective of this game is to see how many levels the player can reach by clicking all circles within 10 seconds. You'll notice that there is much less code in this examples. Dynamic levels are fun! # Create a basic game that demonstrates how to create levels # In each level, the player has to pop all the circles in 10 seconds # A new circle will be added for each level WIDTH = 30 HEIGHT = 20 TITLE = 'Simple Levels Example' current_level = None def timer(): text(\"You survived \" + str(current_level.get_duration()) + \" seconds.\") gameover() def pop(s): s.destroy() current_level.hit() class PopLevel(Level): def __init__(self, level=1, duration=0): self.level = level self.hits = 0 self.time_remaining = 10 self.duration = duration def hit(self): # update the number of hits self.hits += 1 # refresh the score score(self.hits) def get_duration(self): return score(pos=LOWER_RIGHT) def setup(self): \"\"\" setup the level \"\"\" # Hold a reference to this level global current_level current_level = self # TARGETS for x in range(self.level): shape(CIRCLE).clicked(pop) # SCORE BOARD score(0, color=BLACK, method=VALUE, prefix='Hits: ') score(pos=LOWER_LEFT, color=BLACK, value=self.time_remaining, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Remaining: ') score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER, step=1, goal=1000, prefix='Duration: ') score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ') # KEYBOARD EVENTS keydown('r', reset) def completed(self): \"\"\" level is complete when all targets have been destroyed \"\"\" if self.hits == self.level: return True else: return False def next(self): \"\"\" load the next level \"\"\" return PopLevel(level=self.level+1, duration=score(pos=LOWER_RIGHT)) level(PopLevel(1))","title":"Dynamic Levels"},{"location":"examples/levels/#next-steps","text":"Want to see levels in action? Take a look at the Click Ninja and Zombie Madness games.","title":"Next Steps"},{"location":"examples/mazes/","text":"Drawing Mazes We can code a number of games with mazes. From Pacman to avoiding the zombie apocalypse, mazes are a fun and easy way to plant obstacles or walls. The Predigame platform supports a number of maze options that we'll explore in this README. For those familiar with the Predigame Sprite, mazes are nothing more than a collection of sprites, normally all of the same type and size. Let's explore how to code mazes! Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going download an existing Predigame game that has a few maxes we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal: pred pull mazes Then change into the mazes directory. cd mazes Now let's create a basic Predigame canvas that we'll use to build the maze. The canvas will have a width of 30 grid cells and a height of 20 grid cells. WIDTH = 30 HEIGHT = 20 TITLE = 'MAZE' Save your changes. Let's call the file game.py . Try running the game from the terminal using the pred command (you'll want to run this command from the directory where you saved the file). pred game.py This program doesn't do much just yet. Just an empty window titled \"MAZE\" - that is missing the maze! Let's add that now. Random Mazes The first type of maze we'll create is the computer generated randomized maze. The code below will iterate over every cell in the game and make a random decision to draw a maze. # these two nested for loops iterate over # every grid cell on the canvas for y in range(HEIGHT): for x in range(WIDTH): # don't create a block on the location of # the player OR the location of the green cell if (x, y) == (0, 0) or (x, y) == (29, 16): continue # make a random decision to color the cell red # this number can be adjusted to make the cells # smaller or larger. if rand(1, 3) > 2.5: shape(RECT, RED, (x, y)) The line rand(1, 3) > 2.5 represents the probability of drawing a maze. There is about a 16.6667% chance that a given cell will have a RED cell colored. Try adjusting the 2.5 to a larger (but less than 3) or smaller (but greater than 1) and see what happens. You'll also notice that with the if condition: if (x, y) == (0, 0) or (x, y) == (29, 16): continue Will never consider placing a RED cell at position (0, 0) (top left corner) or (29, 16) (bottom right corner). This where we will put the player and a green destination block. Now that we can draw a random maze, lets add a player sprite at the top of the code, under the TITLE line. # create a sprite based on the \"player\" image # position at the top left corner # control the sprite with the arrow keys # the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys() Finally, to complete our simple game, let's add a GREEN destination block. We'll also add a callback to end the game when the player sprite collides with the destination block. Let's add this code to the bottom of the file. # a callback function for when the player reaches # the green destination def win(b, p): text('YOU WIN', BLUE) gameover() # draw a green destination cell on the bottom right d = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination') # if the player reaches this cell, execute the 'win' callback d.collides(p, win) # register the 'r' key for resetting the game keydown('r', reset) For context, here is the complete code: WIDTH = 30 HEIGHT = 18 TITLE = 'MAZE' # create a sprite based on the \"player\" image # position at the top left corner # control the sprite with the arrow keys # the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys() # center the player on the 0,0 grid cell p.move_to((0, 0)) # these two nested for loops iterate over # every grid cell on the canvas for y in range(HEIGHT): for x in range(WIDTH): # don't create a block on the location of # the player OR the location of the green cell if (x, y) == (0, 0) or (x, y) == (29, 16): continue # make a random decision to color the cell red # this number can be adjusted to make the cells # smaller or larger. if rand(1, 3) > 2.5: shape(RECT, RED, (x, y)) # a callback function for when the player reaches # the green destination def win(b, p): text('YOU WIN', BLUE) gameover() # draw a green destination cell on the bottom right d = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination') # if the player reaches this cell, execute the 'win' callback d.collides(p, win) # register the 'r' key for resetting the game keydown('r', reset) Save the changes and try running the code: my_machine$ pred maze.py Notice that player sprite can walk through walls? That's a bit silly. We'll fix that in a few minutes. Can't reach the destination? Try hitting r to reset the game. Don't hit the walls! Now let's modify the code to end the game if the player sprite bumps into a wall. It's a small insertion we can add to the end of the file. # a callback function for when the player runs into a red cell def lose(player, block): if block.tag != 'destination': text('GAME OVER', BLACK) gameover() # if the player 'collides' with any cell, execute the 'lose' callback p.collides(sprites(), lose) Save the changes and try running the code: my_machine$ pred maze.py Wall Avoidance In a real game, we don't want the player sprite to walk into walls. It's possible to check the destination of where the player is about to move prior to making the move. We'll call this a precondition - Predigame handles this as a callback function. Add the following code to the type of your file, under the TITLE line: # a callback that keeps the player from running # into walls. it's only acceptable to walk into # an object marked as a \"destination\" def evaluate(action, sprite, pos): obj = at(pos) if obj: if obj.tag == 'destination': return True else: return False else: return True This code calls the at(pos) function that returns any objects that are at a given location - the location the sprite is about to move to. If there is an object at the location AND that object doesn't have the tag named destination , it must be a wall, so evaluate will return False , an indication it is not safe to complete the movement. In all other conditions - either nothing is there or something with the name destination , permit the move to complete. Next we'll set the evaluate callback function and assign to execute on keys() function. Let's make a change to our player sprite: # create a sprite based on the \"player\" image # position at the top left corner. control the # sprite with the arrow keys while checking a # precondition to make sure we don't walk into # walls. the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys(precondition=evaluate) The code from the prior step can be removed since it won't be called anymore. For context, here's the complete file in case you get a little lost making changes in the right locations. WIDTH = 30 HEIGHT = 18 TITLE = 'MAZE' # a callback that keeps the player from running # into walls. it's only acceptable to walk into # an object marked as a \"destination\" def evaluate(action, sprite, pos): obj = at(pos) if obj: if obj.tag == 'destination': return True else: return False else: return True # create a sprite based on the \"player\" image # position at the top left corner. control the # sprite with the arrow keys while checking a # precondition to make sure we don't walk into # walls. the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys(precondition=evaluate) # these two nested for loops iterate over # every grid cell on the canvas for y in range(HEIGHT): for x in range(WIDTH): # don't create a block on the location of # the player OR the location of the green cell if (x, y) == (0, 0) or (x, y) == (29, 16): continue # make a random decision to color the cell red # this number can be adjusted to make the cells # smaller or larger. if rand(1, 3) > 2.5: shape(RECT, RED, (x, y)) # a callback function for when the player reaches # the green destination def win(b, p): text('YOU WIN', BLUE) gameover() # draw a green destination cell on the bottom right d = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination') # if the player reaches this cell, execute the 'win' callback d.collides(p, win) # register the 'r' key for resetting the game keydown('r', reset) Maze Editor Random mazes can be a little challenging to work with since we don't have any control where the obstacles are created. We'll now walk through how to create mazes. To help illustrate mazes, the Predigame platform includes a maze editor example that can be used to create, preview, and delete mazes. Try running the code and create some mazes. my_machine$ pred maze-editor.py The code includes some debugging information on start up that documents how to use the maze editor. Left Click to draw / Right Click to undo a selection p - preview saved mazes (hit again for next) d - delete the current saved maze s - save the current maze in a new file r - reset and clear screen It's possible to create some pretty cool mazes. Give it a try and see what you can create! Here's an example maze: Loading Saved Mazes Once a few mazes have been created, it's possible to load them into a new game. Let's take a look at a simple example. This code assumes that two mazes \"1\" and \"2\" are available in the mazes/ directory. WIDTH = 30 HEIGHT = 18 TITLE = 'MAZE From File' # load a sample maze maze('1', partial(shape, RECT, RED)) # load another sample maze maze('2', partial(image, 'stone')) # center the player on the 0,0 grid cell p = image('player', (0, 0)).speed(5).keys() # register the 'r' key for resetting the game keydown('r', reset) This example loads two separate mazes into the game - one containing RED shapes, the other stone images. The code uses a concept called a \"partial\". This is like a callback function, but provides the coder additional controls for how that callback can be used. Understanding Partials Here's an example shape sprite that will create a RED rectangle at a random position. shape(RECT, RED) Now, here's the above example coded as a partial definition: partial(shape, RECT, RED) Notice the similarities? Predigame and python will unpack the partial into the shape once it's ready to create the shape. Maze Generator We can also randomly generate mazes that are pretty close to a Pacman-style game with the basic function all: maze() Notice this is the exact same function as before? This means that if the filename of a maze is not provide, Predigame will create a random maze instead. As with any maze, it's possible to provide a partial callback to describe the type of walls to create. For example, this maze will be constructed out of 'stone' images: maze(callback=partial(image, 'stone')) and this maze will be constructed out of black rectangles: maze(callback=partial(shape, RECT, BLACK)) Maze Examples We've included a few examples to illustrate some mini-games that can be created with Mazes: maze-1.py - randomly placed blocks where the player must navigate to the bottom right corner. Notice that they player can walk through walls. maze-2.py - continuation of maze-1.py where the player must avoid walls. maze-3.py - variation of maze-2.py but the player respects physics and is not able to walk through walls. maze-4.py - load a maze from a file. maze-5.py - continuation of maze-4.py but all whitespace is filled with coins. maze-6.py - random maze that fills all whitespace with coins. Next Steps Want to see actors in action? Take a look at the Making Bacon game.","title":"Mazes"},{"location":"examples/mazes/#drawing-mazes","text":"We can code a number of games with mazes. From Pacman to avoiding the zombie apocalypse, mazes are a fun and easy way to plant obstacles or walls. The Predigame platform supports a number of maze options that we'll explore in this README. For those familiar with the Predigame Sprite, mazes are nothing more than a collection of sprites, normally all of the same type and size. Let's explore how to code mazes!","title":"Drawing Mazes"},{"location":"examples/mazes/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/mazes/#getting-started","text":"To get things started, we're going download an existing Predigame game that has a few maxes we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal: pred pull mazes Then change into the mazes directory. cd mazes Now let's create a basic Predigame canvas that we'll use to build the maze. The canvas will have a width of 30 grid cells and a height of 20 grid cells. WIDTH = 30 HEIGHT = 20 TITLE = 'MAZE' Save your changes. Let's call the file game.py . Try running the game from the terminal using the pred command (you'll want to run this command from the directory where you saved the file). pred game.py This program doesn't do much just yet. Just an empty window titled \"MAZE\" - that is missing the maze! Let's add that now.","title":"Getting Started"},{"location":"examples/mazes/#random-mazes","text":"The first type of maze we'll create is the computer generated randomized maze. The code below will iterate over every cell in the game and make a random decision to draw a maze. # these two nested for loops iterate over # every grid cell on the canvas for y in range(HEIGHT): for x in range(WIDTH): # don't create a block on the location of # the player OR the location of the green cell if (x, y) == (0, 0) or (x, y) == (29, 16): continue # make a random decision to color the cell red # this number can be adjusted to make the cells # smaller or larger. if rand(1, 3) > 2.5: shape(RECT, RED, (x, y)) The line rand(1, 3) > 2.5 represents the probability of drawing a maze. There is about a 16.6667% chance that a given cell will have a RED cell colored. Try adjusting the 2.5 to a larger (but less than 3) or smaller (but greater than 1) and see what happens. You'll also notice that with the if condition: if (x, y) == (0, 0) or (x, y) == (29, 16): continue Will never consider placing a RED cell at position (0, 0) (top left corner) or (29, 16) (bottom right corner). This where we will put the player and a green destination block. Now that we can draw a random maze, lets add a player sprite at the top of the code, under the TITLE line. # create a sprite based on the \"player\" image # position at the top left corner # control the sprite with the arrow keys # the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys() Finally, to complete our simple game, let's add a GREEN destination block. We'll also add a callback to end the game when the player sprite collides with the destination block. Let's add this code to the bottom of the file. # a callback function for when the player reaches # the green destination def win(b, p): text('YOU WIN', BLUE) gameover() # draw a green destination cell on the bottom right d = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination') # if the player reaches this cell, execute the 'win' callback d.collides(p, win) # register the 'r' key for resetting the game keydown('r', reset) For context, here is the complete code: WIDTH = 30 HEIGHT = 18 TITLE = 'MAZE' # create a sprite based on the \"player\" image # position at the top left corner # control the sprite with the arrow keys # the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys() # center the player on the 0,0 grid cell p.move_to((0, 0)) # these two nested for loops iterate over # every grid cell on the canvas for y in range(HEIGHT): for x in range(WIDTH): # don't create a block on the location of # the player OR the location of the green cell if (x, y) == (0, 0) or (x, y) == (29, 16): continue # make a random decision to color the cell red # this number can be adjusted to make the cells # smaller or larger. if rand(1, 3) > 2.5: shape(RECT, RED, (x, y)) # a callback function for when the player reaches # the green destination def win(b, p): text('YOU WIN', BLUE) gameover() # draw a green destination cell on the bottom right d = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination') # if the player reaches this cell, execute the 'win' callback d.collides(p, win) # register the 'r' key for resetting the game keydown('r', reset) Save the changes and try running the code: my_machine$ pred maze.py Notice that player sprite can walk through walls? That's a bit silly. We'll fix that in a few minutes. Can't reach the destination? Try hitting r to reset the game.","title":"Random Mazes"},{"location":"examples/mazes/#dont-hit-the-walls","text":"Now let's modify the code to end the game if the player sprite bumps into a wall. It's a small insertion we can add to the end of the file. # a callback function for when the player runs into a red cell def lose(player, block): if block.tag != 'destination': text('GAME OVER', BLACK) gameover() # if the player 'collides' with any cell, execute the 'lose' callback p.collides(sprites(), lose) Save the changes and try running the code: my_machine$ pred maze.py","title":"Don't hit the walls!"},{"location":"examples/mazes/#wall-avoidance","text":"In a real game, we don't want the player sprite to walk into walls. It's possible to check the destination of where the player is about to move prior to making the move. We'll call this a precondition - Predigame handles this as a callback function. Add the following code to the type of your file, under the TITLE line: # a callback that keeps the player from running # into walls. it's only acceptable to walk into # an object marked as a \"destination\" def evaluate(action, sprite, pos): obj = at(pos) if obj: if obj.tag == 'destination': return True else: return False else: return True This code calls the at(pos) function that returns any objects that are at a given location - the location the sprite is about to move to. If there is an object at the location AND that object doesn't have the tag named destination , it must be a wall, so evaluate will return False , an indication it is not safe to complete the movement. In all other conditions - either nothing is there or something with the name destination , permit the move to complete. Next we'll set the evaluate callback function and assign to execute on keys() function. Let's make a change to our player sprite: # create a sprite based on the \"player\" image # position at the top left corner. control the # sprite with the arrow keys while checking a # precondition to make sure we don't walk into # walls. the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys(precondition=evaluate) The code from the prior step can be removed since it won't be called anymore. For context, here's the complete file in case you get a little lost making changes in the right locations. WIDTH = 30 HEIGHT = 18 TITLE = 'MAZE' # a callback that keeps the player from running # into walls. it's only acceptable to walk into # an object marked as a \"destination\" def evaluate(action, sprite, pos): obj = at(pos) if obj: if obj.tag == 'destination': return True else: return False else: return True # create a sprite based on the \"player\" image # position at the top left corner. control the # sprite with the arrow keys while checking a # precondition to make sure we don't walk into # walls. the speed of the sprite enables \"graceful\" # movement with the keyboard p = image('player', (0, 0)).speed(5).keys(precondition=evaluate) # these two nested for loops iterate over # every grid cell on the canvas for y in range(HEIGHT): for x in range(WIDTH): # don't create a block on the location of # the player OR the location of the green cell if (x, y) == (0, 0) or (x, y) == (29, 16): continue # make a random decision to color the cell red # this number can be adjusted to make the cells # smaller or larger. if rand(1, 3) > 2.5: shape(RECT, RED, (x, y)) # a callback function for when the player reaches # the green destination def win(b, p): text('YOU WIN', BLUE) gameover() # draw a green destination cell on the bottom right d = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination') # if the player reaches this cell, execute the 'win' callback d.collides(p, win) # register the 'r' key for resetting the game keydown('r', reset)","title":"Wall Avoidance"},{"location":"examples/mazes/#maze-editor","text":"Random mazes can be a little challenging to work with since we don't have any control where the obstacles are created. We'll now walk through how to create mazes. To help illustrate mazes, the Predigame platform includes a maze editor example that can be used to create, preview, and delete mazes. Try running the code and create some mazes. my_machine$ pred maze-editor.py The code includes some debugging information on start up that documents how to use the maze editor. Left Click to draw / Right Click to undo a selection p - preview saved mazes (hit again for next) d - delete the current saved maze s - save the current maze in a new file r - reset and clear screen It's possible to create some pretty cool mazes. Give it a try and see what you can create! Here's an example maze:","title":"Maze Editor"},{"location":"examples/mazes/#loading-saved-mazes","text":"Once a few mazes have been created, it's possible to load them into a new game. Let's take a look at a simple example. This code assumes that two mazes \"1\" and \"2\" are available in the mazes/ directory. WIDTH = 30 HEIGHT = 18 TITLE = 'MAZE From File' # load a sample maze maze('1', partial(shape, RECT, RED)) # load another sample maze maze('2', partial(image, 'stone')) # center the player on the 0,0 grid cell p = image('player', (0, 0)).speed(5).keys() # register the 'r' key for resetting the game keydown('r', reset) This example loads two separate mazes into the game - one containing RED shapes, the other stone images. The code uses a concept called a \"partial\". This is like a callback function, but provides the coder additional controls for how that callback can be used.","title":"Loading Saved Mazes"},{"location":"examples/mazes/#understanding-partials","text":"Here's an example shape sprite that will create a RED rectangle at a random position. shape(RECT, RED) Now, here's the above example coded as a partial definition: partial(shape, RECT, RED) Notice the similarities? Predigame and python will unpack the partial into the shape once it's ready to create the shape.","title":"Understanding Partials"},{"location":"examples/mazes/#maze-generator","text":"We can also randomly generate mazes that are pretty close to a Pacman-style game with the basic function all: maze() Notice this is the exact same function as before? This means that if the filename of a maze is not provide, Predigame will create a random maze instead. As with any maze, it's possible to provide a partial callback to describe the type of walls to create. For example, this maze will be constructed out of 'stone' images: maze(callback=partial(image, 'stone')) and this maze will be constructed out of black rectangles: maze(callback=partial(shape, RECT, BLACK))","title":"Maze Generator"},{"location":"examples/mazes/#maze-examples","text":"We've included a few examples to illustrate some mini-games that can be created with Mazes: maze-1.py - randomly placed blocks where the player must navigate to the bottom right corner. Notice that they player can walk through walls. maze-2.py - continuation of maze-1.py where the player must avoid walls. maze-3.py - variation of maze-2.py but the player respects physics and is not able to walk through walls. maze-4.py - load a maze from a file. maze-5.py - continuation of maze-4.py but all whitespace is filled with coins. maze-6.py - random maze that fills all whitespace with coins.","title":"Maze Examples"},{"location":"examples/mazes/#next-steps","text":"Want to see actors in action? Take a look at the Making Bacon game.","title":"Next Steps"},{"location":"examples/pictureframe/","text":"Picture Frame This example creates a digital picture frame using images from picsum.photos - you'll definitely need an Internet connection to run this game! The code demonstrates some of the key abstraction features that have been implemented in the Predigame platform. Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Download Existing Game (Optional) We have a version of this game already done and ready to go. Just run the following command: pred new pictureframe Then read the rest of the tutorial and follow along. Getting Started To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new pictureframe Now in the text editor, find and open the file pictureframe/game.py . This file is used to create a basic Predigame canvas that we'll use to place our fireworks. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title. WIDTH = 30 HEIGHT = 20 TITLE = 'Fireworks' For this example, we'll want to enable fullscreen mode: FULLSCREEN=True Next we'll add the background function call. In Predigame we always try to provide defaults for functions. The background() function can be used for loading static images (provided they are in your backgrounds/ directory) or static colors (defined as a constant or (RED, GREEN, BLUE) values). If no argument is provided to background() , we fetch an image from picsum.photos . Add this line to your file: background() Now let's give it a test run! pred game.py You'll notice that the game is loaded in full screen, but the picture is static. To fix this up, let's add a timer callback. background() callback(background, 10, repeat=FOREVER) The code calls background() by itself to seed the display with the first image. The second and beyond image will be loaded by the callback() function with a 10 second delay. Here's the completed version: WIDTH=30 HEIGHT=20 FULLSCREEN=True background() callback(background, 10, repeat=FOREVER) Save your changes and enjoy the pics! pred game.py CHALLENGE - Add the time! One of the neat things about Predigame is that you can always drop in python code to help complete a game. The following example is an extension to the previous example, but now adds the time. We had to refactor things a bit, but the code has a similar operation. WIDTH=30 HEIGHT=20 FULLSCREEN=True from time import localtime, strftime clock = None def update(): global clock if clock: clock.destroy() background() clock = text(strftime(\"%H:%M\", localtime()), color=WHITE, pos=(25, 18), size=2) update() callback(update, 10, repeat=FOREVER)","title":"Picture Frame"},{"location":"examples/pictureframe/#picture-frame","text":"This example creates a digital picture frame using images from picsum.photos - you'll definitely need an Internet connection to run this game! The code demonstrates some of the key abstraction features that have been implemented in the Predigame platform.","title":"Picture Frame"},{"location":"examples/pictureframe/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/pictureframe/#download-existing-game-optional","text":"We have a version of this game already done and ready to go. Just run the following command: pred new pictureframe Then read the rest of the tutorial and follow along.","title":"Download Existing Game (Optional)"},{"location":"examples/pictureframe/#getting-started","text":"To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new pictureframe Now in the text editor, find and open the file pictureframe/game.py . This file is used to create a basic Predigame canvas that we'll use to place our fireworks. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title. WIDTH = 30 HEIGHT = 20 TITLE = 'Fireworks' For this example, we'll want to enable fullscreen mode: FULLSCREEN=True Next we'll add the background function call. In Predigame we always try to provide defaults for functions. The background() function can be used for loading static images (provided they are in your backgrounds/ directory) or static colors (defined as a constant or (RED, GREEN, BLUE) values). If no argument is provided to background() , we fetch an image from picsum.photos . Add this line to your file: background() Now let's give it a test run! pred game.py You'll notice that the game is loaded in full screen, but the picture is static. To fix this up, let's add a timer callback. background() callback(background, 10, repeat=FOREVER) The code calls background() by itself to seed the display with the first image. The second and beyond image will be loaded by the callback() function with a 10 second delay. Here's the completed version: WIDTH=30 HEIGHT=20 FULLSCREEN=True background() callback(background, 10, repeat=FOREVER) Save your changes and enjoy the pics! pred game.py","title":"Getting Started"},{"location":"examples/pictureframe/#challenge-add-the-time","text":"One of the neat things about Predigame is that you can always drop in python code to help complete a game. The following example is an extension to the previous example, but now adds the time. We had to refactor things a bit, but the code has a similar operation. WIDTH=30 HEIGHT=20 FULLSCREEN=True from time import localtime, strftime clock = None def update(): global clock if clock: clock.destroy() background() clock = text(strftime(\"%H:%M\", localtime()), color=WHITE, pos=(25, 18), size=2) update() callback(update, 10, repeat=FOREVER)","title":"CHALLENGE - Add the time!"},{"location":"examples/score/","text":"Keeping Score Every game needs a way to keep score. This examples showcases a few of the current scoring options that are included in Predigame. While it's always possible to write your own scoring code, we've found these options cover many common use cases. Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new score Now in the text editor, find and open the file score/game.py . This file is used to create a basic Predigame canvas that we'll use to place sprites. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title. WIDTH = 30 HEIGHT = 20 TITLE = 'Scoring Demo' Accumulator The first score box we'll define will go to the upper left corner of the screen. score(color=WHITE) You can try running your game now and you'll notice the scoring box. Without any options, the default scoring box is a simple numeric score counter. pred game.py Value The next score box is a numeric value holder. Unlike the previous example, this score box will not count the score, but rather display a value. score(pos=UPPER_RIGHT, method=VALUE) Timer (countdown) Some games may have a countdown timer where the player must complete an operation within a designated amount of time. This example adds a timer() callback function that is executed when the value reaches the goal of 0 . # a callback used for a timer def timer(): text('GAME OVER') gameover() # position this scoreboard in the bottom right corner # run as a timer from 30 to 0 (step is -1 so the counter \"steps down\") # when the goal of 0 is reached, execute the timer callback function score(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:') Timer (duration) Similar to the countdown timer, is a duration timer that displays the amount time the player has been playing the game (or level). As with the countdown timer, it is possible to define a goal and a callback, but we elect to simply show the time. # position this scoreboard in the bottom left corner # run as a timer from 0 to 10 (the goal), in increments of 1 # add a prefix \"Duration:\" # since there is no callback registered, the counter will simply when the goal is obtained score(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:') A Silly Scoring Example To showcase all of our scoring boxes in operation, let's create a simple circle clicking game. Here's the complete version that also includes the previously defined timers. WIDTH = 30 HEIGHT = 20 TITLE = 'Scoring Demo' # default scoring box (upper left corner) score(color=WHITE) # place this scoreboard in the upper right corner and just show the value # this means the scoreboard will not accumulate the score score(pos=UPPER_RIGHT, method=VALUE) # position this scoreboard in the bottom left corner # run as a timer from 0 to 10 (the goal), in increments of 1 # add a prefix \"Duration:\" # since there is no callback registered, the counter will simply when the goal is obtained score(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:') # a callback used for a timer def timer(): text('GAME OVER') gameover() # position this scoreboard in the bottom right corner # run as a timer from 30 to 0 (step is -1 so the counter \"steps down\") # when the goal of 0 is reached, execute the timer callback function score(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:') # a simple sprite callback for popping circles and executing the score Options # every three pops will reset the scoreboard in the upper right corner def pop(s): s.destroy() score(1) score(100, pos=UPPER_RIGHT) if score() % 3 == 0: reset_score(pos=UPPER_RIGHT, method=VALUE) # silly circle drawer def show(): shape(CIRCLE, RED).clicked(pop) callback(show, rand(0,2)) callback(show, 0.5) # register a 'r' keydown method to reset keydown('r', reset) Next Steps Want to see scoring in action? Take a look at the Click Ninja and Zombie Madness games.","title":"Scoring"},{"location":"examples/score/#keeping-score","text":"Every game needs a way to keep score. This examples showcases a few of the current scoring options that are included in Predigame. While it's always possible to write your own scoring code, we've found these options cover many common use cases.","title":"Keeping Score"},{"location":"examples/score/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/score/#getting-started","text":"To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new score Now in the text editor, find and open the file score/game.py . This file is used to create a basic Predigame canvas that we'll use to place sprites. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title. WIDTH = 30 HEIGHT = 20 TITLE = 'Scoring Demo'","title":"Getting Started"},{"location":"examples/score/#accumulator","text":"The first score box we'll define will go to the upper left corner of the screen. score(color=WHITE) You can try running your game now and you'll notice the scoring box. Without any options, the default scoring box is a simple numeric score counter. pred game.py","title":"Accumulator"},{"location":"examples/score/#value","text":"The next score box is a numeric value holder. Unlike the previous example, this score box will not count the score, but rather display a value. score(pos=UPPER_RIGHT, method=VALUE)","title":"Value"},{"location":"examples/score/#timer-countdown","text":"Some games may have a countdown timer where the player must complete an operation within a designated amount of time. This example adds a timer() callback function that is executed when the value reaches the goal of 0 . # a callback used for a timer def timer(): text('GAME OVER') gameover() # position this scoreboard in the bottom right corner # run as a timer from 30 to 0 (step is -1 so the counter \"steps down\") # when the goal of 0 is reached, execute the timer callback function score(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:')","title":"Timer (countdown)"},{"location":"examples/score/#timer-duration","text":"Similar to the countdown timer, is a duration timer that displays the amount time the player has been playing the game (or level). As with the countdown timer, it is possible to define a goal and a callback, but we elect to simply show the time. # position this scoreboard in the bottom left corner # run as a timer from 0 to 10 (the goal), in increments of 1 # add a prefix \"Duration:\" # since there is no callback registered, the counter will simply when the goal is obtained score(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:')","title":"Timer (duration)"},{"location":"examples/score/#a-silly-scoring-example","text":"To showcase all of our scoring boxes in operation, let's create a simple circle clicking game. Here's the complete version that also includes the previously defined timers. WIDTH = 30 HEIGHT = 20 TITLE = 'Scoring Demo' # default scoring box (upper left corner) score(color=WHITE) # place this scoreboard in the upper right corner and just show the value # this means the scoreboard will not accumulate the score score(pos=UPPER_RIGHT, method=VALUE) # position this scoreboard in the bottom left corner # run as a timer from 0 to 10 (the goal), in increments of 1 # add a prefix \"Duration:\" # since there is no callback registered, the counter will simply when the goal is obtained score(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:') # a callback used for a timer def timer(): text('GAME OVER') gameover() # position this scoreboard in the bottom right corner # run as a timer from 30 to 0 (step is -1 so the counter \"steps down\") # when the goal of 0 is reached, execute the timer callback function score(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:') # a simple sprite callback for popping circles and executing the score Options # every three pops will reset the scoreboard in the upper right corner def pop(s): s.destroy() score(1) score(100, pos=UPPER_RIGHT) if score() % 3 == 0: reset_score(pos=UPPER_RIGHT, method=VALUE) # silly circle drawer def show(): shape(CIRCLE, RED).clicked(pop) callback(show, rand(0,2)) callback(show, 0.5) # register a 'r' keydown method to reset keydown('r', reset)","title":"A Silly Scoring Example"},{"location":"examples/score/#next-steps","text":"Want to see scoring in action? Take a look at the Click Ninja and Zombie Madness games.","title":"Next Steps"},{"location":"examples/sprites/","text":"Working with Sprites The Predigame sprite is a generic two-dimensional object that is integrated with other sprites in a larger scene. A sprite can consist of a bitmap (still) image or a basic geometrical shape (circle, rectangle, ellipse). Sprites in Predigame have some fun properties - they can be clicked, collide with other sprites, even fade, spin or pulse. Let's have fun working with Sprites! Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new sprites Now in the text editor, find and open the file sprites/game.py . This file is used to create a basic Predigame canvas that we'll use to place sprites. The canvas will have a width of 30 grid cells, height of 20 grid cells (we'll discuss what cells mean in a second), and a title of Simple Game , which we're going to change to Sprites Demo . WIDTH = 30 HEIGHT = 20 TITLE = 'Sprites Demo' Save your changes. Try running the game from the terminal using the pred command (you'll want to run this command from the directory where you saved the file, e.g. sprites if you followed the above pred new example). pred game.py Now this program doesn't do much just yet. Just an empty window titled Sprites Demo . So boring. We're going to add some more code, but first let's make sure we understand grid coordinates and how to place sprites within those coordinates. Understanding Grid Coordinates Probably the easiest way to understand grid coordinates is to enable the grid() overlay in the game code. WIDTH = 30 HEIGHT = 20 TITLE = 'Sprites Demo' grid() Save your code and try running the this version using the same command: pred game.py The result should look like the figure below. Counting the grid coordinates will show 30 from left to right and 20 from top to bottom . This doesn't address how to address sprites using grid coordinates, we'll cover that next. The following code will show how to place rectangle sprites in each of the four corners of the window. # top/left shape(RECT, RED, (0, 0)) # bottom/left shape(RECT, BLUE, (0, HEIGHT-1)) # top/right shape(RECT, PINK, (WIDTH-1, 0)) # bottom/right shape(RECT, PURPLE, (WIDTH-1, HEIGHT-1)) Saving and running the code will show: - a RED rectangle at position (0, 0) corresponding to the top-left corner - a BLUE rectangle at position (0, HEIGHT-1) corresponding to the bottom-left corner - a PINK rectangle at position (WIDTH-1, 0) corresponding to the top-right corner - a PURPLE rectangle at position (WIDTH-1, HEIGHT-1) corresponding to the bottom-right corner Why are the corners specified as WIDTH-1 and HEIGHT-1 ? Computers always start counting at zero. So if WIDTH = 30 and the first grid is 0 the thirtieth cell would be WIDTH-1 or 29 . Running this code should look like the figure below. We added a few labels to make the grid coordinates a little more easier to visualize. It's possible to replace the code from the previous exercise with the one here: # place on center of screen text(\"Understanding Grid Coordinates\", color=BLACK, size = 2.0) text(\"this is a 30 x 20 window\", color=BLACK, pos=(WIDTH/2-7, HEIGHT/2+1), size = 1.75) # top/left shape(RECT, RED, (0, 0)) text(\"(0, 0)\", RED, pos = (0,1), size = 1.25) # bottom/left shape(RECT, BLUE, (0, HEIGHT-1)) text(\"(0, \" + str(HEIGHT-1) + \")\", BLUE, pos = (0, HEIGHT-2), size=1.25) # top/right shape(RECT, PINK, (WIDTH-1, 0)) text(\"(\" + str(WIDTH-1) + \", 0)\", PINK, pos = (WIDTH-2.5,1), size = 1.25) # bottom/right shape(RECT, PURPLE, (WIDTH-1, HEIGHT-1)) text(\"(\" + str(WIDTH-1) + \", \" + str(HEIGHT-1) + \")\", PURPLE, pos = (WIDTH-3,HEIGHT-2), size = 1.25) The resulting game window will show the following rendering: Creating Shapes There are two types of sprites supported in the Predigame platform - shapes and images. Let's look at shapes. The formal function definition (or signature) for creating a shape is as follows: shape(shape = None, color = None, pos = None, size = (1, 1)) Reading this code, there are four attributes : shape - the type of shape to create. Can be one of RECT, SQUARE, CIRCLE, or ELLIPSE color - the shape's color. Can be a constant like BLACK, BLUE, or RED, as well as a (red, green, blue) tuple such as (128, 128, 128) pos - the grid cell of the shape size - the size of the shape in terms of grid cells using the form (width, height). For CIRCLE shapes, only the first number is considered. Notice that each of these attributes have default values. This means that they are option, and if not specified, Predigame will create a random shape type of random color, size, and position. # draw a random shape type of random color, size, and position shape() Here are a few example shapes we can add to our canvas: # red circle at position (2, 2) shape(CIRCLE, RED, (2, 2)) # create a big blue circle next to the red one shape(CIRCLE, BLUE, (5, 1), 3) # create a 2x2 ORANGE square at position (10, 2) shape(RECT, ORANGE, (10, 2), (2,2)) # create a 6x1 rectangle shape(RECT, AQUA, (15, 2), (6, 1)) # create a custom colored (r, g, b) ELLIPSE shape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2)) If we add each of the above shapes to our code, the resulting file will look like this: WIDTH = 30 HEIGHT = 20 TITLE = 'Sprites Demo' # red circle at position (2, 2) shape(CIRCLE, RED, (2, 2)) # create a big blue circle next to the red one shape(CIRCLE, BLUE, (5, 1), 3) # create a 2x2 ORANGE square at position (10, 2) shape(RECT, ORANGE, (10, 2), (2,2)) # create a 6x1 rectangle shape(RECT, AQUA, (15, 2), (6, 1)) # create a custom colored (r, g, b) ELLIPSE shape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2)) Save and run this code. The result should look similar to the image below: Creating Images Like shapes, the Predigame platform also supports creating images. The formal function definition (or signature) for creating an image is as follows: image(name = None, pos = None, center = None, size = 1) Notice that it is similar, yet slightly different than the code for creating a shape. An image in Predigame is defined by: name - the name (without extension) of the image file. The image file should be stored in the images/ directory. For example, if we had an image \"coke.png\" in our images/ directory, the name of the image would be \"coke\". pos - the grid cell of the shape. Officially, this will be the top-left cell of the image. center - used as an alternative to pos to use this position as the center point. size - the size of the shape in terms of grid cells. By default, the image will be fit into a single grid cell. Notice again that each of these attributes have default values. This means that they are option, and if not specified, PrediGame will select a random image from the images/ directory of size 1 (so it will fit into a single cell) and will be placed at a random position. Now here are a few example shapes we can also add to our canvas: # create a \"sprite\" sprite and place at grid location (2, 8) image('sprite', (2, 8)) # create a \"coke\" sprite of double size and place at grid (7, 8) image('coke', (7, 8), size = 2) # create a zombie image('zombie-1', (13,9), size = 5) # create another zombie image('zombie-2', (19,9), size = 5) Add the above lines to our code file and save the changes. The result should look similar to the image below: Sprite Effects Drawing sprites can be a lot of fun, however, we can add some effects to bring them to life. For example, we can make sprites spin, float, and even pulse. Let's look at the some new sprites with effects attached. Spinning image('sprite', (2,14)).spin(time=1) This sprite will spin and complete a revolution every second. It's possible to change time to a smaller or larger number to increase or decrease the spin rate. Pulsing image('sprite', (7,14)).pulse(time=0.5, size=3) Have the sprite execute a pulsing effect - rapidly expand and shrink. The size attribute will control the maximum size of the sprite (as a multiplier) during expansion. The time attribute sets the amount of time (in seconds) the sprite will take to complete an expansion or contraction. Floating image('coke', (13, 15), size = 2).speed(1).float(distance=1) Have the sprite float in place. The .speed(1) call sets the speed of the movement and the distance attribute sets the amount of room (in term of grid cells) the sprite will use to complete a floating operation. Sprite Event Callbacks When we code a game we sometimes need to create actions that will eventually occur. Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game. The Python program language requires that we specify our functions before registering them in the code. Let's look at a simple callback example. def destroy(s): s.destroy() This function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered. s = shape(CIRCLE, RED, rand_pos()).clicked(destroy) That's right.. We can basically add a .clicked(destroy) to the end of our shape definition and register a callback function that won't get called until the player clicks on the circle. Let's take a look at few more examples of event callbacks. Click Events We already briefly covered a click example, but let's look at one that is a little more complicated. def doit(s): s.destroy() image('kaboom', center=(15, 10), size=25) image('clickme', (19, 15), size = 2).pulse(time=0.05, size= 1.25).clicked(doit) This example creates a fast pulsing clickme sprite that is destroyed when clicked and replaced with an oversized kaboom image. s = image('coke', (13, 15), size = 2) s.speed(1).bouncy().spin().pulse().clicked(s.destroy) This example is similar to our first mouse click example on the shape but it recycles the sprites destroy() method as a callback - .clicked(s.destroy) . It also chains a whole bunch of effects that make this sprite bounce around the canvas, pulse, and even spin. Keyboard Events We can also control a sprite with the keyboard. image('zombie-1', (28, 18), size = 2).keys() image('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s') In this case zombie-1 is registered with the .keys() function which will control the sprite with keyboard arrow buttons. In the case where we'd like to use other keyboard buttons, such as a multi-player game, we can assign new keys - .keys(right='d', left='a', up='w', down='s') . Collisions It's common in some games, like FPS, to want to check for sprites that collide with each other. Let's take our previous keyboard example and check for collisions. def eatit(z, s): s.destroy() z.scale(1.2) image('zombie-1', (28, 18), size = 2).keys().collides(sprites(), eatit) image('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s').collides(sprites(), eatit) Here we chain the .collides() callback which takes in a list of sprites and registers a callback function. As coded, we register both zombies to check for collisions with all sprites, the sprites() call will return all sprites on the canvas, and invoke the eatit callback function. Next Steps Want to see sprites in action? Take a look at the Thirsty Zombie game.","title":"Drawing Sprites"},{"location":"examples/sprites/#working-with-sprites","text":"The Predigame sprite is a generic two-dimensional object that is integrated with other sprites in a larger scene. A sprite can consist of a bitmap (still) image or a basic geometrical shape (circle, rectangle, ellipse). Sprites in Predigame have some fun properties - they can be clicked, collide with other sprites, even fade, spin or pulse. Let's have fun working with Sprites!","title":"Working with Sprites"},{"location":"examples/sprites/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/sprites/#getting-started","text":"To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal: pred new sprites Now in the text editor, find and open the file sprites/game.py . This file is used to create a basic Predigame canvas that we'll use to place sprites. The canvas will have a width of 30 grid cells, height of 20 grid cells (we'll discuss what cells mean in a second), and a title of Simple Game , which we're going to change to Sprites Demo . WIDTH = 30 HEIGHT = 20 TITLE = 'Sprites Demo' Save your changes. Try running the game from the terminal using the pred command (you'll want to run this command from the directory where you saved the file, e.g. sprites if you followed the above pred new example). pred game.py Now this program doesn't do much just yet. Just an empty window titled Sprites Demo . So boring. We're going to add some more code, but first let's make sure we understand grid coordinates and how to place sprites within those coordinates.","title":"Getting Started"},{"location":"examples/sprites/#understanding-grid-coordinates","text":"Probably the easiest way to understand grid coordinates is to enable the grid() overlay in the game code. WIDTH = 30 HEIGHT = 20 TITLE = 'Sprites Demo' grid() Save your code and try running the this version using the same command: pred game.py The result should look like the figure below. Counting the grid coordinates will show 30 from left to right and 20 from top to bottom . This doesn't address how to address sprites using grid coordinates, we'll cover that next. The following code will show how to place rectangle sprites in each of the four corners of the window. # top/left shape(RECT, RED, (0, 0)) # bottom/left shape(RECT, BLUE, (0, HEIGHT-1)) # top/right shape(RECT, PINK, (WIDTH-1, 0)) # bottom/right shape(RECT, PURPLE, (WIDTH-1, HEIGHT-1)) Saving and running the code will show: - a RED rectangle at position (0, 0) corresponding to the top-left corner - a BLUE rectangle at position (0, HEIGHT-1) corresponding to the bottom-left corner - a PINK rectangle at position (WIDTH-1, 0) corresponding to the top-right corner - a PURPLE rectangle at position (WIDTH-1, HEIGHT-1) corresponding to the bottom-right corner","title":"Understanding Grid Coordinates"},{"location":"examples/sprites/#why-are-the-corners-specified-as-width-1-and-height-1","text":"Computers always start counting at zero. So if WIDTH = 30 and the first grid is 0 the thirtieth cell would be WIDTH-1 or 29 . Running this code should look like the figure below. We added a few labels to make the grid coordinates a little more easier to visualize. It's possible to replace the code from the previous exercise with the one here: # place on center of screen text(\"Understanding Grid Coordinates\", color=BLACK, size = 2.0) text(\"this is a 30 x 20 window\", color=BLACK, pos=(WIDTH/2-7, HEIGHT/2+1), size = 1.75) # top/left shape(RECT, RED, (0, 0)) text(\"(0, 0)\", RED, pos = (0,1), size = 1.25) # bottom/left shape(RECT, BLUE, (0, HEIGHT-1)) text(\"(0, \" + str(HEIGHT-1) + \")\", BLUE, pos = (0, HEIGHT-2), size=1.25) # top/right shape(RECT, PINK, (WIDTH-1, 0)) text(\"(\" + str(WIDTH-1) + \", 0)\", PINK, pos = (WIDTH-2.5,1), size = 1.25) # bottom/right shape(RECT, PURPLE, (WIDTH-1, HEIGHT-1)) text(\"(\" + str(WIDTH-1) + \", \" + str(HEIGHT-1) + \")\", PURPLE, pos = (WIDTH-3,HEIGHT-2), size = 1.25) The resulting game window will show the following rendering:","title":"Why are the corners specified as WIDTH-1 and HEIGHT-1?"},{"location":"examples/sprites/#creating-shapes","text":"There are two types of sprites supported in the Predigame platform - shapes and images. Let's look at shapes. The formal function definition (or signature) for creating a shape is as follows: shape(shape = None, color = None, pos = None, size = (1, 1)) Reading this code, there are four attributes : shape - the type of shape to create. Can be one of RECT, SQUARE, CIRCLE, or ELLIPSE color - the shape's color. Can be a constant like BLACK, BLUE, or RED, as well as a (red, green, blue) tuple such as (128, 128, 128) pos - the grid cell of the shape size - the size of the shape in terms of grid cells using the form (width, height). For CIRCLE shapes, only the first number is considered. Notice that each of these attributes have default values. This means that they are option, and if not specified, Predigame will create a random shape type of random color, size, and position. # draw a random shape type of random color, size, and position shape() Here are a few example shapes we can add to our canvas: # red circle at position (2, 2) shape(CIRCLE, RED, (2, 2)) # create a big blue circle next to the red one shape(CIRCLE, BLUE, (5, 1), 3) # create a 2x2 ORANGE square at position (10, 2) shape(RECT, ORANGE, (10, 2), (2,2)) # create a 6x1 rectangle shape(RECT, AQUA, (15, 2), (6, 1)) # create a custom colored (r, g, b) ELLIPSE shape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2)) If we add each of the above shapes to our code, the resulting file will look like this: WIDTH = 30 HEIGHT = 20 TITLE = 'Sprites Demo' # red circle at position (2, 2) shape(CIRCLE, RED, (2, 2)) # create a big blue circle next to the red one shape(CIRCLE, BLUE, (5, 1), 3) # create a 2x2 ORANGE square at position (10, 2) shape(RECT, ORANGE, (10, 2), (2,2)) # create a 6x1 rectangle shape(RECT, AQUA, (15, 2), (6, 1)) # create a custom colored (r, g, b) ELLIPSE shape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2)) Save and run this code. The result should look similar to the image below:","title":"Creating Shapes"},{"location":"examples/sprites/#creating-images","text":"Like shapes, the Predigame platform also supports creating images. The formal function definition (or signature) for creating an image is as follows: image(name = None, pos = None, center = None, size = 1) Notice that it is similar, yet slightly different than the code for creating a shape. An image in Predigame is defined by: name - the name (without extension) of the image file. The image file should be stored in the images/ directory. For example, if we had an image \"coke.png\" in our images/ directory, the name of the image would be \"coke\". pos - the grid cell of the shape. Officially, this will be the top-left cell of the image. center - used as an alternative to pos to use this position as the center point. size - the size of the shape in terms of grid cells. By default, the image will be fit into a single grid cell. Notice again that each of these attributes have default values. This means that they are option, and if not specified, PrediGame will select a random image from the images/ directory of size 1 (so it will fit into a single cell) and will be placed at a random position. Now here are a few example shapes we can also add to our canvas: # create a \"sprite\" sprite and place at grid location (2, 8) image('sprite', (2, 8)) # create a \"coke\" sprite of double size and place at grid (7, 8) image('coke', (7, 8), size = 2) # create a zombie image('zombie-1', (13,9), size = 5) # create another zombie image('zombie-2', (19,9), size = 5) Add the above lines to our code file and save the changes. The result should look similar to the image below:","title":"Creating Images"},{"location":"examples/sprites/#sprite-effects","text":"Drawing sprites can be a lot of fun, however, we can add some effects to bring them to life. For example, we can make sprites spin, float, and even pulse. Let's look at the some new sprites with effects attached.","title":"Sprite Effects"},{"location":"examples/sprites/#spinning","text":"image('sprite', (2,14)).spin(time=1) This sprite will spin and complete a revolution every second. It's possible to change time to a smaller or larger number to increase or decrease the spin rate.","title":"Spinning"},{"location":"examples/sprites/#pulsing","text":"image('sprite', (7,14)).pulse(time=0.5, size=3) Have the sprite execute a pulsing effect - rapidly expand and shrink. The size attribute will control the maximum size of the sprite (as a multiplier) during expansion. The time attribute sets the amount of time (in seconds) the sprite will take to complete an expansion or contraction.","title":"Pulsing"},{"location":"examples/sprites/#floating","text":"image('coke', (13, 15), size = 2).speed(1).float(distance=1) Have the sprite float in place. The .speed(1) call sets the speed of the movement and the distance attribute sets the amount of room (in term of grid cells) the sprite will use to complete a floating operation.","title":"Floating"},{"location":"examples/sprites/#sprite-event-callbacks","text":"When we code a game we sometimes need to create actions that will eventually occur. Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game. The Python program language requires that we specify our functions before registering them in the code. Let's look at a simple callback example. def destroy(s): s.destroy() This function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered. s = shape(CIRCLE, RED, rand_pos()).clicked(destroy) That's right.. We can basically add a .clicked(destroy) to the end of our shape definition and register a callback function that won't get called until the player clicks on the circle. Let's take a look at few more examples of event callbacks.","title":"Sprite Event Callbacks"},{"location":"examples/sprites/#click-events","text":"We already briefly covered a click example, but let's look at one that is a little more complicated. def doit(s): s.destroy() image('kaboom', center=(15, 10), size=25) image('clickme', (19, 15), size = 2).pulse(time=0.05, size= 1.25).clicked(doit) This example creates a fast pulsing clickme sprite that is destroyed when clicked and replaced with an oversized kaboom image. s = image('coke', (13, 15), size = 2) s.speed(1).bouncy().spin().pulse().clicked(s.destroy) This example is similar to our first mouse click example on the shape but it recycles the sprites destroy() method as a callback - .clicked(s.destroy) . It also chains a whole bunch of effects that make this sprite bounce around the canvas, pulse, and even spin.","title":"Click Events"},{"location":"examples/sprites/#keyboard-events","text":"We can also control a sprite with the keyboard. image('zombie-1', (28, 18), size = 2).keys() image('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s') In this case zombie-1 is registered with the .keys() function which will control the sprite with keyboard arrow buttons. In the case where we'd like to use other keyboard buttons, such as a multi-player game, we can assign new keys - .keys(right='d', left='a', up='w', down='s') .","title":"Keyboard Events"},{"location":"examples/sprites/#collisions","text":"It's common in some games, like FPS, to want to check for sprites that collide with each other. Let's take our previous keyboard example and check for collisions. def eatit(z, s): s.destroy() z.scale(1.2) image('zombie-1', (28, 18), size = 2).keys().collides(sprites(), eatit) image('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s').collides(sprites(), eatit) Here we chain the .collides() callback which takes in a list of sprites and registers a callback function. As coded, we register both zombies to check for collisions with all sprites, the sprites() call will return all sprites on the canvas, and invoke the eatit callback function.","title":"Collisions"},{"location":"examples/sprites/#next-steps","text":"Want to see sprites in action? Take a look at the Thirsty Zombie game.","title":"Next Steps"},{"location":"examples/thirsty/","text":"Thirsty Zombie Our zombie likes sprite and hates code. This game throws soda can sprites at the zombie where the zombie must consume (destroy) them. If the zombie consumes a \"coke\" sprite, it will explode and end the game. If the zombie misses too many \"sprite\" sprites, it will die from dehydration. The zombie is rewarded one point for every \"sprite\" consumed. Game Algorithm : create a game canvas with a width of 30 and height of 20 grid cells use callback(function, time) throw the cans pick a random probability for throwing a \"coke\" reward the zombie 1 point for every sprite consumed destroy the zombie, if the zombie consumes a coke the score falls below zero use random speeds and callback times to throw more or less cans use effects to make the game fun reset the game if the r key is pressed Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal: pred pull thirsty Then change into the thirsty directory. cd thirsty Now in the text editor, find and open the file thirsty/game.py . Getting Started Here's the first few lines: WIDTH = 30 HEIGHT = 20 TITLE = 'Thirsty Zombie' # load in the stormy background BACKGROUND = 'stormy' This will build a window of 30x20 grid cells and add a \"stormy\" background image. Make sure this image is saved in the backgrounds/ directory . Zombie Creation # create a zombie sprite. flip the sprite so the zombie faces to the right zombie = image('zombie-2', (5, 15), size = 3).speed(10).flip() # tell the zombie to follow the mouse movement zombie.follow() We use the .flip() function to have the zombie face towards right right side of the screen. Here's how to throw a sprite object: def throw(): # pick a random position and select the y coordinate y_pos = rand_pos()[1] # create a soda and move it from right to left target = 'sprite' if randint(1, 5) == 4: target = 'coke' s = image(target, (WIDTH+5, y_pos)).speed(2).collides(zombie, consume) s.move_to((-1, y_pos), callback = lambda: miss(s)) # a callback to call the throw() function again callback(throw, rand(0.5, 2)) Callback Functions Before we draw the code for a beverage, we need to define the logic that describes consumption. Remember, this is because python requires us to define our callback functions before we use them. # zombie consumes a drink and explodes if it's a coke def consume(target, zombie): # destroy the can target.destroy() if target.name == 'coke': # zombies don't like coke. end the game zombie.destroy() image('kaboom', center=(15, 10), size=25) gameover() else: # we added a sprite. increase score score(1) If we don't consume a beverage, the zombie will need to suffer a little bit. Our second callback describes the \"misses\": # zombie misses the opportunity to take a drink and is thirsty. def miss(target): # destroy the can target.destroy() # subtract a point if this was a sprite if target.name == 'sprite': score(-1) # we lost if score() < 0: text(\"TOTAL DEHYDRATION\") zombie.rotate(90).pulse(time=2, size=2) gameover() Throwing Soda Throwing cans of soda is also a callback function, but controlled via time. A key to throwing is to mix up the positions a bit. The line of code y_pos = rand_pos()[1] is a shorthanded way of randomly picking a y (top/bottom) position. Read through the rest of the code below, we added some documentation to clarify each of the lines. # this is a callback that throws a sprite or coke across the screen def throw_soda(): # pick a random position and select the y coordinate y_pos = rand_pos()[1] # create a soda and move it from right to left target = 'sprite' # roughly 50% of the cans are cokes if randint(1, 2) == 2: target = 'coke' # position the sprite off the right side of the screen # make it move fast (speed 10) # if the zombie hits the can, execute the \"consume\" callback s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume) # move the sprite to the left. execute callback \"miss\" if movement finishes s.move_to((-1, y_pos), callback = lambda: miss(s)) # a callback to call the throw() function again callback(throw_soda, rand(0, 1.5)) # schedule the throw callback to run callback(throw_soda, 1) Final Bits The final parts of the game enable score keeping and resetting the game if the 'r' key is pressed. # add this so we can keep score of the game score(color=WHITE) # press the r key to reset keydown('r', reset) Complete Code Below is the complete code for \"thirsty zombie\". We added an easter egg if the 'b' button is pressed - launch of soccer balls; it's an added obstacle that the zombie will need to avoid. WIDTH = 30 HEIGHT = 20 TITLE = 'Thirsty Zombie' # load in the stormy background BACKGROUND = 'stormy' # create a zombie sprite. flip the sprite so the zombie faces to the right zombie = image('zombie-2', (5, 15), size = 3).speed(10).flip() # tell the zombie to follow the mouse movement zombie.follow() # keep track if the zombie is spinning spinning = False # zombie consumes a drink and explodes if it's a coke def consume(target, zombie): # a spinning zombie cannot consume things if spinning: return # destroy the can target.destroy() if target.name == 'coke': # zombies don't like coke. end the game zombie.destroy() image('kaboom', center=(15, 10), size=25) gameover() else: # we added a sprite. increase score score(1) # zombie misses the opportunity to take a drink and is thirsty. def miss(target): # destroy the can target.destroy() # subtract a point if this was a sprite if target.name == 'sprite': score(-1) # we lost if score() < 0: text(\"TOTAL DEHYDRATION\") zombie.rotate(90).pulse(time=2, size=2) gameover() # this is a callback that throws a sprite or coke across the screen def throw_soda(): # pick a random position and select the y coordinate y_pos = rand_pos()[1] # create a soda and move it from right to left target = 'sprite' # roughly 50% of the cans are cokes if randint(1, 2) == 2: target = 'coke' # position the sprite off the right side of the screen # make it move fast (speed 10) # if the zombie hits the can, execute the \"consume\" callback s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume) # move the sprite to the left. execute callback \"miss\" if movement finishes s.move_to((-1, y_pos), callback = lambda: miss(s)) # a callback to call the throw() function again callback(throw_soda, rand(0, 1.5)) # schedule the throw callback to run callback(throw_soda, 1) # this is a callback when the zombie is done spinning def done_spinning(): # the \"global\" variable is set to False (since we are done spinning) global spinning spinning = False # this is a callback when the zombie is hit by a ball def spinner(b, z): # the \"global\" variable is set to True (since we are spinning) global spinning spinning = True # destroy the ball b.destroy() # spin the zombie.. time probably can't go much smaller than 0.5 # execute callback done_spinning after completing two rotations z.spin(time=0.5, rotations=2, callback=done_spinning) # this is a callback function to launch the ball def launch(): # create a ball and position off the right side of the screen random_y_position = rand_pos()[1] # position balls off the screen, make them spin and move a little fast ball = image('ball', (WIDTH+5, random_y_position), size=2).spin(0.2).speed(5) # move right to left, destroy if movement completes ball.move_to((-5, random_y_position), callback=ball.destroy) # make the zombie spin if hit by a ball ball.collides(zombie, spinner) # prepare to launch another callback(launch, rand(0.2, 1)) # hitting 'b' starts launching balls! keydown('b', launch) # add this so we can keep score of the game score(color=WHITE) # press the r key to reset keydown('r', reset) Save this code as game.py and let's give it a run! pred game.py If it loads correctly, the following game canvas should display. Have fun!!","title":"Thirsty Zombie"},{"location":"examples/thirsty/#thirsty-zombie","text":"Our zombie likes sprite and hates code. This game throws soda can sprites at the zombie where the zombie must consume (destroy) them. If the zombie consumes a \"coke\" sprite, it will explode and end the game. If the zombie misses too many \"sprite\" sprites, it will die from dehydration. The zombie is rewarded one point for every \"sprite\" consumed. Game Algorithm : create a game canvas with a width of 30 and height of 20 grid cells use callback(function, time) throw the cans pick a random probability for throwing a \"coke\" reward the zombie 1 point for every sprite consumed destroy the zombie, if the zombie consumes a coke the score falls below zero use random speeds and callback times to throw more or less cans use effects to make the game fun reset the game if the r key is pressed","title":"Thirsty Zombie"},{"location":"examples/thirsty/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/thirsty/#getting-started","text":"To get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal: pred pull thirsty Then change into the thirsty directory. cd thirsty Now in the text editor, find and open the file thirsty/game.py .","title":"Getting Started"},{"location":"examples/thirsty/#getting-started_1","text":"Here's the first few lines: WIDTH = 30 HEIGHT = 20 TITLE = 'Thirsty Zombie' # load in the stormy background BACKGROUND = 'stormy' This will build a window of 30x20 grid cells and add a \"stormy\" background image. Make sure this image is saved in the backgrounds/ directory .","title":"Getting Started"},{"location":"examples/thirsty/#zombie-creation","text":"# create a zombie sprite. flip the sprite so the zombie faces to the right zombie = image('zombie-2', (5, 15), size = 3).speed(10).flip() # tell the zombie to follow the mouse movement zombie.follow() We use the .flip() function to have the zombie face towards right right side of the screen. Here's how to throw a sprite object: def throw(): # pick a random position and select the y coordinate y_pos = rand_pos()[1] # create a soda and move it from right to left target = 'sprite' if randint(1, 5) == 4: target = 'coke' s = image(target, (WIDTH+5, y_pos)).speed(2).collides(zombie, consume) s.move_to((-1, y_pos), callback = lambda: miss(s)) # a callback to call the throw() function again callback(throw, rand(0.5, 2))","title":"Zombie Creation"},{"location":"examples/thirsty/#callback-functions","text":"Before we draw the code for a beverage, we need to define the logic that describes consumption. Remember, this is because python requires us to define our callback functions before we use them. # zombie consumes a drink and explodes if it's a coke def consume(target, zombie): # destroy the can target.destroy() if target.name == 'coke': # zombies don't like coke. end the game zombie.destroy() image('kaboom', center=(15, 10), size=25) gameover() else: # we added a sprite. increase score score(1) If we don't consume a beverage, the zombie will need to suffer a little bit. Our second callback describes the \"misses\": # zombie misses the opportunity to take a drink and is thirsty. def miss(target): # destroy the can target.destroy() # subtract a point if this was a sprite if target.name == 'sprite': score(-1) # we lost if score() < 0: text(\"TOTAL DEHYDRATION\") zombie.rotate(90).pulse(time=2, size=2) gameover()","title":"Callback Functions"},{"location":"examples/thirsty/#throwing-soda","text":"Throwing cans of soda is also a callback function, but controlled via time. A key to throwing is to mix up the positions a bit. The line of code y_pos = rand_pos()[1] is a shorthanded way of randomly picking a y (top/bottom) position. Read through the rest of the code below, we added some documentation to clarify each of the lines. # this is a callback that throws a sprite or coke across the screen def throw_soda(): # pick a random position and select the y coordinate y_pos = rand_pos()[1] # create a soda and move it from right to left target = 'sprite' # roughly 50% of the cans are cokes if randint(1, 2) == 2: target = 'coke' # position the sprite off the right side of the screen # make it move fast (speed 10) # if the zombie hits the can, execute the \"consume\" callback s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume) # move the sprite to the left. execute callback \"miss\" if movement finishes s.move_to((-1, y_pos), callback = lambda: miss(s)) # a callback to call the throw() function again callback(throw_soda, rand(0, 1.5)) # schedule the throw callback to run callback(throw_soda, 1)","title":"Throwing Soda"},{"location":"examples/thirsty/#final-bits","text":"The final parts of the game enable score keeping and resetting the game if the 'r' key is pressed. # add this so we can keep score of the game score(color=WHITE) # press the r key to reset keydown('r', reset)","title":"Final Bits"},{"location":"examples/thirsty/#complete-code","text":"Below is the complete code for \"thirsty zombie\". We added an easter egg if the 'b' button is pressed - launch of soccer balls; it's an added obstacle that the zombie will need to avoid. WIDTH = 30 HEIGHT = 20 TITLE = 'Thirsty Zombie' # load in the stormy background BACKGROUND = 'stormy' # create a zombie sprite. flip the sprite so the zombie faces to the right zombie = image('zombie-2', (5, 15), size = 3).speed(10).flip() # tell the zombie to follow the mouse movement zombie.follow() # keep track if the zombie is spinning spinning = False # zombie consumes a drink and explodes if it's a coke def consume(target, zombie): # a spinning zombie cannot consume things if spinning: return # destroy the can target.destroy() if target.name == 'coke': # zombies don't like coke. end the game zombie.destroy() image('kaboom', center=(15, 10), size=25) gameover() else: # we added a sprite. increase score score(1) # zombie misses the opportunity to take a drink and is thirsty. def miss(target): # destroy the can target.destroy() # subtract a point if this was a sprite if target.name == 'sprite': score(-1) # we lost if score() < 0: text(\"TOTAL DEHYDRATION\") zombie.rotate(90).pulse(time=2, size=2) gameover() # this is a callback that throws a sprite or coke across the screen def throw_soda(): # pick a random position and select the y coordinate y_pos = rand_pos()[1] # create a soda and move it from right to left target = 'sprite' # roughly 50% of the cans are cokes if randint(1, 2) == 2: target = 'coke' # position the sprite off the right side of the screen # make it move fast (speed 10) # if the zombie hits the can, execute the \"consume\" callback s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume) # move the sprite to the left. execute callback \"miss\" if movement finishes s.move_to((-1, y_pos), callback = lambda: miss(s)) # a callback to call the throw() function again callback(throw_soda, rand(0, 1.5)) # schedule the throw callback to run callback(throw_soda, 1) # this is a callback when the zombie is done spinning def done_spinning(): # the \"global\" variable is set to False (since we are done spinning) global spinning spinning = False # this is a callback when the zombie is hit by a ball def spinner(b, z): # the \"global\" variable is set to True (since we are spinning) global spinning spinning = True # destroy the ball b.destroy() # spin the zombie.. time probably can't go much smaller than 0.5 # execute callback done_spinning after completing two rotations z.spin(time=0.5, rotations=2, callback=done_spinning) # this is a callback function to launch the ball def launch(): # create a ball and position off the right side of the screen random_y_position = rand_pos()[1] # position balls off the screen, make them spin and move a little fast ball = image('ball', (WIDTH+5, random_y_position), size=2).spin(0.2).speed(5) # move right to left, destroy if movement completes ball.move_to((-5, random_y_position), callback=ball.destroy) # make the zombie spin if hit by a ball ball.collides(zombie, spinner) # prepare to launch another callback(launch, rand(0.2, 1)) # hitting 'b' starts launching balls! keydown('b', launch) # add this so we can keep score of the game score(color=WHITE) # press the r key to reset keydown('r', reset) Save this code as game.py and let's give it a run! pred game.py If it loads correctly, the following game canvas should display. Have fun!!","title":"Complete Code"},{"location":"examples/zombie/","text":"Zombie Madness A coding instructional implementation based on the Predigame Platform . Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code! Asset Licenses All static artwork has been obtained from OpenGameArt or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development. Prerequisites You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions. Getting Started To get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal: pred pull zombie Then change into the zombie directory. cd zombie Game Story This game consists of three \"actors\" - the player (you, depicted as a soldier), red forces (depicted as a zombie), and blue forces (depicted as a wild boar). Red forces launch in the top-right corner and will randomly find and seek the player and blues. Reds will attack upon collision. Death will be imminent. Blue deaths immediately turn into a new red. Player death ends game. Blue forces launch in the top-left corner and try to navigate to their \"home\" destination (bottom-right corner). They don't know anything about the player and zombie, though it is possible to hack the blue forces and add \"self defense\". Reds and blues periodically \"replan\" their routes. Players try to ensure as many blues can return home safely while destroying all reds. They have weapons and should not be afraid to use them. There is a 10% chance of a special level that will require a different strategy. Instructional Coverage We're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform. Predigame Concepts Covered: Callbacks (timing and keyboard) Animated Actors Levels Scoring and Statistics Preserving Game State Inventory Control Weapons! Python Concepts Covered: Abstractions Loops Classes The game consists of three files: zombie.py - [ADVANCED] contains the bulk of the implementation. Can be modified as desired, but some of the concepts would require prior programming experience. weapons.py - [INTERMEDIATE] all game weapons are defined as python classes. We recommend coders with prior experience experiment with the weapons and see the corresponding impacts in the game. zombie_plugins.py - [BEGINNER] the game has a bunch of user defined features that can be easily tweaked to change the style and function of the game. The majority of our coders spend their time working in this file. This README walks through some common use cases and the underlying code that would be required for implementation. Each example includes a LOCATION GUIDE that will detail where in the zombie_plugins.py file to insert and modify the code. For those looking to start fresh, we've included a file zombie_plugins_start.py that has the bare minimum for a functioning game. You'll want save this file as zombie_plugins.py and start coding! Keep in mind that bare minimum means NO WEAPONS so you'll need to be extra careful and avoid those red forces. Running the Game We recommend running all predigames from the command prompt/console/terminal. Be sure to cd into your game directory run: pred zombie.py State Management Upon completion of a level, the game will write two state files. These files can be deleted to reset state. player.pg - consists of player energy, wealth, and inventory. stats.pg - consists of key game metrics: Number of levels completed Number of blue|red forces launched Number of red kills Number of player kills Number of blue forces that arrive home safely Background Images Static backgrounds LOCATION GUIDE : insert inside the setup function -- def setup(player, level): This code will provide a single image that is used in ever level. You'll want to add to your setup function. background('grass') You can also just have single color. Here is an example of a gray background. background(GRAY) If you have a particular color in mind, it's possible to also define the background with a (red, green, blue) tuple. background((25, 25, 25)) Random backgrounds LOCATION GUIDE : insert inside the setup function -- def setup(player, level): If you interested in changing backgrounds for each level, we'll want to create a list with all of our choices and then use the choice() function to randomly select an image file from the list. choices = ['grass', 'ville'] background(choice(choices)) We also have a pretty cool image service that will randomly pick and use a background from the Internet. This can add a little jazz to your game. background() Progressive backgrounds LOCATION GUIDE : insert inside the setup function -- def setup(player, level): Sometimes you'll want to have the same background be used for the same level. This can provide a hint to the user of where they are in the game. In order to accomplish progressive backgrounds, we'll need to evaluate the level and decide which background image to load. Using python, we can accomplish this with an if/else statement. if level.level == 1: background('grass') elif level.level == 2: background('ville') else: background('stormy') Notice that the file line is the \"catch all\" statement. This basically means the same stormy image will be used for the third and beyond levels. Mazes Generated maze LOCATION GUIDE : insert inside the setup function -- def setup(player, level): It's possible, also within the setup function, to define the type of maze should be drawn on the game service. Assuming that there is an image with the name 'stone' , it's possible to use that to draw the maze. maze(callback=partial(image, 'stone')) Likewise, it's also possibly to simply draw a maze with colors. For example, maze(callback=partial(shape, RECT, BLACK)) Random maze LOCATION GUIDE : insert inside the setup function -- def setup(player, level): Sometimes it may be desirable to have some randomly placed blocks to create as obstacles. It's possible to tweak the 2.75 number to draw more or less blocks. The numbers 19 and 31 signify the HEIGHT and WIDTH of the window, in terms of grid cells. for y in range(19): for x in range(31): if rand(1, 3) > 2.75: shape(RECT, RED, (x, y), tag='wall') Player Actions Keyboard Shortcuts NOTE: some of these shortcuts use the same keys. They can be easily changed to something else. It is not possible to assign more than one shortcut to the same keyboard key. Change the walking keys LOCATION GUIDE : insert inside the setup function -- def setup(player, level): The game uses arrow keys for walking by default. It's possible to change them to something else. The below example changes them to w , a , s , and d . This code will need to be added to your setup function player.keys(right = 'd', left = 'a', up = 'w', down = 's', precondition=player_physics) This code will obey the maze walls. If you want to walk through them, remove the , precondition=player_physics ending. The resulting code will look like this: player.keys(right = 'd', left = 'a', up = 'w', down = 's') Change facing direction (without moving) LOCATION GUIDE : insert inside the setup function -- def setup(player, level): Sometimes you may want to quickly change direction and shoot without having to move. This code will rebind the arrow keys to changing the facing direction. Keep in mind that you'll need to change the walking keys or register different keys for the facing direction . This code will need to be added to your setup function. def __direction__(player, direction): \"\"\" change the players direction \"\"\" player.direction = direction player.act(IDLE, FOREVER) keydown('left', callback=partial(__direction__,player, LEFT)) keydown('right', callback=partial(__direction__,player, RIGHT)) keydown('up', callback=partial(__direction__,player, BACK)) keydown('down', callback=partial(__direction__,player, FRONT)) Inventory Controlled Weapons LOCATION GUIDE (ALL WEAPONS) : insert inside the setup function -- def setup(player, level): weapon cost energy impact air gun 2 0 c4 explosive 50 -10 flame thrower 500 -50 green rage 25 10 grenade 100 -50 landmine 50 0 machine gun 2 0 mustard gas 250 -10 punch 1 -10 wall builder 5 -5 wall buster n/a -0.25 nuclear bomb mucho grande 0 Core conceptual language - A player \"takes\" a Thing (can be anything) that is later used. Inventory Market Place Buy weapons, restore energy at the market place! The market place can be accessed with the F1 key during the game. All activity will be paused while you shop. Air Gun Shoots \"air\" bullets. Default activation is with the space bar. player.take(weapons.AirGun(call='space')) C4 Explosives Drops C4 explosives. Thrown with the 7 key, detonated with the 8 key. Default throwing distance is 8 blocks and blast radius is 10 (which is about four blocks). Explosives only kill actors and do not destroy walls. player.take(weapons.C4(call='7', detonate='8', distance=8, radius=10)) Flame Thrower Throws a devastating ball of fire. It takes quite a bit of energy to generate a the fiery ball, but it's a sure way to clear out the bad guys. The flame had an internal compass that shadows the player's orientation, so move the player around for maximum effect. Generated and thrown with the 2 key. Use player directional keys after thrown to control flame ball. player.take(weapons.FlameThrower(call='2')) Green Rage (Energy Drink) Give your player a dose of caffeine for continued rage! Only accessible from the inventory panel. Grenade Throw a grenade with the 3 key. Default throwing distance is 6 blocks and blast radius is 10 (which is about four blocks). Grenade destroys anything in it's blasting radius - including walls! player.take(weapons.Grenade(call='3', distance=6, radius=10)) Landmine Plant a landmine with the 6 key. The bomb is activated in one second. BE CAREFUL!! - your player can fall victim to the explosive. player.take(weapons.Landmine(call='6', delay=1)) Machine Gun Keep your blue forces safe with the trusty machine gun! Default trigger is the 5 key with single bullets that travel 15 blocks. Want rapid fire more bullets? Be sure to set the repeat parameter. player.take(weapons.MachineGun(call='5', distance=15, repeat=1)) Mustard Gas Take out your enemies with a harmful chemical weapon. Thrown with the 4 key, a mustard gas capsule travels 10 blocks and has an effective radius of 20 (about 5 blocks). The gas capsule only explodes if it hits an actor instance. player.take(weapons.MustardGas(call='4', distance=10, radius=20)) Punch When all else fails, use your hands! The simple punch is activated with the 1 key. Make sure you sneak behind your enemy as they can attack you otherwise! player.take(weapons.Punch(call='1')) Wall Builder Have your player use walls to provide defense from the zombies. The first line sets the wall image, the second sets the directional callback keys. wall = partial(image, 'stone') player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall)) Want to use colored rectangles instead? Give this a shot: wall = partial(shape, RECT, BLACK) player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall)) Wall Buster Let your player bust through the maze walls. Make sure you reset player walking keys (see above). A player that obeys physics can't bust walls! player.take(weapons.WallBuster()) Nuclear Bomb OH. YEAH! Every game needs this one. Keep in mind that it takes a few seconds to call in the bomb. By default our bomb can be called in with the n key. player.take(weapons.NuclearBomb(call='n')) Bonus Sprites LOCATION GUIDE : insert inside the setup function -- def setup(player, level): These boost sprites allow your player to earn extra energy and wealth bonuses during the game. Blue and red forces are immune to boost sprites. Energy Boost This code will drop sprite images with a 5% probability. Anytime the player collides with a sprite image, the player is rewarded with a 10% energy boost. def drink(soda, player): soda.destroy() player.energy = 10 fill(partial(image,'sprite', size=1.0), 0.05, player, drink) Wealth Boost This code will drop coin images with a 25% probability. Anytime the player collides with a coin image, the player is rewarded with a 5 point wealth boost. def claim(coin, player): coin.destroy() player.wealth = 5 fill(partial(image,'coin', size=1.0), 0.25, player, claim) Friendlies LOCATION GUIDE : insert as a top-level function Your objective is to save the life of friendly forces. def get_blue(): \"\"\" create a blue (friendly) actor \"\"\" # return name of actor and grazing speed return 'Boar', 3 Custom destination image LOCATION GUIDE : insert as a top-level function Don't like the default pig pen image? It's possible to create your own with this function and then change pigpen with whatever image you want! def blue_destination(): return 'pigpen' Self defense [HARD] LOCATION GUIDE : insert as a top-level function and modify get_blue It's possible to have your blue forces automate a self defense. This code is a bit weird and it still may allow hostiles to kill blue forces. Step 1: Define a self-defense function This code checks all directions to see if any red forces are within 5 blocks. When a red force is nearby, the blue throws some self defense flares -- instantly killing the enemy. def blue_defend(actor): \"\"\" activate self defense \"\"\" for direction in [BACK, FRONT, LEFT, RIGHT]: things = actor.next_object(direction=direction, distance=5) if things and has_tag(things, 'red'): actor.direction = direction actor.stop = True target = actor.next_object() if target and isinstance(target, Actor): turd = image('turd', pos=actor.pos).speed(15) turd.move_to(target.pos).destruct(2) target.kill() callback(partial(actor.act, IDLE, FOREVER), 5) Step 2: Change the get_blue function to include the newly added blue_defend self defense function. def get_blue(): \"\"\" create a blue (friendly) actor \"\"\" # return name of actor, grazing speed, self defense return 'Piggy', 2, blue_defend Schedule more friendlies LOCATION GUIDE : insert inside the setup function -- def setup(player, level): It's easy to schedule more friendlies with a callback function. Here's a couple of variations. All will need to be added to your setup function. schedule a single friendly (1 second delay) callback(level.create_blue, wait=1) schedule a friendly every 10 seconds and repeat 5 times callback(level.create_blue, wait=10, repeat=5) schedule a friendly every 10 seconds and repeat forever callback(level.create_blue, wait=10, repeat=FOREVER) Hostiles LOCATION GUIDE : insert as a top-level function Your object is to eliminate all hostile actors. def get_red(): \"\"\" create a red (hostile) actor \"\"\" # return name of actor, movement speed return 'Zombie-1', 1 Spawn different types of zombies at different speeds! def get_red(): \"\"\" create a red (hostile) actor \"\"\" # return name of actor, movement speed zombies = ['Zombie-1','Zombie-2','Zombie-3'] return choice(zombies), randint(1,4) Schedule more hostiles LOCATION GUIDE : insert inside the setup function -- def setup(player, level): It's easy to schedule more hostiles with a callback function. Here's a couple of variations. All will need to be added to your setup function. schedule a single hostile (1 second delay) callback(level.create_red, wait=1) schedule a hostile every 10 seconds and repeat 5 times callback(level.create_red, wait=10, repeat=5) schedule a hostile every 10 seconds and repeat forever callback(level.create_red, wait=10, repeat=FOREVER) Levels LOCATION GUIDE : insert inside the setup function -- def setup(player, level): Overriding the default behavior (MUST ADD) It's possible to change how the story ends! Here's a few possible tricks you can try. Be sure to register your __completed__ function first! def __completed__(self): # promote level by killing all the hostiles if len(get('red')) == 0: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True # register the __completed__ function to control how the level decisions are made level.completed = MethodType(__completed__, level) You'll notice that plugging in this code will drastically change how the levels end. What happens if all the blues die? What happens if your player dies? The rest of the the updates will be specific to the __completed__ function. There is no need to register that function more than once. Option 1: All Blues Go Home This code will promote the level if all blue forces go home. It will also end the game if one dies. Again, you'll want to replace your existing __completed__ function with this code. def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif self.blue_killed > 0: text('GAME OVER') gameover() Option 2: Option 1 + Player Survives def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover() Option 3: Option 2 + Kill all the hostiles def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif len(get('red')) == 0: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover() Option 4: Blues go home and their house survives def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif len(get('destination')) == 0: text('DESTINATION DESTROYED! GAME OVER!') gameover() elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover() Option 5: Option 4 + all reds die def __completed__(self): if self.blue_spawned == self.blue_safe and len(get('red')) == 0: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif len(get('destination')) == 0: text('DESTINATION DESTROYED! GAME OVER!') gameover() elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover() Scoring Add countdown timer LOCATION GUIDE : insert inside the setup function -- def setup(player, level): This code should be added to the end of the setup function. python timer(color=WHITE, value=30) If desired, it's also possible to add a countdown time that adds additional time for each level. The following code will add 30 seconds for each level. python timer(color=WHITE, value=30*level.level)","title":"Zombie Madness"},{"location":"examples/zombie/#zombie-madness","text":"A coding instructional implementation based on the Predigame Platform . Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code!","title":"Zombie Madness"},{"location":"examples/zombie/#asset-licenses","text":"All static artwork has been obtained from OpenGameArt or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development.","title":"Asset Licenses"},{"location":"examples/zombie/#prerequisites","text":"You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit http://predigame.io for installation instructions.","title":"Prerequisites"},{"location":"examples/zombie/#getting-started","text":"To get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal: pred pull zombie Then change into the zombie directory. cd zombie","title":"Getting Started"},{"location":"examples/zombie/#game-story","text":"This game consists of three \"actors\" - the player (you, depicted as a soldier), red forces (depicted as a zombie), and blue forces (depicted as a wild boar). Red forces launch in the top-right corner and will randomly find and seek the player and blues. Reds will attack upon collision. Death will be imminent. Blue deaths immediately turn into a new red. Player death ends game. Blue forces launch in the top-left corner and try to navigate to their \"home\" destination (bottom-right corner). They don't know anything about the player and zombie, though it is possible to hack the blue forces and add \"self defense\". Reds and blues periodically \"replan\" their routes. Players try to ensure as many blues can return home safely while destroying all reds. They have weapons and should not be afraid to use them. There is a 10% chance of a special level that will require a different strategy.","title":"Game Story"},{"location":"examples/zombie/#instructional-coverage","text":"We're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform. Predigame Concepts Covered: Callbacks (timing and keyboard) Animated Actors Levels Scoring and Statistics Preserving Game State Inventory Control Weapons! Python Concepts Covered: Abstractions Loops Classes The game consists of three files: zombie.py - [ADVANCED] contains the bulk of the implementation. Can be modified as desired, but some of the concepts would require prior programming experience. weapons.py - [INTERMEDIATE] all game weapons are defined as python classes. We recommend coders with prior experience experiment with the weapons and see the corresponding impacts in the game. zombie_plugins.py - [BEGINNER] the game has a bunch of user defined features that can be easily tweaked to change the style and function of the game. The majority of our coders spend their time working in this file. This README walks through some common use cases and the underlying code that would be required for implementation. Each example includes a LOCATION GUIDE that will detail where in the zombie_plugins.py file to insert and modify the code. For those looking to start fresh, we've included a file zombie_plugins_start.py that has the bare minimum for a functioning game. You'll want save this file as zombie_plugins.py and start coding! Keep in mind that bare minimum means NO WEAPONS so you'll need to be extra careful and avoid those red forces.","title":"Instructional Coverage"},{"location":"examples/zombie/#running-the-game","text":"We recommend running all predigames from the command prompt/console/terminal. Be sure to cd into your game directory run: pred zombie.py","title":"Running the Game"},{"location":"examples/zombie/#state-management","text":"Upon completion of a level, the game will write two state files. These files can be deleted to reset state. player.pg - consists of player energy, wealth, and inventory. stats.pg - consists of key game metrics: Number of levels completed Number of blue|red forces launched Number of red kills Number of player kills Number of blue forces that arrive home safely","title":"State Management"},{"location":"examples/zombie/#background-images","text":"","title":"Background Images"},{"location":"examples/zombie/#static-backgrounds","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): This code will provide a single image that is used in ever level. You'll want to add to your setup function. background('grass') You can also just have single color. Here is an example of a gray background. background(GRAY) If you have a particular color in mind, it's possible to also define the background with a (red, green, blue) tuple. background((25, 25, 25))","title":"Static backgrounds"},{"location":"examples/zombie/#random-backgrounds","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): If you interested in changing backgrounds for each level, we'll want to create a list with all of our choices and then use the choice() function to randomly select an image file from the list. choices = ['grass', 'ville'] background(choice(choices)) We also have a pretty cool image service that will randomly pick and use a background from the Internet. This can add a little jazz to your game. background()","title":"Random backgrounds"},{"location":"examples/zombie/#progressive-backgrounds","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): Sometimes you'll want to have the same background be used for the same level. This can provide a hint to the user of where they are in the game. In order to accomplish progressive backgrounds, we'll need to evaluate the level and decide which background image to load. Using python, we can accomplish this with an if/else statement. if level.level == 1: background('grass') elif level.level == 2: background('ville') else: background('stormy') Notice that the file line is the \"catch all\" statement. This basically means the same stormy image will be used for the third and beyond levels.","title":"Progressive backgrounds"},{"location":"examples/zombie/#mazes","text":"","title":"Mazes"},{"location":"examples/zombie/#generated-maze","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): It's possible, also within the setup function, to define the type of maze should be drawn on the game service. Assuming that there is an image with the name 'stone' , it's possible to use that to draw the maze. maze(callback=partial(image, 'stone')) Likewise, it's also possibly to simply draw a maze with colors. For example, maze(callback=partial(shape, RECT, BLACK))","title":"Generated maze"},{"location":"examples/zombie/#random-maze","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): Sometimes it may be desirable to have some randomly placed blocks to create as obstacles. It's possible to tweak the 2.75 number to draw more or less blocks. The numbers 19 and 31 signify the HEIGHT and WIDTH of the window, in terms of grid cells. for y in range(19): for x in range(31): if rand(1, 3) > 2.75: shape(RECT, RED, (x, y), tag='wall')","title":"Random maze"},{"location":"examples/zombie/#player-actions","text":"","title":"Player Actions"},{"location":"examples/zombie/#keyboard-shortcuts","text":"NOTE: some of these shortcuts use the same keys. They can be easily changed to something else. It is not possible to assign more than one shortcut to the same keyboard key.","title":"Keyboard Shortcuts"},{"location":"examples/zombie/#change-the-walking-keys","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): The game uses arrow keys for walking by default. It's possible to change them to something else. The below example changes them to w , a , s , and d . This code will need to be added to your setup function player.keys(right = 'd', left = 'a', up = 'w', down = 's', precondition=player_physics) This code will obey the maze walls. If you want to walk through them, remove the , precondition=player_physics ending. The resulting code will look like this: player.keys(right = 'd', left = 'a', up = 'w', down = 's')","title":"Change the walking keys"},{"location":"examples/zombie/#change-facing-direction-without-moving","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): Sometimes you may want to quickly change direction and shoot without having to move. This code will rebind the arrow keys to changing the facing direction. Keep in mind that you'll need to change the walking keys or register different keys for the facing direction . This code will need to be added to your setup function. def __direction__(player, direction): \"\"\" change the players direction \"\"\" player.direction = direction player.act(IDLE, FOREVER) keydown('left', callback=partial(__direction__,player, LEFT)) keydown('right', callback=partial(__direction__,player, RIGHT)) keydown('up', callback=partial(__direction__,player, BACK)) keydown('down', callback=partial(__direction__,player, FRONT))","title":"Change facing direction (without moving)"},{"location":"examples/zombie/#inventory-controlled-weapons","text":"LOCATION GUIDE (ALL WEAPONS) : insert inside the setup function -- def setup(player, level): weapon cost energy impact air gun 2 0 c4 explosive 50 -10 flame thrower 500 -50 green rage 25 10 grenade 100 -50 landmine 50 0 machine gun 2 0 mustard gas 250 -10 punch 1 -10 wall builder 5 -5 wall buster n/a -0.25 nuclear bomb mucho grande 0 Core conceptual language - A player \"takes\" a Thing (can be anything) that is later used.","title":"Inventory Controlled Weapons"},{"location":"examples/zombie/#inventory-market-place","text":"Buy weapons, restore energy at the market place! The market place can be accessed with the F1 key during the game. All activity will be paused while you shop.","title":"Inventory Market Place"},{"location":"examples/zombie/#air-gun","text":"Shoots \"air\" bullets. Default activation is with the space bar. player.take(weapons.AirGun(call='space'))","title":"Air Gun"},{"location":"examples/zombie/#c4-explosives","text":"Drops C4 explosives. Thrown with the 7 key, detonated with the 8 key. Default throwing distance is 8 blocks and blast radius is 10 (which is about four blocks). Explosives only kill actors and do not destroy walls. player.take(weapons.C4(call='7', detonate='8', distance=8, radius=10))","title":"C4 Explosives"},{"location":"examples/zombie/#flame-thrower","text":"Throws a devastating ball of fire. It takes quite a bit of energy to generate a the fiery ball, but it's a sure way to clear out the bad guys. The flame had an internal compass that shadows the player's orientation, so move the player around for maximum effect. Generated and thrown with the 2 key. Use player directional keys after thrown to control flame ball. player.take(weapons.FlameThrower(call='2'))","title":"Flame Thrower"},{"location":"examples/zombie/#green-rage-energy-drink","text":"Give your player a dose of caffeine for continued rage! Only accessible from the inventory panel.","title":"Green Rage (Energy Drink)"},{"location":"examples/zombie/#grenade","text":"Throw a grenade with the 3 key. Default throwing distance is 6 blocks and blast radius is 10 (which is about four blocks). Grenade destroys anything in it's blasting radius - including walls! player.take(weapons.Grenade(call='3', distance=6, radius=10))","title":"Grenade"},{"location":"examples/zombie/#landmine","text":"Plant a landmine with the 6 key. The bomb is activated in one second. BE CAREFUL!! - your player can fall victim to the explosive. player.take(weapons.Landmine(call='6', delay=1))","title":"Landmine"},{"location":"examples/zombie/#machine-gun","text":"Keep your blue forces safe with the trusty machine gun! Default trigger is the 5 key with single bullets that travel 15 blocks. Want rapid fire more bullets? Be sure to set the repeat parameter. player.take(weapons.MachineGun(call='5', distance=15, repeat=1))","title":"Machine Gun"},{"location":"examples/zombie/#mustard-gas","text":"Take out your enemies with a harmful chemical weapon. Thrown with the 4 key, a mustard gas capsule travels 10 blocks and has an effective radius of 20 (about 5 blocks). The gas capsule only explodes if it hits an actor instance. player.take(weapons.MustardGas(call='4', distance=10, radius=20))","title":"Mustard Gas"},{"location":"examples/zombie/#punch","text":"When all else fails, use your hands! The simple punch is activated with the 1 key. Make sure you sneak behind your enemy as they can attack you otherwise! player.take(weapons.Punch(call='1'))","title":"Punch"},{"location":"examples/zombie/#wall-builder","text":"Have your player use walls to provide defense from the zombies. The first line sets the wall image, the second sets the directional callback keys. wall = partial(image, 'stone') player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall)) Want to use colored rectangles instead? Give this a shot: wall = partial(shape, RECT, BLACK) player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall))","title":"Wall Builder"},{"location":"examples/zombie/#wall-buster","text":"Let your player bust through the maze walls. Make sure you reset player walking keys (see above). A player that obeys physics can't bust walls! player.take(weapons.WallBuster())","title":"Wall Buster"},{"location":"examples/zombie/#nuclear-bomb","text":"OH. YEAH! Every game needs this one. Keep in mind that it takes a few seconds to call in the bomb. By default our bomb can be called in with the n key. player.take(weapons.NuclearBomb(call='n'))","title":"Nuclear Bomb"},{"location":"examples/zombie/#bonus-sprites","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): These boost sprites allow your player to earn extra energy and wealth bonuses during the game. Blue and red forces are immune to boost sprites.","title":"Bonus Sprites"},{"location":"examples/zombie/#energy-boost","text":"This code will drop sprite images with a 5% probability. Anytime the player collides with a sprite image, the player is rewarded with a 10% energy boost. def drink(soda, player): soda.destroy() player.energy = 10 fill(partial(image,'sprite', size=1.0), 0.05, player, drink)","title":"Energy Boost"},{"location":"examples/zombie/#wealth-boost","text":"This code will drop coin images with a 25% probability. Anytime the player collides with a coin image, the player is rewarded with a 5 point wealth boost. def claim(coin, player): coin.destroy() player.wealth = 5 fill(partial(image,'coin', size=1.0), 0.25, player, claim)","title":"Wealth Boost"},{"location":"examples/zombie/#friendlies","text":"LOCATION GUIDE : insert as a top-level function Your objective is to save the life of friendly forces. def get_blue(): \"\"\" create a blue (friendly) actor \"\"\" # return name of actor and grazing speed return 'Boar', 3","title":"Friendlies"},{"location":"examples/zombie/#custom-destination-image","text":"LOCATION GUIDE : insert as a top-level function Don't like the default pig pen image? It's possible to create your own with this function and then change pigpen with whatever image you want! def blue_destination(): return 'pigpen'","title":"Custom destination image"},{"location":"examples/zombie/#self-defense-hard","text":"LOCATION GUIDE : insert as a top-level function and modify get_blue It's possible to have your blue forces automate a self defense. This code is a bit weird and it still may allow hostiles to kill blue forces. Step 1: Define a self-defense function This code checks all directions to see if any red forces are within 5 blocks. When a red force is nearby, the blue throws some self defense flares -- instantly killing the enemy. def blue_defend(actor): \"\"\" activate self defense \"\"\" for direction in [BACK, FRONT, LEFT, RIGHT]: things = actor.next_object(direction=direction, distance=5) if things and has_tag(things, 'red'): actor.direction = direction actor.stop = True target = actor.next_object() if target and isinstance(target, Actor): turd = image('turd', pos=actor.pos).speed(15) turd.move_to(target.pos).destruct(2) target.kill() callback(partial(actor.act, IDLE, FOREVER), 5) Step 2: Change the get_blue function to include the newly added blue_defend self defense function. def get_blue(): \"\"\" create a blue (friendly) actor \"\"\" # return name of actor, grazing speed, self defense return 'Piggy', 2, blue_defend","title":"Self defense [HARD]"},{"location":"examples/zombie/#schedule-more-friendlies","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): It's easy to schedule more friendlies with a callback function. Here's a couple of variations. All will need to be added to your setup function. schedule a single friendly (1 second delay) callback(level.create_blue, wait=1) schedule a friendly every 10 seconds and repeat 5 times callback(level.create_blue, wait=10, repeat=5) schedule a friendly every 10 seconds and repeat forever callback(level.create_blue, wait=10, repeat=FOREVER)","title":"Schedule more friendlies"},{"location":"examples/zombie/#hostiles","text":"LOCATION GUIDE : insert as a top-level function Your object is to eliminate all hostile actors. def get_red(): \"\"\" create a red (hostile) actor \"\"\" # return name of actor, movement speed return 'Zombie-1', 1 Spawn different types of zombies at different speeds! def get_red(): \"\"\" create a red (hostile) actor \"\"\" # return name of actor, movement speed zombies = ['Zombie-1','Zombie-2','Zombie-3'] return choice(zombies), randint(1,4)","title":"Hostiles"},{"location":"examples/zombie/#schedule-more-hostiles","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): It's easy to schedule more hostiles with a callback function. Here's a couple of variations. All will need to be added to your setup function. schedule a single hostile (1 second delay) callback(level.create_red, wait=1) schedule a hostile every 10 seconds and repeat 5 times callback(level.create_red, wait=10, repeat=5) schedule a hostile every 10 seconds and repeat forever callback(level.create_red, wait=10, repeat=FOREVER)","title":"Schedule more hostiles"},{"location":"examples/zombie/#levels","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level):","title":"Levels"},{"location":"examples/zombie/#overriding-the-default-behavior-must-add","text":"It's possible to change how the story ends! Here's a few possible tricks you can try. Be sure to register your __completed__ function first! def __completed__(self): # promote level by killing all the hostiles if len(get('red')) == 0: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True # register the __completed__ function to control how the level decisions are made level.completed = MethodType(__completed__, level) You'll notice that plugging in this code will drastically change how the levels end. What happens if all the blues die? What happens if your player dies? The rest of the the updates will be specific to the __completed__ function. There is no need to register that function more than once.","title":"Overriding the default behavior (MUST ADD)"},{"location":"examples/zombie/#option-1-all-blues-go-home","text":"This code will promote the level if all blue forces go home. It will also end the game if one dies. Again, you'll want to replace your existing __completed__ function with this code. def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif self.blue_killed > 0: text('GAME OVER') gameover()","title":"Option 1: All Blues Go Home"},{"location":"examples/zombie/#option-2-option-1-player-survives","text":"def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover()","title":"Option 2: Option 1 + Player Survives"},{"location":"examples/zombie/#option-3-option-2-kill-all-the-hostiles","text":"def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif len(get('red')) == 0: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover()","title":"Option 3: Option 2 + Kill all the hostiles"},{"location":"examples/zombie/#option-4-blues-go-home-and-their-house-survives","text":"def __completed__(self): if self.blue_spawned == self.blue_safe: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif len(get('destination')) == 0: text('DESTINATION DESTROYED! GAME OVER!') gameover() elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover()","title":"Option 4: Blues go home and their house survives"},{"location":"examples/zombie/#option-5-option-4-all-reds-die","text":"def __completed__(self): if self.blue_spawned == self.blue_safe and len(get('red')) == 0: self.player.energy = 50 self.player.wealth = 250 save_state(self.player, 'player.pg') return True elif len(get('destination')) == 0: text('DESTINATION DESTROYED! GAME OVER!') gameover() elif self.blue_killed > 0 or len(get('player')) == 0: text('GAME OVER') gameover()","title":"Option 5: Option 4 + all reds die"},{"location":"examples/zombie/#scoring","text":"","title":"Scoring"},{"location":"examples/zombie/#add-countdown-timer","text":"LOCATION GUIDE : insert inside the setup function -- def setup(player, level): This code should be added to the end of the setup function. python timer(color=WHITE, value=30) If desired, it's also possible to add a countdown time that adds additional time for each level. The following code will add 30 seconds for each level. python timer(color=WHITE, value=30*level.level)","title":"Add  countdown timer"}]}