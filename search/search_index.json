{
    "docs": [
        {
            "location": "/",
            "text": "Predigame Instructional Platform\n\n\n\n\nPure Code. Pure Fun. Brain candy for the aspiring coder!\n\n\nOverview\n\n\nPredigame is an instructional platform that teaches the basics of coding through the creation of arcade games.\nThe platform was researched and developed by \nPredicate Academy\n and used for teaching kids ages 8-17 all the \namazingly cool things\n that can be created with code. Predigame is a minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface that is especially welcoming to first time coders. Predigame allows aspiring coders to familiarize themselves with \ncomputational thinking\n while\ndownplaying many of the language and keyboard nuances that come with using a text-based coding language. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist - specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are \ndirectly transferrable\n in any journey to becoming a software engineer.\n\n\nUnlike other introductory platforms that teach coding concepts through visual (drag and drop) interactions, Predigame is written in Python and Pygame. While the core gaming platform covers a number of common use cases, Predigame is completely extensible and games can be amplified with custom code.\n\n\nPredigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch). It may likely run in on other operating systems, we just haven't tested them (yet).\n\n\nWe assume that all users have some basic computer skills: typing, opening/closing windows, as well as an ability to navigate files and folders.\n\n\nExample Game - Zombie Madness\n\n\nZombie Madness is an instructional implementation that was used by \nPredicate Academy\n during their Winter and Sping 2018 seasonal classes. Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code! Click the image below for a video of the game in action!\n\n\n\n\nExample Game - Click Ninja\n\n\nClick Ninja was inspired by the app \nfruit ninja\n, but it's a little different since we have a mouse and not a touch screen. Click the image below for a video of the game in action!\n\n\n\n\nInstalling Predigame\n\n\nInstall a Text Editor\n\n\nEvery coder needs a good text editor. For python development, we recommend using \nAtom\n. New to Atom? Check out their \ndocumentation\n. Sorry Pi Users - Atom isn't currently available for Raspbian, so we'd recommend using IDLE or Thonny (both come preinstalled with Raspbian Stretch).\n\n\nMicrosoft Windows 10\n\n\nNOTE: installation will require Administrator permissions\n\n\nNew to coding and installing stuff? Check out our \nWindows Installation Video\n!\n\n\nInstall Python\n\n\nPredigame has been tested with Python v3.6.4 (\ndirect download link\n). When installing, you'll want to make sure to check the box to have Python added to your PATH (it's off by default).\n\n\n\n\nInstall Pygame\n\n\nOpen a command prompt (search: \ncommand prompt\n)\n\n\n\n\nType the following command in the command prompt window:\n\n\npython -m pip install -U pygame\n\n\n\n\nLook for line \nSuccessfully installed ...\n to indicate a successful installation.\n\n\nInstall Predigame\n\n\nOpen a command prompt (or reuse the window from the previous step) and type the following command:\n\n\npython -m pip install -U predigame\n\n\n\n\nThis can take a minute or two to complete. Look for the line \nSuccessfully installed ...\n to indicate a successful installation.\n\n\nmacOS\n\n\nNOTE: installation will require Administrator permissions\n\n\nNew to coding and installing stuff? Check out our \nmacOS installation video\n!\n\n\nInstall Python\n\n\nPredigame has been tested with Python v3.6.4 (\ndirect download link\n).\n\n\nInstall Pygame\n\n\nOpen a Terminal (command search: \nTerminal\n or visit \nthis link\n for help). Type the following command in the terminal:\n\n\nsudo pip3 install -U pygame\n\n\n\n\nThis command will require an administrator account and a prompt for a password. Look for line \nSuccessfully installed ...\n to indicate a successful installation.\n\n\nInstall Predigame\n\n\nOpen a command prompt (or reuse the window from the previous step) and type the following command:\n\n\nsudo pip3 install -U predigame\n\n\n\n\nThis command will require an administrator account and a prompt for a password. The process can take a minute or two to complete. Look for the line \nSuccessfully installed ...\n to indicate a successful installation.\n\n\nRaspberry Pi\n\n\nGood news Pi fans! You're just a \npip3 install\n away from coding your first game! Open a Terminal and type the following command:\n\n\nsudo pip3 install -U predigame\n\n\n\n\nNew to coding and installing stuff? Check out our \nRaspberry Pi Installation Video\n!\n\n\nUpdating Predigame\n\n\nPredigame changes frequently. Run the following command(s) to ensure you have the latest and greatest release.\n\n\nWindows\n\n\npython -m pip uninstall predigame\npython -m pip install predigame\n\n\n\n\nWe're not sure \npip install -U\n  works correctly on Windows, so it's always good to uninstall first.\n\n\nmacOS and Raspberry Pi\n\n\nsudo pip3 install -U predigame\n\n\n\n\nGetting Started\n\n\nNow that you have Predigame installed, let's open a command prompt (Windows) or terminal (macOS, Pi) and test out to an existing game to make sure things are working correctly.\n\n\nList available game downloads:\n\n\npred list\n\n\n\n\nTry downloading the \nclickninja\n game:\n\n\npred pull clickninja\n\n\n\n\nAssuming that was successful, let's try to start the game!\n\n\ncd clickninja\npred clickninja-levels.py\n\n\n\n\nThe \nr\n key can be used to reset the game. Hit \nEsc\n to close the window. If you want to run again, the \ncd clickninja\n command may not be necessary (if you are already in the \nclickninja\n directory).\n\n\nWant to learn more about customizing Click Ninja? Check out the the \ngame tutorial\n.\n\n\nmacOS Certificate Errors\n\n\nSome macOS users may see this error the first time using \npred\n:\n\n\nssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:749)\n\n\n\n\nIf that happens, run this command to install the certificates and try again:\n\n\nsudo /Applications/Python 3.6/Install Certificates.command\n\n\n\n\nCoding Your First Game\n\n\nOur first game is going to be a digital picture frame. It's not \nTECHNICALLY\n a game, rather a fun example that showcases some of the flexibilities and power of Predigame.\n\n\nOpen a command prompt (Windows) or terminal (macOS, Pi) and run the following command to create a new game:\n\n\npred new hello\n\n\n\n\nNote\n For windows users, it may be easier to run \ncd Desktop\n prior to \npred new\n (files and folders stored on the desktop will be a little easier to find).\n\n\nThis command will create a new directory \nhello\n and game template \nhello/game.py\n as well as some subdirectories that will be useful to hold custom images, backgrounds, and sounds. Using your favorite code editor, open the file \ngame.py\n. You'll notice the game already has a few lines of code (we'll discuss what those mean next).\n\n\nTry adding this line to the bottom of the file:\n\n\nbackground()\n\n\n\n\nSo the completed code example should look like:\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Simple Game'\n\nbackground()\n\n\n\n\nSave your changes. Then in the terminal, you'll want to run:\n\n\npred game.py\n\n\n\n\nDid you see the background picture? Make sure you \ncd hello\n prior to running \npred\n as you need to be in the same directory as your python files.\n\n\nThere you go! First \"game\" down. Take a look at the \nPicture Frame\n example for some other cool coding additions.\n\n\nAPI Docs\n\n\nPredigame API documentation can be found here: \nhttp://predigame.io/api\n. Not sure what this means? Don't worry. We'll cover this later!\n\n\nSupport\n\n\nFind a bug? Have a question?\n\n\n\n\nVisit our Support Forum: \nhttps://groups.google.com/a/predicate.us/forum/#!forum/supportloc\n\n\nGitHub User? Fork our repos - \nhttps://github.com/predigame\n. We happily take pull requests :)",
            "title": "Home"
        },
        {
            "location": "/#predigame-instructional-platform",
            "text": "Pure Code. Pure Fun. Brain candy for the aspiring coder!",
            "title": "Predigame Instructional Platform"
        },
        {
            "location": "/#overview",
            "text": "Predigame is an instructional platform that teaches the basics of coding through the creation of arcade games.\nThe platform was researched and developed by  Predicate Academy  and used for teaching kids ages 8-17 all the  amazingly cool things  that can be created with code. Predigame is a minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface that is especially welcoming to first time coders. Predigame allows aspiring coders to familiarize themselves with  computational thinking  while\ndownplaying many of the language and keyboard nuances that come with using a text-based coding language. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist - specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are  directly transferrable  in any journey to becoming a software engineer.  Unlike other introductory platforms that teach coding concepts through visual (drag and drop) interactions, Predigame is written in Python and Pygame. While the core gaming platform covers a number of common use cases, Predigame is completely extensible and games can be amplified with custom code.  Predigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch). It may likely run in on other operating systems, we just haven't tested them (yet).  We assume that all users have some basic computer skills: typing, opening/closing windows, as well as an ability to navigate files and folders.",
            "title": "Overview"
        },
        {
            "location": "/#example-game-zombie-madness",
            "text": "Zombie Madness is an instructional implementation that was used by  Predicate Academy  during their Winter and Sping 2018 seasonal classes. Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code! Click the image below for a video of the game in action!",
            "title": "Example Game - Zombie Madness"
        },
        {
            "location": "/#example-game-click-ninja",
            "text": "Click Ninja was inspired by the app  fruit ninja , but it's a little different since we have a mouse and not a touch screen. Click the image below for a video of the game in action!",
            "title": "Example Game - Click Ninja"
        },
        {
            "location": "/#installing-predigame",
            "text": "",
            "title": "Installing Predigame"
        },
        {
            "location": "/#install-a-text-editor",
            "text": "Every coder needs a good text editor. For python development, we recommend using  Atom . New to Atom? Check out their  documentation . Sorry Pi Users - Atom isn't currently available for Raspbian, so we'd recommend using IDLE or Thonny (both come preinstalled with Raspbian Stretch).",
            "title": "Install a Text Editor"
        },
        {
            "location": "/#microsoft-windows-10",
            "text": "NOTE: installation will require Administrator permissions  New to coding and installing stuff? Check out our  Windows Installation Video !  Install Python  Predigame has been tested with Python v3.6.4 ( direct download link ). When installing, you'll want to make sure to check the box to have Python added to your PATH (it's off by default).   Install Pygame  Open a command prompt (search:  command prompt )   Type the following command in the command prompt window:  python -m pip install -U pygame  Look for line  Successfully installed ...  to indicate a successful installation.  Install Predigame  Open a command prompt (or reuse the window from the previous step) and type the following command:  python -m pip install -U predigame  This can take a minute or two to complete. Look for the line  Successfully installed ...  to indicate a successful installation.",
            "title": "Microsoft Windows 10"
        },
        {
            "location": "/#macos",
            "text": "NOTE: installation will require Administrator permissions  New to coding and installing stuff? Check out our  macOS installation video !  Install Python  Predigame has been tested with Python v3.6.4 ( direct download link ).  Install Pygame  Open a Terminal (command search:  Terminal  or visit  this link  for help). Type the following command in the terminal:  sudo pip3 install -U pygame  This command will require an administrator account and a prompt for a password. Look for line  Successfully installed ...  to indicate a successful installation.  Install Predigame  Open a command prompt (or reuse the window from the previous step) and type the following command:  sudo pip3 install -U predigame  This command will require an administrator account and a prompt for a password. The process can take a minute or two to complete. Look for the line  Successfully installed ...  to indicate a successful installation.",
            "title": "macOS"
        },
        {
            "location": "/#raspberry-pi",
            "text": "Good news Pi fans! You're just a  pip3 install  away from coding your first game! Open a Terminal and type the following command:  sudo pip3 install -U predigame  New to coding and installing stuff? Check out our  Raspberry Pi Installation Video !",
            "title": "Raspberry Pi"
        },
        {
            "location": "/#updating-predigame",
            "text": "Predigame changes frequently. Run the following command(s) to ensure you have the latest and greatest release.",
            "title": "Updating Predigame"
        },
        {
            "location": "/#windows",
            "text": "python -m pip uninstall predigame\npython -m pip install predigame  We're not sure  pip install -U   works correctly on Windows, so it's always good to uninstall first.",
            "title": "Windows"
        },
        {
            "location": "/#macos-and-raspberry-pi",
            "text": "sudo pip3 install -U predigame",
            "title": "macOS and Raspberry Pi"
        },
        {
            "location": "/#getting-started",
            "text": "Now that you have Predigame installed, let's open a command prompt (Windows) or terminal (macOS, Pi) and test out to an existing game to make sure things are working correctly.  List available game downloads:  pred list  Try downloading the  clickninja  game:  pred pull clickninja  Assuming that was successful, let's try to start the game!  cd clickninja\npred clickninja-levels.py  The  r  key can be used to reset the game. Hit  Esc  to close the window. If you want to run again, the  cd clickninja  command may not be necessary (if you are already in the  clickninja  directory).  Want to learn more about customizing Click Ninja? Check out the the  game tutorial .",
            "title": "Getting Started"
        },
        {
            "location": "/#macos-certificate-errors",
            "text": "Some macOS users may see this error the first time using  pred :  ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:749)  If that happens, run this command to install the certificates and try again:  sudo /Applications/Python 3.6/Install Certificates.command",
            "title": "macOS Certificate Errors"
        },
        {
            "location": "/#coding-your-first-game",
            "text": "Our first game is going to be a digital picture frame. It's not  TECHNICALLY  a game, rather a fun example that showcases some of the flexibilities and power of Predigame.  Open a command prompt (Windows) or terminal (macOS, Pi) and run the following command to create a new game:  pred new hello  Note  For windows users, it may be easier to run  cd Desktop  prior to  pred new  (files and folders stored on the desktop will be a little easier to find).  This command will create a new directory  hello  and game template  hello/game.py  as well as some subdirectories that will be useful to hold custom images, backgrounds, and sounds. Using your favorite code editor, open the file  game.py . You'll notice the game already has a few lines of code (we'll discuss what those mean next).  Try adding this line to the bottom of the file:  background()  So the completed code example should look like:  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Simple Game'\n\nbackground()  Save your changes. Then in the terminal, you'll want to run:  pred game.py  Did you see the background picture? Make sure you  cd hello  prior to running  pred  as you need to be in the same directory as your python files.  There you go! First \"game\" down. Take a look at the  Picture Frame  example for some other cool coding additions.",
            "title": "Coding Your First Game"
        },
        {
            "location": "/#api-docs",
            "text": "Predigame API documentation can be found here:  http://predigame.io/api . Not sure what this means? Don't worry. We'll cover this later!",
            "title": "API Docs"
        },
        {
            "location": "/#support",
            "text": "Find a bug? Have a question?   Visit our Support Forum:  https://groups.google.com/a/predicate.us/forum/#!forum/supportloc  GitHub User? Fork our repos -  https://github.com/predigame . We happily take pull requests :)",
            "title": "Support"
        },
        {
            "location": "/about/",
            "text": "The Predicate Project: Rethinking Technology Education\n\n\nEducation should prepare young people for jobs that do not yet exist, using technologies that have not been invented, to solve problems of which we are not yet aware.\n - \nRichard Riley\n\n\nWhen I was in 10th grade I was \"academically floundering\" - a \"C\" and \"D\" student at best. No drive to do well in school. I clearly didn't understand nor did I care about the big picture. Then I took a technology class that was given by a former metal shop teacher who had a grasp of the future. This was back in the early 1990s and the computing field wasn\u2019t much at the time. We made an intercom \u2013 no, it wasn\u2019t two cans and a string \u2013 rather, it was a silk-screened circuit board. We drilled all the holes, soldered the electronic components (while also learning how each of those components worked in unison to deliver a capability). The highlight for me was bringing it home and installing MY creation in my bedroom. Even today, I remember that class vividly \u2013 it had an impact, that 25 years later continues to mold my life. I have a tremendous appreciation for the teachers who are some of the earliest role models for our children. Day in and day out, they work on the educational front lines \u2013 lecturing, encouraging, mentoring, correcting \u2013 and they see it all. A good teacher can positively impact a child for life.\n\n\nAs a parent and technology professional, I\u2019ve often battled with the question \u2013 are we doing enough to prepare our children for the future? My day job is a Research Director at \nTwo Six Labs\n \u2013 a company that pushes the boundaries of the possible to protect the future. Our mission requires that we hire some amazingly talented people and it should come as no surprise that fueling the hiring needs of a growing organization can be as challenging as creating breakthrough technologies.\n\n\nFor today\u2019s 10-year-old in 5th grade \u2013 there\u2019s a solid seven years remaining in primary education and potentially another four (maybe more) before hitting the workforce.  Adding it all up, if all these numbers hold and my math is correct, a 5th grader in 2018 would graduate high school in 2025, and college in 2029. While it seems like a long way ahead, there are things we can do today to prepare our children for the future.\n\n\nThe challenge is that for all of the technological innovations, we\u2019ve actually made it harder for our children to learn about technology. We live in consumption driven times and, for most children, technology is only \u201cseen\u201d from the lens of a user. There is, unfortunately, an established expectation for immediate results and an equal instantaneous cloud of discouragement and frustration when something doesn\u2019t work as expected. At our home, simply the loss of electricity is a reminder of our childrens\u2019 lens through which they see technology. However, for every game, every Netflix stream, app, website, robotic vacuum cleaner, and drone, there is someone whose job it is to design the next big idea and someone who makes that idea come to life. We need to provide a different lens for seeing technology \u2013 from that of the creator.\n\n\n\n\nIn January 2016 my wife and I started Predicate Academy \u2013 a \u201cboutique\u201d school that teaches coding to kids ages 8 and up in a small Southern New Jersey town. Prior to Predicate, I had no teaching experience, but I\u2019m a problem solver at heart, and I felt increasingly motivated to figure out how to \u201cfix\u201d technology education. My vision for Predicate was to create an environment where we change the way children learn about technology. To be honest, I had no idea how I was going to accomplish this challenge, but I\u2019ve been dissatisfied with the void of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. So that was my starting point. I was particularly attracted to the work being done by the Raspberry Pi Foundation \u2013 they use many of the same \u201ctools of the trade\u201d \u2013 Linux, command line, modern programming languages - that are used in the field.  And the devices are only $35USD, so everybody can own one, even if coding isn\u2019t their thing. So, we bought Pis, lots of Pis! Since 2016, we\u2019ve put more than 1000 Pis out in the wild.\n\n\n\n\nAn interesting paradox at Predicate is that while we focus on education, our aspiring innovators do not see Predicate Academy as a school. Why not? Frequent responses are: \u201cit\u2019s coding\u201d, \u201cwe make games\u201d, \u201cit\u2019s fun\u201d, \u201cthere is no homework\u201d. I believe I\u2019ve successfully exploited this belief by being able to bury some dense mathematical and physics concepts in the context of \u201ccoding\u201d. Computer Science is multidisciplinary field with roots in Mathematics and Physics, and going back to its roots, is rich with applied educational value. In any given week some of our classes would be converting between seconds and milliseconds, writing algebraic formulas to make a LED pulse, computing Euclidean distance, and even understanding the frequency spectrum.\n\n\nBut teaching is incredibly hard work! While I only hold a few classes a week at Predicate, a technical glitch can wreak chaos on a class. Through it all, though, one of the most unexpected surprises is to see the weekly progression of our aspiring innovators. Their curiosity and excitement is equally contagious \u2013 far more than I would have ever estimated. I have a handful of kids that have assembled a wealth of command line foo and a few others that have mastered nmap and ssh (so much so I had to change our in-class code deployment processes). We have some very talented future technologists and it\u2019s been a true honor to be a part of their educational journey.\n\n\n\n\nI genuinely believe that with every passing class, we are becoming increasingly aware of better ways to deliver technology education. Direct feedback from our innovators and their parents has offered continued motivation to see our vision through. In many ways, I\u2019m reliving an educational experience I had many years ago and it\u2019s been great to see the impact that Predicate has had in our community.\n\n\n\n\n\n\nPredicate has allowed us to see excitement in our budding inventor \u2013 more than any other extracurricular activity he has tried!  Drew may be quiet while concentrating in coding class, but then he comes home and runs to set up the latest project declaring, \u201cYou HAVE to see this,\u201d to the whole family! What an amazing and smart way to spread the love of coding and computers to our future inventors, scientists and leaders!\n\n\n\n\n\n\nKevin\u2019s experience at Predicate Academy has been amazing!  He has been able to apply what he has learned in his Journey sessions to create a video game in his high school\u2019s Computer System and Video Game Design class.  Kevin designed a fully interactive game that required coding and creating sprites, sounds, backgrounds, objects, controllers, and levels.  The game has three lives and secret Easter Egg levels.  If a player passes all the levels, the game can provide up to thirty minutes of entertainment! We are thrilled that Kevin is a part of something so special at Predicate Academy!  Not only is he gaining valuable real-life skills to take into the classroom and world, but Predicate has given him the knowledge and confidence to share these skills with his high school classmates!\n\n\n\n\n\n\nSome time ago, Ryan decided that he wanted to be a coder when he grew up.  I knew he liked playing video games and Minecraft mods, so I guess that\u2019s where he got the idea that he wanted to be a coder.  With the help of a junior programming book, we tried to do a little programming at home, but I was not very successful helping him to understand the concepts or make it applicable to his interests.  We came across a Facebook mention of a Predicate Academy open house and went to check it out.  Mr. Mike showed us the Python programming and physical computing interaction with the Raspberry Pi and Ryan was immediately hooked.  The computing projects at Predicate Academy provide him with just the right mix of challenge, skill development and fun.  Ryan looks forward to going to class every week and he can\u2019t wait to continue learning how to code at Predicate Academy!\n\n\n\n\n\n\nWhile we have been teaching our aspiring innovators how to code, we\u2019ve also been studying how children respond to these concepts (and, well, education in general).  Painting in broad strokes, a number of consistent themes surfaced in our classes:\n\n\n\n\n\n\nMost kids (at least in our area) are familiar with coding prior to coming to Predicate, but it is often limited to Computer Science Education Week and the Hour of Code.\n\n\n\n\n\n\nTyping skills are wildly varying and navigation around special keys (especially those used in most coding languages) is a challenge. I\u2019m always amused when kids come in and ask: \u201cMr. Mike, are we going to do any typing today in coding class?\u201d.\n\n\n\n\n\n\nFamiliarity on a topic can bias attention. I\u2019ll deem this \u201cMinecraft Fatigue\u201d \u2013 a growing number of 12-year olds are increasingly disinterested in all things related to Minecraft. Want to demonstrate loops and 3-dimensional spaces? It better not be done in Minecraft.\n\n\n\n\n\n\nKids \u201cthink\u201d they can multitask in front of a computer. That is, they think they can surf the web while also following along to a technical concept presentation. In general, I can have about 10 minutes of attention before the multitasking gears kick in.\n\n\n\n\n\n\nOver the last three years, we have established a fairly decent understanding of our limits \u2013technically, mentally, even emotionally \u2013 that allow us to shape technology education in a way that keeps the classes engaged while also ensuring they are actively learning new concepts. But there is a consistently large void in meeting the expectations of children who are quick to default into \u201cconsumption mode\u201d. Why would they be interested in coding \u201cpong\u201d when they can go home and play Fortnite? This is a regular barrier for success at Predicate and I\u2019d argue it hampers progression for technology education in general. Sustaining motivation in our kids is a key factor for them to stay engaged. I do not see this as an education problem but rather a technology problem \u2013 complexity that can be achieved through abstraction.\n\n\nOver the past year, we\u2019ve been working on an instructional platform that teaches the basics of coding through the creation of arcade games. The aptly named \u201cPredigame\u201d was originally developed by \n@Gabe-Linux\n as a way to introduce text-based coding to our younger innovators. Their response fueled continued work on the project. Today, Predigame is minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface allowing aspiring coders to familiarize themselves with computational thinking while downplaying many of the nuances that come with giving instructions to a computer. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist. Specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are directly transferrable in any journey to becoming a software engineer.\n\n\n\n\nWe\u2019re really excited to offer Predigame \npredigame.io\n to the open source community as a solution to address the needs of intermediate coders in search of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. Predigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch).\n\n\nGive it a shot and let\u2019s change the way our children learn about technology!\n\n\n\n\nMichael Orr\n\n\n(\n@predicatemike\n, \n@mrsqueeze\n)\n\n\nParent, Technologist, Sunday Sound Guy, Teacher",
            "title": "About"
        },
        {
            "location": "/about/#the-predicate-project-rethinking-technology-education",
            "text": "Education should prepare young people for jobs that do not yet exist, using technologies that have not been invented, to solve problems of which we are not yet aware.  -  Richard Riley  When I was in 10th grade I was \"academically floundering\" - a \"C\" and \"D\" student at best. No drive to do well in school. I clearly didn't understand nor did I care about the big picture. Then I took a technology class that was given by a former metal shop teacher who had a grasp of the future. This was back in the early 1990s and the computing field wasn\u2019t much at the time. We made an intercom \u2013 no, it wasn\u2019t two cans and a string \u2013 rather, it was a silk-screened circuit board. We drilled all the holes, soldered the electronic components (while also learning how each of those components worked in unison to deliver a capability). The highlight for me was bringing it home and installing MY creation in my bedroom. Even today, I remember that class vividly \u2013 it had an impact, that 25 years later continues to mold my life. I have a tremendous appreciation for the teachers who are some of the earliest role models for our children. Day in and day out, they work on the educational front lines \u2013 lecturing, encouraging, mentoring, correcting \u2013 and they see it all. A good teacher can positively impact a child for life.  As a parent and technology professional, I\u2019ve often battled with the question \u2013 are we doing enough to prepare our children for the future? My day job is a Research Director at  Two Six Labs  \u2013 a company that pushes the boundaries of the possible to protect the future. Our mission requires that we hire some amazingly talented people and it should come as no surprise that fueling the hiring needs of a growing organization can be as challenging as creating breakthrough technologies.  For today\u2019s 10-year-old in 5th grade \u2013 there\u2019s a solid seven years remaining in primary education and potentially another four (maybe more) before hitting the workforce.  Adding it all up, if all these numbers hold and my math is correct, a 5th grader in 2018 would graduate high school in 2025, and college in 2029. While it seems like a long way ahead, there are things we can do today to prepare our children for the future.  The challenge is that for all of the technological innovations, we\u2019ve actually made it harder for our children to learn about technology. We live in consumption driven times and, for most children, technology is only \u201cseen\u201d from the lens of a user. There is, unfortunately, an established expectation for immediate results and an equal instantaneous cloud of discouragement and frustration when something doesn\u2019t work as expected. At our home, simply the loss of electricity is a reminder of our childrens\u2019 lens through which they see technology. However, for every game, every Netflix stream, app, website, robotic vacuum cleaner, and drone, there is someone whose job it is to design the next big idea and someone who makes that idea come to life. We need to provide a different lens for seeing technology \u2013 from that of the creator.   In January 2016 my wife and I started Predicate Academy \u2013 a \u201cboutique\u201d school that teaches coding to kids ages 8 and up in a small Southern New Jersey town. Prior to Predicate, I had no teaching experience, but I\u2019m a problem solver at heart, and I felt increasingly motivated to figure out how to \u201cfix\u201d technology education. My vision for Predicate was to create an environment where we change the way children learn about technology. To be honest, I had no idea how I was going to accomplish this challenge, but I\u2019ve been dissatisfied with the void of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. So that was my starting point. I was particularly attracted to the work being done by the Raspberry Pi Foundation \u2013 they use many of the same \u201ctools of the trade\u201d \u2013 Linux, command line, modern programming languages - that are used in the field.  And the devices are only $35USD, so everybody can own one, even if coding isn\u2019t their thing. So, we bought Pis, lots of Pis! Since 2016, we\u2019ve put more than 1000 Pis out in the wild.   An interesting paradox at Predicate is that while we focus on education, our aspiring innovators do not see Predicate Academy as a school. Why not? Frequent responses are: \u201cit\u2019s coding\u201d, \u201cwe make games\u201d, \u201cit\u2019s fun\u201d, \u201cthere is no homework\u201d. I believe I\u2019ve successfully exploited this belief by being able to bury some dense mathematical and physics concepts in the context of \u201ccoding\u201d. Computer Science is multidisciplinary field with roots in Mathematics and Physics, and going back to its roots, is rich with applied educational value. In any given week some of our classes would be converting between seconds and milliseconds, writing algebraic formulas to make a LED pulse, computing Euclidean distance, and even understanding the frequency spectrum.  But teaching is incredibly hard work! While I only hold a few classes a week at Predicate, a technical glitch can wreak chaos on a class. Through it all, though, one of the most unexpected surprises is to see the weekly progression of our aspiring innovators. Their curiosity and excitement is equally contagious \u2013 far more than I would have ever estimated. I have a handful of kids that have assembled a wealth of command line foo and a few others that have mastered nmap and ssh (so much so I had to change our in-class code deployment processes). We have some very talented future technologists and it\u2019s been a true honor to be a part of their educational journey.   I genuinely believe that with every passing class, we are becoming increasingly aware of better ways to deliver technology education. Direct feedback from our innovators and their parents has offered continued motivation to see our vision through. In many ways, I\u2019m reliving an educational experience I had many years ago and it\u2019s been great to see the impact that Predicate has had in our community.    Predicate has allowed us to see excitement in our budding inventor \u2013 more than any other extracurricular activity he has tried!  Drew may be quiet while concentrating in coding class, but then he comes home and runs to set up the latest project declaring, \u201cYou HAVE to see this,\u201d to the whole family! What an amazing and smart way to spread the love of coding and computers to our future inventors, scientists and leaders!    Kevin\u2019s experience at Predicate Academy has been amazing!  He has been able to apply what he has learned in his Journey sessions to create a video game in his high school\u2019s Computer System and Video Game Design class.  Kevin designed a fully interactive game that required coding and creating sprites, sounds, backgrounds, objects, controllers, and levels.  The game has three lives and secret Easter Egg levels.  If a player passes all the levels, the game can provide up to thirty minutes of entertainment! We are thrilled that Kevin is a part of something so special at Predicate Academy!  Not only is he gaining valuable real-life skills to take into the classroom and world, but Predicate has given him the knowledge and confidence to share these skills with his high school classmates!    Some time ago, Ryan decided that he wanted to be a coder when he grew up.  I knew he liked playing video games and Minecraft mods, so I guess that\u2019s where he got the idea that he wanted to be a coder.  With the help of a junior programming book, we tried to do a little programming at home, but I was not very successful helping him to understand the concepts or make it applicable to his interests.  We came across a Facebook mention of a Predicate Academy open house and went to check it out.  Mr. Mike showed us the Python programming and physical computing interaction with the Raspberry Pi and Ryan was immediately hooked.  The computing projects at Predicate Academy provide him with just the right mix of challenge, skill development and fun.  Ryan looks forward to going to class every week and he can\u2019t wait to continue learning how to code at Predicate Academy!    While we have been teaching our aspiring innovators how to code, we\u2019ve also been studying how children respond to these concepts (and, well, education in general).  Painting in broad strokes, a number of consistent themes surfaced in our classes:    Most kids (at least in our area) are familiar with coding prior to coming to Predicate, but it is often limited to Computer Science Education Week and the Hour of Code.    Typing skills are wildly varying and navigation around special keys (especially those used in most coding languages) is a challenge. I\u2019m always amused when kids come in and ask: \u201cMr. Mike, are we going to do any typing today in coding class?\u201d.    Familiarity on a topic can bias attention. I\u2019ll deem this \u201cMinecraft Fatigue\u201d \u2013 a growing number of 12-year olds are increasingly disinterested in all things related to Minecraft. Want to demonstrate loops and 3-dimensional spaces? It better not be done in Minecraft.    Kids \u201cthink\u201d they can multitask in front of a computer. That is, they think they can surf the web while also following along to a technical concept presentation. In general, I can have about 10 minutes of attention before the multitasking gears kick in.    Over the last three years, we have established a fairly decent understanding of our limits \u2013technically, mentally, even emotionally \u2013 that allow us to shape technology education in a way that keeps the classes engaged while also ensuring they are actively learning new concepts. But there is a consistently large void in meeting the expectations of children who are quick to default into \u201cconsumption mode\u201d. Why would they be interested in coding \u201cpong\u201d when they can go home and play Fortnite? This is a regular barrier for success at Predicate and I\u2019d argue it hampers progression for technology education in general. Sustaining motivation in our kids is a key factor for them to stay engaged. I do not see this as an education problem but rather a technology problem \u2013 complexity that can be achieved through abstraction.  Over the past year, we\u2019ve been working on an instructional platform that teaches the basics of coding through the creation of arcade games. The aptly named \u201cPredigame\u201d was originally developed by  @Gabe-Linux  as a way to introduce text-based coding to our younger innovators. Their response fueled continued work on the project. Today, Predigame is minimalistic platform and makes extensive use of coding abstractions to present a \"low lift\" interface allowing aspiring coders to familiarize themselves with computational thinking while downplaying many of the nuances that come with giving instructions to a computer. Holding true to form, Predigame seeks to offer a coding experience through the lens of a technologist. Specific emphasis is given towards software design, modern programming languages, command line execution, error debugging - skills that are directly transferrable in any journey to becoming a software engineer.   We\u2019re really excited to offer Predigame  predigame.io  to the open source community as a solution to address the needs of intermediate coders in search of a middle ground between Hour of Code/Scratch/Blockly and full-fledged coding. Predigame requires minimum computing resources and has been tested on Microsoft Windows 10, macOS 10.12+ (Sierra and High Sierra), and Raspberry Pi Model 2B/3B (Raspbian Jessie and Stretch).  Give it a shot and let\u2019s change the way our children learn about technology!   Michael Orr  ( @predicatemike ,  @mrsqueeze )  Parent, Technologist, Sunday Sound Guy, Teacher",
            "title": "The Predicate Project: Rethinking Technology Education"
        },
        {
            "location": "/examples/fireworks/",
            "text": "Fireworks!\n\n\nA relatively simple and fun Predigame example that highlights image sprites, callbacks, and sound effects.\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nDownload Existing Game (Optional)\n\n\nWe have a version of this game already done and ready to go. Just run the following command:\n\n\npred pull fireworks\n\n\n\n\nThen read the rest of the tutorial and follow along.\n\n\nGetting Started\n\n\nTo get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:\n\n\npred new fireworks\n\n\n\n\nNow in the text editor, find and open the file \nfireworks/game.py\n. Now let's get started!\n\n\nFor the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and window title:\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Fireworks!'\n\n\n\n\nSince fireworks normally launch in the evening, we'll paint our background black.\n\n\n# make the background black\nBACKGROUND = (0,0,0)\n\n\n\n\nThis defines the background using a RGB (RED, GREEN, BLUE) tuple. We also have some constants defined for common colors, so setting the line this way would have the same effect:\n\n\n# make the background black\nBACKGROUND = BLACK\n\n\n\n\nFor your game, you may wish to use a background image instead. That's possible provided that the image is stored in the \nbackgrounds/\n directory. Then the code would look something like this (\nNOTE that we don't use file extensions for images, backgrounds, and sounds\n).\n\n\n# use a background image\nBACKGROUND = 'castle_at_night'\n\n\n\n\nThe core of the game consists of two callbacks. First is a one to launch the firework and the second to create the explosion effect. Let's cover launching first:\n\n\ndef launch():\n        # play a sound\n        sound('fireworks')\n\n        # create a random position with some padding to keep away from edges\n        p = rand_pos(x_padding=5, y_padding=10)\n\n        # create a really small yellow circle\n        # position circle at point p's x coordinate but under the viewable area\n        s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1)\n\n        # move the sprite to the designated area\n        # callback (destroy) will be invoked when sprite arrives at destination\n        s.speed(15).move_to(p, callback=s.destroy)\n\n        # schedule to have the launch function called again..\n        # some random time between 0 and 3 seconds\n        callback(launch, rand(0, 3))\n\n# start show in 1 second!\ncallback(launch, 1)\n\n\n\n\nNow let's give it a test run!\n\n\npred game.py\n\n\n\n\nYou'll notice that fireworks launch and sound effects are playing, but there is \nno explosion\n! That's due to this line:\n\n\n        s.speed(15).move_to(p, callback=s.destroy)\n\n\n\n\nOnce the yellow circle sprite moves to point \np\n the callback \ns.destroy\n is invoked. As the name implies, that simply destroys the sprite.\n\n\nNow let's handle the explosion. We'll define a function to handle that effect:\n\n\ndef explode(s):\n        s.destroy()\n        # pick a random number between 1 and 5\n        num = randint(1, 5)\n        # load the fireworks image sprite\n        img = image('fireworks-'+str(num), s.pos, size=0.5)\n        # make the image pulse (get big), destroy between 0.1 and 4 seconds\n        img.pulse(time=4, size=10).destruct(rand(0.1,4))\n\n\n\n\nIn our example, we currently have five fireworks images in our \nimages/\n directory:\n\n\nfireworks-1.png fireworks-2.png fireworks-3.png fireworks-4.png fireworks-5.png\n\n\n\n\nGo ahead a find some fireworks of your own. Transparent images always work best. You'll want to label them similar to how we did so it's easy to randomly pick one of the images. The \nrandint(1,5)\n line simply picks a number between 1 and 5 at random. The image will initially render at roughly sized at one half a grid cell. The image will slowly pulse with a four second interval. Note that the image will \ndestruct\n between 0.1 and 4 seconds, so this basically means the firework will expand and never contract.\n\n\nWith the explosion defined, we'll now want to go back and reset the yellow sprite callback to use our new \nexplode\n function:\n\n\n        s.speed(15).move_to(p, callback=partial(explode, s))\n\n\n\n\nHere's the completed version (without comments):\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Fireworks!'\n\nBACKGROUND = (0,0,0)\n\ndef explode(s):\n        s.destroy()\n        num = randint(1, 5)\n        img = image('fireworks-'+str(num), s.pos, size=0.5)\n        img.pulse(time=4, size=10).destruct(rand(0.1,4))\n\ndef launch():\n        sound('fireworks')\n        p = rand_pos(x_padding=5, y_padding=10)\n        s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1)\n        s.speed(15).move_to(p, callback=partial(explode, s))\n        callback(launch, rand(0, 3))\n\ncallback(launch, 1)\n\n\n\n\nSave your changes and enjoy the show!\n\n\npred game.py",
            "title": "Fireworks!"
        },
        {
            "location": "/examples/fireworks/#fireworks",
            "text": "A relatively simple and fun Predigame example that highlights image sprites, callbacks, and sound effects.",
            "title": "Fireworks!"
        },
        {
            "location": "/examples/fireworks/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/fireworks/#download-existing-game-optional",
            "text": "We have a version of this game already done and ready to go. Just run the following command:  pred pull fireworks  Then read the rest of the tutorial and follow along.",
            "title": "Download Existing Game (Optional)"
        },
        {
            "location": "/examples/fireworks/#getting-started",
            "text": "To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:  pred new fireworks  Now in the text editor, find and open the file  fireworks/game.py . Now let's get started!  For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and window title:  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Fireworks!'  Since fireworks normally launch in the evening, we'll paint our background black.  # make the background black\nBACKGROUND = (0,0,0)  This defines the background using a RGB (RED, GREEN, BLUE) tuple. We also have some constants defined for common colors, so setting the line this way would have the same effect:  # make the background black\nBACKGROUND = BLACK  For your game, you may wish to use a background image instead. That's possible provided that the image is stored in the  backgrounds/  directory. Then the code would look something like this ( NOTE that we don't use file extensions for images, backgrounds, and sounds ).  # use a background image\nBACKGROUND = 'castle_at_night'  The core of the game consists of two callbacks. First is a one to launch the firework and the second to create the explosion effect. Let's cover launching first:  def launch():\n        # play a sound\n        sound('fireworks')\n\n        # create a random position with some padding to keep away from edges\n        p = rand_pos(x_padding=5, y_padding=10)\n\n        # create a really small yellow circle\n        # position circle at point p's x coordinate but under the viewable area\n        s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1)\n\n        # move the sprite to the designated area\n        # callback (destroy) will be invoked when sprite arrives at destination\n        s.speed(15).move_to(p, callback=s.destroy)\n\n        # schedule to have the launch function called again..\n        # some random time between 0 and 3 seconds\n        callback(launch, rand(0, 3))\n\n# start show in 1 second!\ncallback(launch, 1)  Now let's give it a test run!  pred game.py  You'll notice that fireworks launch and sound effects are playing, but there is  no explosion ! That's due to this line:          s.speed(15).move_to(p, callback=s.destroy)  Once the yellow circle sprite moves to point  p  the callback  s.destroy  is invoked. As the name implies, that simply destroys the sprite.  Now let's handle the explosion. We'll define a function to handle that effect:  def explode(s):\n        s.destroy()\n        # pick a random number between 1 and 5\n        num = randint(1, 5)\n        # load the fireworks image sprite\n        img = image('fireworks-'+str(num), s.pos, size=0.5)\n        # make the image pulse (get big), destroy between 0.1 and 4 seconds\n        img.pulse(time=4, size=10).destruct(rand(0.1,4))  In our example, we currently have five fireworks images in our  images/  directory:  fireworks-1.png fireworks-2.png fireworks-3.png fireworks-4.png fireworks-5.png  Go ahead a find some fireworks of your own. Transparent images always work best. You'll want to label them similar to how we did so it's easy to randomly pick one of the images. The  randint(1,5)  line simply picks a number between 1 and 5 at random. The image will initially render at roughly sized at one half a grid cell. The image will slowly pulse with a four second interval. Note that the image will  destruct  between 0.1 and 4 seconds, so this basically means the firework will expand and never contract.  With the explosion defined, we'll now want to go back and reset the yellow sprite callback to use our new  explode  function:          s.speed(15).move_to(p, callback=partial(explode, s))  Here's the completed version (without comments):  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Fireworks!'\n\nBACKGROUND = (0,0,0)\n\ndef explode(s):\n        s.destroy()\n        num = randint(1, 5)\n        img = image('fireworks-'+str(num), s.pos, size=0.5)\n        img.pulse(time=4, size=10).destruct(rand(0.1,4))\n\ndef launch():\n        sound('fireworks')\n        p = rand_pos(x_padding=5, y_padding=10)\n        s = shape(CIRCLE, YELLOW, (p[0], WIDTH-5), size=0.1)\n        s.speed(15).move_to(p, callback=partial(explode, s))\n        callback(launch, rand(0, 3))\n\ncallback(launch, 1)  Save your changes and enjoy the show!  pred game.py",
            "title": "Getting Started"
        },
        {
            "location": "/examples/pictureframe/",
            "text": "Picture Frame\n\n\nThis example creates a digital picture frame using images from \npicsum.photos\n - you'll definitely need an Internet connection to run this game! The code demonstrates some of the key abstraction features that have been implemented in the Predigame platform.\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nDownload Existing Game (Optional)\n\n\nWe have a version of this game already done and ready to go. Just run the following command:\n\n\npred new pictureframe\n\n\n\n\nThen read the rest of the tutorial and follow along.\n\n\nGetting Started\n\n\nTo get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:\n\n\npred new pictureframe\n\n\n\n\nNow in the text editor, find and open the file \npictureframe/game.py\n. This file is used to create a basic Predigame canvas that we'll use to place our fireworks. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title.\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Fireworks'\n\n\n\n\nFor this example, we'll want to enable fullscreen mode:\n\n\nFULLSCREEN=True\n\n\n\n\nNext we'll add the background function call. In Predigame we always try to provide defaults for functions. The \nbackground()\n function can be used for loading static images (provided they are in your \nbackgrounds/\n directory) or static colors (defined as a constant or (RED, GREEN, BLUE) values). If no argument is provided to \nbackground()\n, we fetch an image from \npicsum.photos\n.\n\n\nAdd this line to your file:\n\n\nbackground()\n\n\n\n\nNow let's give it a test run!\n\n\npred game.py\n\n\n\n\nYou'll notice that the game is loaded in full screen, but the picture is static. To fix this up, let's add a timer callback.\n\n\nbackground()\ncallback(background, 10, repeat=FOREVER)\n\n\n\n\nThe code calls \nbackground()\n by itself to seed the display with the first image. The second and beyond image will be loaded by the \ncallback()\n function with a \n10\n second delay.\n\n\nHere's the completed version:\n\n\nWIDTH=30\nHEIGHT=20\nFULLSCREEN=True\n\nbackground()\ncallback(background, 10, repeat=FOREVER)\n\n\n\n\nSave your changes and enjoy the pics!\n\n\npred game.py\n\n\n\n\nCHALLENGE - Add the time!\n\n\nOne of the neat things about Predigame is that you can always drop in python code to help complete a game. The following example is an extension to the previous example, but now  adds the time. We had to refactor things a bit, but the code has a similar operation.\n\n\nWIDTH=30\nHEIGHT=20\nFULLSCREEN=True\n\nfrom time import localtime, strftime\nclock = None\ndef update():\n   global clock\n   if clock:\n      clock.destroy()\n   background()\n   clock = text(strftime(\"%H:%M\", localtime()), color=WHITE, pos=(25, 18), size=2)\nupdate()\ncallback(update, 10, repeat=FOREVER)",
            "title": "Picture Frame"
        },
        {
            "location": "/examples/pictureframe/#picture-frame",
            "text": "This example creates a digital picture frame using images from  picsum.photos  - you'll definitely need an Internet connection to run this game! The code demonstrates some of the key abstraction features that have been implemented in the Predigame platform.",
            "title": "Picture Frame"
        },
        {
            "location": "/examples/pictureframe/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/pictureframe/#download-existing-game-optional",
            "text": "We have a version of this game already done and ready to go. Just run the following command:  pred new pictureframe  Then read the rest of the tutorial and follow along.",
            "title": "Download Existing Game (Optional)"
        },
        {
            "location": "/examples/pictureframe/#getting-started",
            "text": "To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:  pred new pictureframe  Now in the text editor, find and open the file  pictureframe/game.py . This file is used to create a basic Predigame canvas that we'll use to place our fireworks. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title.  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Fireworks'  For this example, we'll want to enable fullscreen mode:  FULLSCREEN=True  Next we'll add the background function call. In Predigame we always try to provide defaults for functions. The  background()  function can be used for loading static images (provided they are in your  backgrounds/  directory) or static colors (defined as a constant or (RED, GREEN, BLUE) values). If no argument is provided to  background() , we fetch an image from  picsum.photos .  Add this line to your file:  background()  Now let's give it a test run!  pred game.py  You'll notice that the game is loaded in full screen, but the picture is static. To fix this up, let's add a timer callback.  background()\ncallback(background, 10, repeat=FOREVER)  The code calls  background()  by itself to seed the display with the first image. The second and beyond image will be loaded by the  callback()  function with a  10  second delay.  Here's the completed version:  WIDTH=30\nHEIGHT=20\nFULLSCREEN=True\n\nbackground()\ncallback(background, 10, repeat=FOREVER)  Save your changes and enjoy the pics!  pred game.py",
            "title": "Getting Started"
        },
        {
            "location": "/examples/pictureframe/#challenge-add-the-time",
            "text": "One of the neat things about Predigame is that you can always drop in python code to help complete a game. The following example is an extension to the previous example, but now  adds the time. We had to refactor things a bit, but the code has a similar operation.  WIDTH=30\nHEIGHT=20\nFULLSCREEN=True\n\nfrom time import localtime, strftime\nclock = None\ndef update():\n   global clock\n   if clock:\n      clock.destroy()\n   background()\n   clock = text(strftime(\"%H:%M\", localtime()), color=WHITE, pos=(25, 18), size=2)\nupdate()\ncallback(update, 10, repeat=FOREVER)",
            "title": "CHALLENGE - Add the time!"
        },
        {
            "location": "/examples/bacon/",
            "text": "Making Bacon\n\n\nA simple maze game that demonstrates some cool things we can do with actors. Create a new file named \nbacon.py\n and start with our standard first three lines of code:\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nDownload Existing Game (Optional)\n\n\nWe have a version of this game already done and ready to go. Just run the following command:\n\n\npred pull bacon\n\n\n\n\nThen read the rest of the tutorial and follow along.\n\n\nGetting Started\n\n\nTo get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:\n\n\npred new bacon\n\n\n\n\nNow in the text editor, find and open the file \nbacon/game.py\n. Fix up your code so it looks like the example below:\n\n\nWIDTH = 30\nHEIGHT = 18\nTITLE = 'Making Bacon'\n\n\n\n\nLike before, these lines doesn't do much just yet. Here's a line to add a simple \nbackground\n (\nremember backgrounds are retrieved from the backgrounds/ directory\n)\n\n\n# use a grass background\nBACKGROUND = 'grass'\n\n\n\n\nNext we'll define a constant for the number of piggies to create. This line of code will not have any impact just yet.\n\n\n# how many piggies to create\nPIGGIES = 10\n\n\n\n\nNow let's create a maze with stone images. Remember that we must have a \nstone\n in image in our images directory.\n\n\nmaze(callback=partial(image, 'stone'))\n\n\n\n\nCHECKPOINT\n - try saving and running your code at this point. You should see something like the below picture.\n\n\n\n\nAlternatively, it's also possible to create a maze with just black rectangles instead of stone images.\n\n\nmaze(callback=partial(shape, RECT, BLACK))\n\n\n\n\nIf all looks good with the maze, let's add our player actor. We're going for \nSoldier-2\n. The actor will be assigned to move on keyboard arrows and every keyboard movement will call the \nevaluate\n callback. This is code that we can use to \"evaluate\" each move to make sure the player can't walk through walls.\n\n\n# a callback that keeps the player from running\n# into walls.\ndef evaluate(action, sprite, pos):\n    obj = at(pos)\n    if obj and obj.tag == 'wall':\n        return False\n    else:\n        return True\n\n# create a soldier on the bottom left grid cell\nplayer = actor('Soldier-2', (0, HEIGHT-1), tag='player', abortable=True)\n\n# have the solider attach to the keyboard arrows\n# each move is \"evaluated\" to make sure the player\n# doesn't walk through the wall\nplayer.keys(precondition=evaluate)\n\n# player moves at a speed of 5 with an animation rate of 2\n# which flips the sprite image every other frame\nplayer.speed(5).rate(2).move_to((0, HEIGHT-1))\n\n\n\n\nLet's give this a shot. Try running the code to ensure that the player can navigate the maze maze without being able to walk through walls.\n\n\nThe Predigame platform includes an abstraction for respecting maze walls, so defining an \nevaluate\n function isn't necessary. Instead you an have the line:\n\n\n# have the solider attach to the keyboard arrows\n# each move is \"evaluated\" to make sure the player\n# doesn't walk through the wall\nplayer.keys(precondition=player_physics)\n\n\n\n\nIf this works, try adding some piggies. Here is one case where the \nPIGGIES\n constant will be used.\n\n\n# create a piggy function\ndef create_piggy(num):\n    for x in range(num):\n        pos = rand_pos()\n        piggy = actor('Porter', pos, tag='piggy')\n        piggy.move_to((pos))\n        # graze is a random walk\n        piggy.wander(partial(graze, piggy), time=0.75)\n\n# create some piggies\ncreate_piggy(PIGGIES)\n\n\n\n\nPorter\n is an animated actor. There is a special callback function \nwander\n that allows the computer to control the movement of an actor. The \nwander\n is called for every movement, in the case of our piggy, calls the Predigame internal \ngraze\n callback function which is a random and undirected movement.  \n\n\nTry running saving these updates and running the game. We'll see the maze, our player, and now some piggies! It's possible to speed up the piggies by adjusting the \ntime\n attribute for the random walk.\n\n\n\n\nThe final part of our game is shooting! We'll create a \nshoot\n callback that is assigned to the space bar. It looks a little like an air shot, but the piggy effects are pretty cool.\n\n\n# shoot a weapon\ndef shoot():\n    player.act(SHOOT, loop=1)\n\n    #find the next object that is facing the player\n    target = player.next_object()\n\n    # if it's a piggy and that piggy is alive\n    if target and target.tag == 'piggy' and target.health > 0:\n        # kill the piggy and make it disappear in 3 seconds\n        target.kill(delay=3)\n        # tally the kill\n        score(1)\n\n    # check to see if there are any piggys left\n    if len(get('piggy')) == 0:\n        text('Time for some BACON!! (%s secs)' % time(), color=BLACK)\n        gameover()\n\n# register space to shoot\nkeydown('space', shoot)\n\n#we're keeping score\nscore()\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)\n\n\n\n\nNotice we use the \nPIGGIES\n constant a second time? That's why we made it a constant. Our game needs to track all the piggies and will stop playing when \nPIGGIES\n piggies have been killed. \nNOTE: this code will not work if more points are assigned for each dead piggy!",
            "title": "Making Bacon"
        },
        {
            "location": "/examples/bacon/#making-bacon",
            "text": "A simple maze game that demonstrates some cool things we can do with actors. Create a new file named  bacon.py  and start with our standard first three lines of code:",
            "title": "Making Bacon"
        },
        {
            "location": "/examples/bacon/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/bacon/#download-existing-game-optional",
            "text": "We have a version of this game already done and ready to go. Just run the following command:  pred pull bacon  Then read the rest of the tutorial and follow along.",
            "title": "Download Existing Game (Optional)"
        },
        {
            "location": "/examples/bacon/#getting-started",
            "text": "To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:  pred new bacon  Now in the text editor, find and open the file  bacon/game.py . Fix up your code so it looks like the example below:  WIDTH = 30\nHEIGHT = 18\nTITLE = 'Making Bacon'  Like before, these lines doesn't do much just yet. Here's a line to add a simple  background  ( remember backgrounds are retrieved from the backgrounds/ directory )  # use a grass background\nBACKGROUND = 'grass'  Next we'll define a constant for the number of piggies to create. This line of code will not have any impact just yet.  # how many piggies to create\nPIGGIES = 10  Now let's create a maze with stone images. Remember that we must have a  stone  in image in our images directory.  maze(callback=partial(image, 'stone'))  CHECKPOINT  - try saving and running your code at this point. You should see something like the below picture.   Alternatively, it's also possible to create a maze with just black rectangles instead of stone images.  maze(callback=partial(shape, RECT, BLACK))  If all looks good with the maze, let's add our player actor. We're going for  Soldier-2 . The actor will be assigned to move on keyboard arrows and every keyboard movement will call the  evaluate  callback. This is code that we can use to \"evaluate\" each move to make sure the player can't walk through walls.  # a callback that keeps the player from running\n# into walls.\ndef evaluate(action, sprite, pos):\n    obj = at(pos)\n    if obj and obj.tag == 'wall':\n        return False\n    else:\n        return True\n\n# create a soldier on the bottom left grid cell\nplayer = actor('Soldier-2', (0, HEIGHT-1), tag='player', abortable=True)\n\n# have the solider attach to the keyboard arrows\n# each move is \"evaluated\" to make sure the player\n# doesn't walk through the wall\nplayer.keys(precondition=evaluate)\n\n# player moves at a speed of 5 with an animation rate of 2\n# which flips the sprite image every other frame\nplayer.speed(5).rate(2).move_to((0, HEIGHT-1))  Let's give this a shot. Try running the code to ensure that the player can navigate the maze maze without being able to walk through walls.  The Predigame platform includes an abstraction for respecting maze walls, so defining an  evaluate  function isn't necessary. Instead you an have the line:  # have the solider attach to the keyboard arrows\n# each move is \"evaluated\" to make sure the player\n# doesn't walk through the wall\nplayer.keys(precondition=player_physics)  If this works, try adding some piggies. Here is one case where the  PIGGIES  constant will be used.  # create a piggy function\ndef create_piggy(num):\n    for x in range(num):\n        pos = rand_pos()\n        piggy = actor('Porter', pos, tag='piggy')\n        piggy.move_to((pos))\n        # graze is a random walk\n        piggy.wander(partial(graze, piggy), time=0.75)\n\n# create some piggies\ncreate_piggy(PIGGIES)  Porter  is an animated actor. There is a special callback function  wander  that allows the computer to control the movement of an actor. The  wander  is called for every movement, in the case of our piggy, calls the Predigame internal  graze  callback function which is a random and undirected movement.    Try running saving these updates and running the game. We'll see the maze, our player, and now some piggies! It's possible to speed up the piggies by adjusting the  time  attribute for the random walk.   The final part of our game is shooting! We'll create a  shoot  callback that is assigned to the space bar. It looks a little like an air shot, but the piggy effects are pretty cool.  # shoot a weapon\ndef shoot():\n    player.act(SHOOT, loop=1)\n\n    #find the next object that is facing the player\n    target = player.next_object()\n\n    # if it's a piggy and that piggy is alive\n    if target and target.tag == 'piggy' and target.health > 0:\n        # kill the piggy and make it disappear in 3 seconds\n        target.kill(delay=3)\n        # tally the kill\n        score(1)\n\n    # check to see if there are any piggys left\n    if len(get('piggy')) == 0:\n        text('Time for some BACON!! (%s secs)' % time(), color=BLACK)\n        gameover()\n\n# register space to shoot\nkeydown('space', shoot)\n\n#we're keeping score\nscore()\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)  Notice we use the  PIGGIES  constant a second time? That's why we made it a constant. Our game needs to track all the piggies and will stop playing when  PIGGIES  piggies have been killed.  NOTE: this code will not work if more points are assigned for each dead piggy!",
            "title": "Getting Started"
        },
        {
            "location": "/examples/clickninja/",
            "text": "The Click Ninja\n\n\nClick Ninja was inspired by the app \nfruit ninja\n, but a little different since we have a mouse. As coders, we write the code and control how the game operates.\n\n\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal:\n\n\npred pull clickninja\n\n\n\n\nThen change into the \nclickninja\n directory.\n\n\ncd clickninja\n\n\n\n\nInstructional Coverage\n\n\nWe're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform.\n\n\nPredigame Concepts Covered:\n\n\n\n\nCallbacks (timing and mouse)\n\n\nLevels\n\n\nImage Sprite Effects\n\n\nSound Effects\n\n\n\n\nThe game consists of three python (only one is needed to run the game):\n\n\n\n\nclickninja.py\n  - You'll create this file as part of this tutorial.\n\n\nclickninja-final.py\n - A \"camera ready\" version of the game.\n\n\nclickninja-levels.py\n - An extension of \nclickninja-final.py\n but with level support.\n\n\n\n\nRunning the Game\n\n\nWe recommend running all predigames from the command prompt/console/terminal. Be sure to  \ncd\n  into your game directory run:\n\n\nmy_machine$ pred clickninja.py\n\n\n\n\nIf you want to give one of the complete versions a spin, run one of these commands:\n\n\nmy_machine$ pred clickninja-final.py\nmy_machine$ pred clickninja-levels.py\n\n\n\n\nBasic Game\n\n\nThe fundamentals for click ninja are pretty basic. Open a text editor and copy in the follow code. This will create a window of 20x14 blocks and a title of 'Click Ninja'\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\n\n\n\nSave your changes. Let's call the file \nclickninja.py\n.  Try running the game from the terminal using the \npred\n command (you'll want to run this command from the directory where you saved the file).\n\n\npred clickninja.py\n\n\n\n\nThis game doesn't do much just yet. Just an empty window titled \"Click Ninja\". So boring. Let's add some more code. We added a bunch of comments to describe the purpose of each line.\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\n# the \"main\" part of our game\ndef spawn():\n\n    # pick a random color\n    target = choice([BLACK, ORANGE, AQUA, NAVY])\n\n    # a virual \"arc\" -- three positions where\n    # the object will move\n    # arc[0]  bottom/off screen\n    # arc[1] top of the arc\n    # arc[2] bottom/off screen\n    arc = rand_arc()\n\n    # draw our sprite\n    s = shape(CIRCLE, target, arc[0])\n\n    # move to second and third points of arc\n    # destroy if not hit\n    s.move_to(arc[1], arc[2], callback = s.destroy)\n\n    #tell this code to run again -- sometime between 100ms to 3secs\n    callback(spawn, rand(0.1, 3))\n\n# keep score (top left)\nscore(color = PURPLE)\n\n# start the game in 1 second\ncallback(spawn, 1)\n\n# register the 'r' key to reset the game\nkeydown('r', reset)  \n\n\n\n\nLet's try our game now. We'll start to see a little more action. It looks a little like juggling, but we can't click on any of the circles. Notice that the last line of code will cause our game to reset if the 'r' key is pressed - this will be important a few steps later.\n\n\nCallback Functions\n\n\nWhen we code a game we sometimes need to create actions that will \neventually occur\n. Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game.\n\n\nThe Python program language requires that we specify our \nfunctions\n before registering them in the code. Let's look at a simple callback example.\n\n\ndef destroy(s):\n    s.destroy()\n\n\n\n\nThis function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered.\n\n\ns = shape(CIRCLE, target, arc[0]).clicked(destroy)\n\n\n\n\nThat's right.. We can basically add a \n.clicked(destroy)\n to the end of our shape definition and \nregister\n a callback function that won't get called until the player clicks on the circle.\n\n\nHere's the full code now (we took out all the comments to make it a little easier to read). Let's give it a quick test.\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    s.destroy()\n\ndef spawn():\n    target = choice([BLACK, ORANGE, AQUA, NAVY])\n\n    arc = rand_arc()\n\n    s = shape(CIRCLE, target, arc[0]).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = s.destroy)\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)    \n\n\n\n\nKeeping Score\n\n\nWe can modify our destroy callback function to \nscore\n the number of things we destroy. It's just requires adding a line of code.\n\n\ndef destroy(s):\n    # vvvv - add the line below - vvvv\n    score(1)\n    # ^^^^ - add the line above - ^^^^    \n    s.destroy()\n\n\n\n\n\n\nVersion 1: Keep Alive\n\n\nAt this point we almost have a fully functional game. We just need to add a keep alive function. That is, we want to make sure we stop the game if we don't click on a circle. Look for this line of code in our game:\n\n\n    s.move_to(arc[1], arc[2], callback= s.destroy)\n\n\n\n\nThe way this code is written, the callback function \ns.destroy\n will be called if nothing else happens to the shape. Let's create a new callback function \nfailure(s)\n that will pause the game. Notice we'll use something called a lambda. We'll be sure to discuss what that means at a later point.\n\n\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n\n\n\nLet's make sure we create the failure function. We'll put that right under our \ndestroy\n callback function.\n\n\ndef failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    callback(gameover, 0.01)\n\n\n\n\nThat's it! Here's the complete code if you need it. Go ahead and enjoy Version 1. How many circles can you click?\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(1)\n    s.destroy()\n\ndef failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    gameover()\n\ndef spawn():\n    target = choice([BLACK, ORANGE, AQUA, NAVY])\n\n    arc = rand_arc()\n\n    s = shape(CIRCLE, target, arc[0]).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)   \n\n\n\n\nVersion 2: Throwing Food\n\n\nLet's swap out circles for pictures of food. The predigame platform makes it easy to load pictures in your game. Just copy them to an \nimages\n subdirectory. The click ninja includes a few food images to get started. Let's see what we have.\n\n\nmy_machine$ ls images\nbananas.png  cherries.png ham.png      icee.png     pizza.png    taco.png\nbomb.png     fries.png    hotdog.png   olives.png   redsplat.png\n\n\n\nLet's say we want to load the hotdog image. We can do that with a single line of code.\n\n\nimage('hotdog', (x, y), size=size)\n\n\n\n\nWe'll see that to load the image we need the first part of the file, the initial x and y coordinates, and the size (default is \n1.0\n). Notice that we don't need to include the \nimages\n directory or the \n.png\n file extension. Predigame takes care of that for us.\n\n\nSo, now let's replace the circles with images. To do that we're going to rewrite our \nspawn()\n function.\n\n\ndef spawn():\n\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    s.speed(speed).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\n\n\n\nIn addition to drawing images, notice that we also have variables for \nspeed\n and \nsize\n. As our code runs anytime we'll draw a \nrandom\n target with a \nrandom\n speed and \nrandom\n size.  Notice the \nrandint\n functions, such as \nrandint(2, 10)\n. This will randomly pick a number between 2 and 10.\n\n\nLet's try running our code. Here's the complete version.\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(1)\n    s.destroy()\n\ndef failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    callback(gameover, 0.01)\n\ndef spawn():\n\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    s.speed(speed).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)   \n\n\n\n\nVersion 3: Bombs Away\n\n\nInstead of just drawing food, let's throw some bombs too! Unlike food, our players can't click on a bomb or else.. well, game over! For starters, let's assume there is a 25% (1 out of 4) chance a bomb will be thrown. In code we'll want to add two lines in our \nspawn()\n function.\n\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n    # vvv - add this code - vvv\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    # ^^^ - add this code - ^^^\n\n\n\n\nThe two lines we just added will replace the \ntarget\n variable with bomb with a 25% probability. Now, we said the player can't click on a bomb (game over otherwise) and, unlike food, if they don't click, we don't want to stop the game (because not clicking the bomb is what we want). This means we'll need to change the following lines:\n\n\n    # old code\n    s = image(target, arc[0], size=size)\n    s.speed(speed).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n\n\n\nAnd check to see if target is a bomb.\n\n\n    # new code\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n\n\n\n\nLet's try running our code. Here's the complete version.\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(1)\n    s.destroy()\n\ndef failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    callback(gameover, 0.01)\n\ndef spawn():\n\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)   \n\n\n\n\nVersion 4: Better Score\n\n\nOur game ends quickly when we make a single mistake and that can make for a frustrating experience for even the best player. Let's improve our scoring with a few basic rules:\n\n\n\n\nReward the player \nfive points\n for clicking food\n\n\nPenalize the player  \ntwenty points\n for missing a food item\n\n\nHalt the game when the number of points falls below zero\n\n\nHalt the game if the player clicks on a bomb\n\n\n\n\nHere's our improved \ndestroy\n and \nfailure\n functions. Change your functions so they look like these:\n\n\ndef destroy(s):\n    score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        text('You Survived %s seconds' % time(), MAROON)\n        gameover()\n\n\n\n\nNotice that in \nfailure\n we added the line \nif s.name == 'bomb' or score() < 0:\n? Since our failure function is called if we don't click on a food or if we click on a bomb, we need to make sure that we end the game \nimmediately\n if the player clicks on the bomb. It's a simple adjustment that will allow our code to be general enough for multiple cases.\n\n\nLet's try running our code. Here's the complete version.\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        text('You Survived %s seconds' % time(), MAROON)\n        callback(gameover, 0.01)\n\ndef spawn():\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)   \n\n\n\n\nVersion 5: The Bonus Taco\n\n\nJust like a bomb, we can add a bonus taco that flies across the screen. We don't want to award our player too much, so we'll give the taco a 10% (1 out of 10) probability of showing on the screen. Here's what we'll need to change:\n\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'\n\n\n\n\nAnd if we pick a taco for a target, we'll need to change how the taco moves as we want it to fly across - not in an arc formation.\n\n\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    elif target == 'taco':\n       s.speed(5).clicked(destroy)\n       s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n\n\n\nNow when a user clicks on a taco, we want to reward some bonus points, so we'll need to tweak the \ndestroy\n function.\n\n\ndef destroy(s):\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    s.destroy()\n\n\n\n\nLet's try running our code. Here's the complete version.\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        text('You Survived %s seconds' % time(), MAROON)\n        callback(gameover, 0.01)\n\ndef spawn():\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    elif target == 'taco':\n       s.speed(5).clicked(destroy)\n       s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)   \n\n\n\n\nOther Fun Things\n\n\nSpinning Sprites\n\n\nWe can code any image object to spin...\n\n\ns.speed(speed).spin().clicked(failure)\n\n\n\n\nAnd the \nspin\n function can be given a number to control the rate\n\n\n# fast spinning\ns.speed(speed).spin(0.1).clicked(failure)\n\n# or\n\n# slow spinning\ns.speed(speed).spin(2.0).clicked(failure)\n\n\n\n\n\n\nBackground Wallpaper\n\n\nA white background can get a little boring. Try adding this line to the top of your code:\n\n\nTITLE = 'Click Ninja'\n\n# load 'background/board.jpg' as the wallpaper\nBACKGROUND = 'board'\n\n\n\n\nBACKGROUND\n files are stored in the \nbackground\n directory.\n\n\nSound Effects\n\n\nJust like images, predigame supports sound effects. We've preloaded a few for the game. For instance, you can add a launching sound to the \nspawn()\n function:\n\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'\n\n    sound('launch')\n\n\n\n\nYou can add effects to when a user clicks on a food item or even looses.\n\n\ndef destroy(s):\n    sound('swoosh')\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        sound('scream')\n        text('You Survived %s seconds' % time(), MAROON)\n        gameover()\n\n\n\n\nEffects\n\n\nWhile it's cool to click away on our food. We can also introduce a fading effect that makes it slowly dissolve on contact. To do this, simply change the last line in the \ndestroy\n function.\n\n\ndef destroy(s):\n    sound('swoosh')\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    # s.destroy()\n    # have the sprite fade out in 750 ms\n    s.fade(0.75)\n\n\n\n\nRed Splat on Contact\n\n\nAnother fun thing is to leave a splat mark behind for each food item the player strikes. To do this, it's a simple extension to the \ndestroy\n callback function.\n\n\ndef destroy(s):\n    sound('swoosh')\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n\n    # draw a splatting image at the position of the strike\n    # make it fade away after 10 seconds\n    image('redsplat', s.event_pos, 2).fade(1.0)\n\n    s.destroy()\n\n\n\n\nHere the \ns\n variable (which is short for sprite) has a position. So we want to draw the red splat image at the location of the strike.\n\n\nExploding Bombs\n\n\nAccidents happen! If the player accidentally clicks on a bomb, we should have them explode. It's a simple modification to the \nfailure\n function.\n\n\ndef failure(s):\n    score(-20)\n    # make the bomb explode\n    if s.name == 'bomb':\n        s.destroy()\n        image('explode', s.center, 10).pulse(0.05)\n\n    if s.name == 'bomb' or score() < 0:\n        sound('scream')\n        text('You Survived %s seconds' % time(), MAROON)\n        callback(gameover, 0.01)\n\n\n\n\nThe key to the explosion is the \n.pulse(0.05)\n function call. The game will quickly pause, but the pulse is fast enough to provide an explosion effect.\n\n\nLevels!\n\n\nClick Ninja is 1000x better when you add levels! We won't get into the coding specifics for levels here - that'll be covered in other \nPredigame\n examples, but here is a leveled version of the code, with plenty of inline comments:\n\n\nWIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja (Leveled Edition)'\n\n# handle to current level (used by generic functions)\ncurrent_level = None\n\ndef destroy(s):\n    sound('swoosh')\n    current_level.hit()\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n\n    # draw a splatting image at the center position of the image\n    image('redsplat', center=s.event_pos, size=2).fade(1.0)\n\n    # add a fade out effect\n    s.fade(0.25)\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb':\n        s.destroy()\n        image('explode', center=s.center, size=10).pulse(0.05)\n\n    if s.name == 'bomb' or score() < 0:\n        sound('scream')\n        text('You Survived %s seconds' % current_level.get_duration(), MAROON)\n        callback(gameover, 0.01)\n\ndef spawn(min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=1, max_rate=1):\n    \"\"\" leveled version includes min/max parameters \"\"\"\n    size = rand(min_size, max_size)\n    speed = rand(min_speed,max_speed)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'\n\n    sound('launch')\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).spin(1).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    elif target == 'taco':\n       s.speed(5).spin().clicked(destroy)\n       s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)\n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(partial(spawn, min_speed=min_speed, max_speed=max_speed,\n                     min_rate=min_rate, max_rate=max_rate,\n                     min_size=min_size, max_size=max_size), rand(min_rate, max_rate))\n\nclass NinjaLevel(Level):\n    \"\"\" defines the behavior of a single level \"\"\"\n    def __init__(self, level=1, total_hits=0, duration=0, min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=3, max_rate=3):\n        self.level = level\n\n        self.min_size = min_size\n        # prevent sizes from getting too small\n        if self.min_size < 0.1:\n            self.min_size = 0.1\n\n        self.min_speed = min_speed\n        # prevent speed from getting too small\n        if self.min_speed < 0.1:\n            self.min_speed = 0.1\n\n        self.min_rate = min_rate\n        # prevent launch rates from getting too small\n        if self.min_rate < 0:\n            self.min_rate = 0\n\n        self.max_size = max_size\n        self.max_speed = max_speed\n        self.max_rate = max_rate\n        self.hits = 0\n        self.total_hits = total_hits\n        self.duration = duration\n\n    def hit(self):\n        self.hits += 1\n        self.total_hits += 1\n        score(self.total_hits, pos=LOWER_LEFT)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n        global current_level\n        current_level = self\n\n        # BACKGROUND (randomly selected)\n        background()\n\n        # SCORE BOARD\n        score(0, prefix='Score: ')\n        score(self.total_hits, pos=LOWER_LEFT, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n        score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ')\n\n        # START LEVEL\n        callback(partial(spawn, min_speed=self.min_speed, max_speed=self.max_speed,\n                         min_rate=self.min_rate, max_rate=self.max_rate,\n                         min_size=self.min_size, max_size=self.max_size), 1)\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" 10 hits are required to complete a level \"\"\"\n        if self.hits == 10:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" load the next level \"\"\"\n        return NinjaLevel(level=self.level+1, total_hits=self.total_hits,\n                          duration=score(pos=LOWER_RIGHT),\n                          min_speed=self.min_speed-0.1, max_speed=self.max_speed+0.5,\n                          min_rate=self.min_rate-0.5, max_rate=self.max_rate-0.1,\n                          min_size=self.min_size-0.5, max_size=self.max_size)\n\nlevel(NinjaLevel(1))",
            "title": "Click Ninja"
        },
        {
            "location": "/examples/clickninja/#the-click-ninja",
            "text": "Click Ninja was inspired by the app  fruit ninja , but a little different since we have a mouse. As coders, we write the code and control how the game operates.",
            "title": "The Click Ninja"
        },
        {
            "location": "/examples/clickninja/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/clickninja/#getting-started",
            "text": "To get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal:  pred pull clickninja  Then change into the  clickninja  directory.  cd clickninja",
            "title": "Getting Started"
        },
        {
            "location": "/examples/clickninja/#instructional-coverage",
            "text": "We're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform.  Predigame Concepts Covered:   Callbacks (timing and mouse)  Levels  Image Sprite Effects  Sound Effects   The game consists of three python (only one is needed to run the game):   clickninja.py   - You'll create this file as part of this tutorial.  clickninja-final.py  - A \"camera ready\" version of the game.  clickninja-levels.py  - An extension of  clickninja-final.py  but with level support.",
            "title": "Instructional Coverage"
        },
        {
            "location": "/examples/clickninja/#running-the-game",
            "text": "We recommend running all predigames from the command prompt/console/terminal. Be sure to   cd   into your game directory run:  my_machine$ pred clickninja.py  If you want to give one of the complete versions a spin, run one of these commands:  my_machine$ pred clickninja-final.py\nmy_machine$ pred clickninja-levels.py",
            "title": "Running the Game"
        },
        {
            "location": "/examples/clickninja/#basic-game",
            "text": "The fundamentals for click ninja are pretty basic. Open a text editor and copy in the follow code. This will create a window of 20x14 blocks and a title of 'Click Ninja'  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'  Save your changes. Let's call the file  clickninja.py .  Try running the game from the terminal using the  pred  command (you'll want to run this command from the directory where you saved the file).  pred clickninja.py  This game doesn't do much just yet. Just an empty window titled \"Click Ninja\". So boring. Let's add some more code. We added a bunch of comments to describe the purpose of each line.  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\n# the \"main\" part of our game\ndef spawn():\n\n    # pick a random color\n    target = choice([BLACK, ORANGE, AQUA, NAVY])\n\n    # a virual \"arc\" -- three positions where\n    # the object will move\n    # arc[0]  bottom/off screen\n    # arc[1] top of the arc\n    # arc[2] bottom/off screen\n    arc = rand_arc()\n\n    # draw our sprite\n    s = shape(CIRCLE, target, arc[0])\n\n    # move to second and third points of arc\n    # destroy if not hit\n    s.move_to(arc[1], arc[2], callback = s.destroy)\n\n    #tell this code to run again -- sometime between 100ms to 3secs\n    callback(spawn, rand(0.1, 3))\n\n# keep score (top left)\nscore(color = PURPLE)\n\n# start the game in 1 second\ncallback(spawn, 1)\n\n# register the 'r' key to reset the game\nkeydown('r', reset)    Let's try our game now. We'll start to see a little more action. It looks a little like juggling, but we can't click on any of the circles. Notice that the last line of code will cause our game to reset if the 'r' key is pressed - this will be important a few steps later.",
            "title": "Basic Game"
        },
        {
            "location": "/examples/clickninja/#callback-functions",
            "text": "When we code a game we sometimes need to create actions that will  eventually occur . Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game.  The Python program language requires that we specify our  functions  before registering them in the code. Let's look at a simple callback example.  def destroy(s):\n    s.destroy()  This function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered.  s = shape(CIRCLE, target, arc[0]).clicked(destroy)  That's right.. We can basically add a  .clicked(destroy)  to the end of our shape definition and  register  a callback function that won't get called until the player clicks on the circle.  Here's the full code now (we took out all the comments to make it a little easier to read). Let's give it a quick test.  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    s.destroy()\n\ndef spawn():\n    target = choice([BLACK, ORANGE, AQUA, NAVY])\n\n    arc = rand_arc()\n\n    s = shape(CIRCLE, target, arc[0]).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = s.destroy)\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)",
            "title": "Callback Functions"
        },
        {
            "location": "/examples/clickninja/#keeping-score",
            "text": "We can modify our destroy callback function to  score  the number of things we destroy. It's just requires adding a line of code.  def destroy(s):\n    # vvvv - add the line below - vvvv\n    score(1)\n    # ^^^^ - add the line above - ^^^^    \n    s.destroy()",
            "title": "Keeping Score"
        },
        {
            "location": "/examples/clickninja/#version-1-keep-alive",
            "text": "At this point we almost have a fully functional game. We just need to add a keep alive function. That is, we want to make sure we stop the game if we don't click on a circle. Look for this line of code in our game:      s.move_to(arc[1], arc[2], callback= s.destroy)  The way this code is written, the callback function  s.destroy  will be called if nothing else happens to the shape. Let's create a new callback function  failure(s)  that will pause the game. Notice we'll use something called a lambda. We'll be sure to discuss what that means at a later point.      s.move_to(arc[1], arc[2], callback = lambda: failure(s))  Let's make sure we create the failure function. We'll put that right under our  destroy  callback function.  def failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    callback(gameover, 0.01)  That's it! Here's the complete code if you need it. Go ahead and enjoy Version 1. How many circles can you click?  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(1)\n    s.destroy()\n\ndef failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    gameover()\n\ndef spawn():\n    target = choice([BLACK, ORANGE, AQUA, NAVY])\n\n    arc = rand_arc()\n\n    s = shape(CIRCLE, target, arc[0]).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)",
            "title": "Version 1: Keep Alive"
        },
        {
            "location": "/examples/clickninja/#version-2-throwing-food",
            "text": "Let's swap out circles for pictures of food. The predigame platform makes it easy to load pictures in your game. Just copy them to an  images  subdirectory. The click ninja includes a few food images to get started. Let's see what we have.  my_machine$ ls images\nbananas.png  cherries.png ham.png      icee.png     pizza.png    taco.png\nbomb.png     fries.png    hotdog.png   olives.png   redsplat.png  Let's say we want to load the hotdog image. We can do that with a single line of code.  image('hotdog', (x, y), size=size)  We'll see that to load the image we need the first part of the file, the initial x and y coordinates, and the size (default is  1.0 ). Notice that we don't need to include the  images  directory or the  .png  file extension. Predigame takes care of that for us.  So, now let's replace the circles with images. To do that we're going to rewrite our  spawn()  function.  def spawn():\n\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    s.speed(speed).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))  In addition to drawing images, notice that we also have variables for  speed  and  size . As our code runs anytime we'll draw a  random  target with a  random  speed and  random  size.  Notice the  randint  functions, such as  randint(2, 10) . This will randomly pick a number between 2 and 10.  Let's try running our code. Here's the complete version.  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(1)\n    s.destroy()\n\ndef failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    callback(gameover, 0.01)\n\ndef spawn():\n\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    s.speed(speed).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)",
            "title": "Version 2: Throwing Food"
        },
        {
            "location": "/examples/clickninja/#version-3-bombs-away",
            "text": "Instead of just drawing food, let's throw some bombs too! Unlike food, our players can't click on a bomb or else.. well, game over! For starters, let's assume there is a 25% (1 out of 4) chance a bomb will be thrown. In code we'll want to add two lines in our  spawn()  function.      target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n    # vvv - add this code - vvv\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    # ^^^ - add this code - ^^^  The two lines we just added will replace the  target  variable with bomb with a 25% probability. Now, we said the player can't click on a bomb (game over otherwise) and, unlike food, if they don't click, we don't want to stop the game (because not clicking the bomb is what we want). This means we'll need to change the following lines:      # old code\n    s = image(target, arc[0], size=size)\n    s.speed(speed).clicked(destroy)\n    s.move_to(arc[1], arc[2], callback = lambda: failure(s))  And check to see if target is a bomb.      # new code\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))  Let's try running our code. Here's the complete version.  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(1)\n    s.destroy()\n\ndef failure(s):\n    text('You Survived %s seconds' % time(), MAROON)\n    callback(gameover, 0.01)\n\ndef spawn():\n\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)",
            "title": "Version 3: Bombs Away"
        },
        {
            "location": "/examples/clickninja/#version-4-better-score",
            "text": "Our game ends quickly when we make a single mistake and that can make for a frustrating experience for even the best player. Let's improve our scoring with a few basic rules:   Reward the player  five points  for clicking food  Penalize the player   twenty points  for missing a food item  Halt the game when the number of points falls below zero  Halt the game if the player clicks on a bomb   Here's our improved  destroy  and  failure  functions. Change your functions so they look like these:  def destroy(s):\n    score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        text('You Survived %s seconds' % time(), MAROON)\n        gameover()  Notice that in  failure  we added the line  if s.name == 'bomb' or score() < 0: ? Since our failure function is called if we don't click on a food or if we click on a bomb, we need to make sure that we end the game  immediately  if the player clicks on the bomb. It's a simple adjustment that will allow our code to be general enough for multiple cases.  Let's try running our code. Here's the complete version.  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        text('You Survived %s seconds' % time(), MAROON)\n        callback(gameover, 0.01)\n\ndef spawn():\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)",
            "title": "Version 4: Better Score"
        },
        {
            "location": "/examples/clickninja/#version-5-the-bonus-taco",
            "text": "Just like a bomb, we can add a bonus taco that flies across the screen. We don't want to award our player too much, so we'll give the taco a 10% (1 out of 10) probability of showing on the screen. Here's what we'll need to change:      if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'  And if we pick a taco for a target, we'll need to change how the taco moves as we want it to fly across - not in an arc formation.      if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    elif target == 'taco':\n       s.speed(5).clicked(destroy)\n       s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))  Now when a user clicks on a taco, we want to reward some bonus points, so we'll need to tweak the  destroy  function.  def destroy(s):\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    s.destroy()  Let's try running our code. Here's the complete version.  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja'\n\ndef destroy(s):\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        text('You Survived %s seconds' % time(), MAROON)\n        callback(gameover, 0.01)\n\ndef spawn():\n    speed = randint(2, 10)\n    size = randint(1,4)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    elif target == 'taco':\n       s.speed(5).clicked(destroy)\n       s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)    \n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(spawn, rand(0.1, 3))\n\nscore(color = PURPLE)\ncallback(spawn, 1)\nkeydown('r', reset)",
            "title": "Version 5: The Bonus Taco"
        },
        {
            "location": "/examples/clickninja/#other-fun-things",
            "text": "",
            "title": "Other Fun Things"
        },
        {
            "location": "/examples/clickninja/#spinning-sprites",
            "text": "We can code any image object to spin...  s.speed(speed).spin().clicked(failure)  And the  spin  function can be given a number to control the rate  # fast spinning\ns.speed(speed).spin(0.1).clicked(failure)\n\n# or\n\n# slow spinning\ns.speed(speed).spin(2.0).clicked(failure)",
            "title": "Spinning Sprites"
        },
        {
            "location": "/examples/clickninja/#background-wallpaper",
            "text": "A white background can get a little boring. Try adding this line to the top of your code:  TITLE = 'Click Ninja'\n\n# load 'background/board.jpg' as the wallpaper\nBACKGROUND = 'board'  BACKGROUND  files are stored in the  background  directory.",
            "title": "Background Wallpaper"
        },
        {
            "location": "/examples/clickninja/#sound-effects",
            "text": "Just like images, predigame supports sound effects. We've preloaded a few for the game. For instance, you can add a launching sound to the  spawn()  function:      target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'\n\n    sound('launch')  You can add effects to when a user clicks on a food item or even looses.  def destroy(s):\n    sound('swoosh')\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    s.destroy()\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb' or score() < 0:\n        sound('scream')\n        text('You Survived %s seconds' % time(), MAROON)\n        gameover()",
            "title": "Sound Effects"
        },
        {
            "location": "/examples/clickninja/#effects",
            "text": "While it's cool to click away on our food. We can also introduce a fading effect that makes it slowly dissolve on contact. To do this, simply change the last line in the  destroy  function.  def destroy(s):\n    sound('swoosh')\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n    # s.destroy()\n    # have the sprite fade out in 750 ms\n    s.fade(0.75)",
            "title": "Effects"
        },
        {
            "location": "/examples/clickninja/#red-splat-on-contact",
            "text": "Another fun thing is to leave a splat mark behind for each food item the player strikes. To do this, it's a simple extension to the  destroy  callback function.  def destroy(s):\n    sound('swoosh')\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n\n    # draw a splatting image at the position of the strike\n    # make it fade away after 10 seconds\n    image('redsplat', s.event_pos, 2).fade(1.0)\n\n    s.destroy()  Here the  s  variable (which is short for sprite) has a position. So we want to draw the red splat image at the location of the strike.",
            "title": "Red Splat on Contact"
        },
        {
            "location": "/examples/clickninja/#exploding-bombs",
            "text": "Accidents happen! If the player accidentally clicks on a bomb, we should have them explode. It's a simple modification to the  failure  function.  def failure(s):\n    score(-20)\n    # make the bomb explode\n    if s.name == 'bomb':\n        s.destroy()\n        image('explode', s.center, 10).pulse(0.05)\n\n    if s.name == 'bomb' or score() < 0:\n        sound('scream')\n        text('You Survived %s seconds' % time(), MAROON)\n        callback(gameover, 0.01)  The key to the explosion is the  .pulse(0.05)  function call. The game will quickly pause, but the pulse is fast enough to provide an explosion effect.",
            "title": "Exploding Bombs"
        },
        {
            "location": "/examples/clickninja/#levels",
            "text": "Click Ninja is 1000x better when you add levels! We won't get into the coding specifics for levels here - that'll be covered in other  Predigame  examples, but here is a leveled version of the code, with plenty of inline comments:  WIDTH = 20\nHEIGHT = 14\nTITLE = 'Click Ninja (Leveled Edition)'\n\n# handle to current level (used by generic functions)\ncurrent_level = None\n\ndef destroy(s):\n    sound('swoosh')\n    current_level.hit()\n    if s.name == 'taco':\n       score(50)\n    else:\n       score(5)\n\n    # draw a splatting image at the center position of the image\n    image('redsplat', center=s.event_pos, size=2).fade(1.0)\n\n    # add a fade out effect\n    s.fade(0.25)\n\ndef failure(s):\n    score(-20)\n    if s.name == 'bomb':\n        s.destroy()\n        image('explode', center=s.center, size=10).pulse(0.05)\n\n    if s.name == 'bomb' or score() < 0:\n        sound('scream')\n        text('You Survived %s seconds' % current_level.get_duration(), MAROON)\n        callback(gameover, 0.01)\n\ndef spawn(min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=1, max_rate=1):\n    \"\"\" leveled version includes min/max parameters \"\"\"\n    size = rand(min_size, max_size)\n    speed = rand(min_speed,max_speed)\n\n    target = choice(['bananas', 'cherries',\n                     'olives', 'ham', 'hotdog',\n                     'fries','icee', 'pizza'])\n\n    if randint(1, 4) == 2:\n        target = 'bomb'\n    if randint(1, 10) == 5:\n        target = 'taco'\n\n    sound('launch')\n\n    arc = rand_arc()\n\n    s = image(target, arc[0], size=size)\n    if target == 'bomb':\n       s.speed(speed).spin(1).clicked(failure)\n       s.move_to(arc[1], arc[2], callback = s.destroy)\n    elif target == 'taco':\n       s.speed(5).spin().clicked(destroy)\n       s.move_to((-10, -2), (-5, HEIGHT/2), (WIDTH+1, HEIGHT/2), callback = s.destroy)\n    else:\n       s.speed(speed).clicked(destroy)\n       s.move_to(arc[1], arc[2], callback = lambda: failure(s))\n\n    callback(partial(spawn, min_speed=min_speed, max_speed=max_speed,\n                     min_rate=min_rate, max_rate=max_rate,\n                     min_size=min_size, max_size=max_size), rand(min_rate, max_rate))\n\nclass NinjaLevel(Level):\n    \"\"\" defines the behavior of a single level \"\"\"\n    def __init__(self, level=1, total_hits=0, duration=0, min_size=4, max_size=4, min_speed=1, max_speed=1, min_rate=3, max_rate=3):\n        self.level = level\n\n        self.min_size = min_size\n        # prevent sizes from getting too small\n        if self.min_size < 0.1:\n            self.min_size = 0.1\n\n        self.min_speed = min_speed\n        # prevent speed from getting too small\n        if self.min_speed < 0.1:\n            self.min_speed = 0.1\n\n        self.min_rate = min_rate\n        # prevent launch rates from getting too small\n        if self.min_rate < 0:\n            self.min_rate = 0\n\n        self.max_size = max_size\n        self.max_speed = max_speed\n        self.max_rate = max_rate\n        self.hits = 0\n        self.total_hits = total_hits\n        self.duration = duration\n\n    def hit(self):\n        self.hits += 1\n        self.total_hits += 1\n        score(self.total_hits, pos=LOWER_LEFT)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n        global current_level\n        current_level = self\n\n        # BACKGROUND (randomly selected)\n        background()\n\n        # SCORE BOARD\n        score(0, prefix='Score: ')\n        score(self.total_hits, pos=LOWER_LEFT, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n        score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ')\n\n        # START LEVEL\n        callback(partial(spawn, min_speed=self.min_speed, max_speed=self.max_speed,\n                         min_rate=self.min_rate, max_rate=self.max_rate,\n                         min_size=self.min_size, max_size=self.max_size), 1)\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" 10 hits are required to complete a level \"\"\"\n        if self.hits == 10:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" load the next level \"\"\"\n        return NinjaLevel(level=self.level+1, total_hits=self.total_hits,\n                          duration=score(pos=LOWER_RIGHT),\n                          min_speed=self.min_speed-0.1, max_speed=self.max_speed+0.5,\n                          min_rate=self.min_rate-0.5, max_rate=self.max_rate-0.1,\n                          min_size=self.min_size-0.5, max_size=self.max_size)\n\nlevel(NinjaLevel(1))",
            "title": "Levels!"
        },
        {
            "location": "/examples/thirsty/",
            "text": "Thirsty Zombie\n\n\nOur zombie likes sprite and hates code. This game throws soda can sprites at the zombie where the zombie must consume (destroy) them. If the zombie consumes a \"coke\" sprite, it will explode and end the game. If the zombie misses too many \"sprite\" sprites, it will die from dehydration.  The zombie is rewarded one point for every \"sprite\" consumed.\n\n\nGame Algorithm\n:\n\n\n\n\ncreate a game canvas with a width of 30 and height of 20 grid cells\n\n\nuse \ncallback(function, time)\n throw the cans\n\n\npick a random probability for throwing a \"coke\"\n\n\nreward the zombie \n1\n point for every sprite consumed\n\n\ndestroy the zombie, if\n\n\nthe zombie consumes a coke\n\n\nthe score falls below zero\n\n\n\n\n\n\nuse random speeds and callback times to throw more or less cans\n\n\nuse effects to make the game fun\n\n\nreset the game if the \nr\n key is pressed\n\n\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal:\n\n\npred pull thirsty\n\n\n\n\nThen change into the \nthirsty\n directory.\n\n\ncd thirsty\n\n\n\n\nNow in the text editor, find and open the file \nthirsty/game.py\n.\n\n\nGetting Started\n\n\nHere's the first few lines:\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Thirsty Zombie'\n\n# load in the stormy background\nBACKGROUND = 'stormy'\n\n\n\n\nThis will build a window of 30x20 grid cells and add a \"stormy\" background image. \nMake sure this image is saved in the \nbackgrounds/\n directory\n.\n\n\nZombie Creation\n\n\n# create a zombie sprite. flip the sprite so the zombie faces to the right\nzombie = image('zombie-2', (5, 15), size = 3).speed(10).flip()\n\n# tell the zombie to follow the mouse movement\nzombie.follow()\n\n\n\n\nWe use the \n.flip()\n function to have the zombie face towards right right side of the screen.\n\n\nHere's how to throw a sprite object:\n\n\ndef throw():\n    # pick a random position and select the y coordinate\n    y_pos = rand_pos()[1]\n\n    # create a soda and move it from right to left\n    target = 'sprite'\n    if randint(1, 5) == 4:\n        target = 'coke'     \n    s = image(target, (WIDTH+5, y_pos)).speed(2).collides(zombie, consume)\n    s.move_to((-1, y_pos), callback = lambda: miss(s))\n\n    # a callback to call the throw() function again\n    callback(throw, rand(0.5, 2))\n\n\n\n\nCallback Functions\n\n\nBefore we draw the code for a beverage, we need to define the logic that describes consumption. Remember, this is because python requires us to define our callback functions before we use them.\n\n\n# zombie consumes a drink and explodes if it's a coke\ndef consume(target, zombie):\n    # destroy the can\n    target.destroy()\n\n    if target.name == 'coke':\n        # zombies don't like coke. end the game\n        zombie.destroy()\n        image('kaboom', center=(15, 10), size=25)\n        gameover()\n    else:\n        # we added a sprite. increase score\n        score(1)\n\n\n\n\nIf we don't consume a beverage, the zombie will need to suffer a little bit. Our second callback describes the \"misses\":\n\n\n# zombie misses the opportunity to take a drink and is thirsty.\ndef miss(target):\n\n    # destroy the can\n    target.destroy()\n\n    # subtract a point if this was a sprite\n    if target.name == 'sprite':\n        score(-1)\n\n    # we lost\n    if score() < 0:\n        text(\"TOTAL DEHYDRATION\")\n        zombie.rotate(90).pulse(time=2, size=2)\n        gameover()\n\n\n\n\nThrowing Soda\n\n\nThrowing cans of soda is also a callback function, but controlled via time. A key to throwing is to mix up the positions a bit. The line of code \ny_pos = rand_pos()[1]\n is a shorthanded way of randomly picking a y (top/bottom) position. Read through the rest of the code below, we added some documentation to clarify each of the lines.\n\n\n# this is a callback that throws a sprite or coke across the screen\ndef throw_soda():\n\n    # pick a random position and select the y coordinate\n    y_pos = rand_pos()[1]\n\n    # create a soda and move it from right to left\n    target = 'sprite'\n\n    # roughly 50% of the cans are cokes\n    if randint(1, 2) == 2:\n        target = 'coke'     \n\n    # position the sprite off the right side of the screen\n    # make it move fast (speed 10)\n    # if the zombie hits the can, execute the \"consume\" callback\n    s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume)\n\n    # move the sprite to the left. execute callback \"miss\" if movement finishes\n    s.move_to((-1, y_pos), callback = lambda: miss(s))\n\n    # a callback to call the throw() function again\n    callback(throw_soda, rand(0, 1.5))\n\n# schedule the throw callback to run\ncallback(throw_soda, 1)\n\n\n\n\nFinal Bits\n\n\nThe final parts of the game enable score keeping and resetting the game if the 'r' key is pressed.\n\n\n# add this so we can keep score of the game\nscore(color=WHITE)\n\n# press the r key to reset\nkeydown('r', reset)\n\n\n\n\nComplete Code\n\n\nBelow is the complete code for \"thirsty zombie\".  We added an easter egg if the 'b' button is pressed - launch of soccer balls; it's an added obstacle that the zombie will need to avoid.\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Thirsty Zombie'\n\n# load in the stormy background\nBACKGROUND = 'stormy'\n\n# create a zombie sprite. flip the sprite so the zombie faces to the right\nzombie = image('zombie-2', (5, 15), size = 3).speed(10).flip()\n\n# tell the zombie to follow the mouse movement\nzombie.follow()\n\n# keep track if the zombie is spinning\nspinning = False\n\n# zombie consumes a drink and explodes if it's a coke\ndef consume(target, zombie):\n\n    # a spinning zombie cannot consume things\n    if spinning:\n        return\n\n    # destroy the can\n    target.destroy()\n\n    if target.name == 'coke':\n        # zombies don't like coke. end the game\n        zombie.destroy()\n        image('kaboom', center=(15, 10), size=25)\n        gameover()\n    else:\n        # we added a sprite. increase score\n        score(1)\n\n# zombie misses the opportunity to take a drink and is thirsty.\ndef miss(target):\n\n    # destroy the can\n    target.destroy()\n\n    # subtract a point if this was a sprite\n    if target.name == 'sprite':\n        score(-1)\n\n    # we lost\n    if score() < 0:\n        text(\"TOTAL DEHYDRATION\")\n        zombie.rotate(90).pulse(time=2, size=2)\n        gameover()\n\n# this is a callback that throws a sprite or coke across the screen\ndef throw_soda():\n\n    # pick a random position and select the y coordinate\n    y_pos = rand_pos()[1]\n\n    # create a soda and move it from right to left\n    target = 'sprite'\n\n    # roughly 50% of the cans are cokes\n    if randint(1, 2) == 2:\n        target = 'coke'     \n\n    # position the sprite off the right side of the screen\n    # make it move fast (speed 10)\n    # if the zombie hits the can, execute the \"consume\" callback\n    s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume)\n\n    # move the sprite to the left. execute callback \"miss\" if movement finishes\n    s.move_to((-1, y_pos), callback = lambda: miss(s))\n\n    # a callback to call the throw() function again\n    callback(throw_soda, rand(0, 1.5))\n\n# schedule the throw callback to run\ncallback(throw_soda, 1)\n\n# this is a callback when the zombie is done spinning\ndef done_spinning():\n\n    # the \"global\" variable is set to False (since we are done spinning)\n    global spinning\n    spinning = False\n\n# this is a callback when the zombie is hit by a ball\ndef spinner(b, z):\n\n    # the \"global\" variable is set to True (since we are spinning)\n    global spinning\n    spinning = True\n\n    # destroy the ball\n    b.destroy()\n\n    # spin the zombie.. time probably can't go much smaller than 0.5\n    # execute callback done_spinning after completing two rotations\n    z.spin(time=0.5, rotations=2, callback=done_spinning)\n\n# this is a callback function to launch the ball\ndef launch():\n\n    # create a ball and position off the right side of the screen\n    random_y_position = rand_pos()[1]\n\n    # position balls off the screen, make them spin and move a little fast\n    ball = image('ball', (WIDTH+5, random_y_position), size=2).spin(0.2).speed(5)\n\n    # move right to left, destroy if movement completes\n    ball.move_to((-5, random_y_position), callback=ball.destroy)\n\n    # make the zombie spin if hit by a ball\n    ball.collides(zombie, spinner)\n\n    # prepare to launch another\n    callback(launch, rand(0.2, 1))\n\n# hitting 'b' starts launching balls!\nkeydown('b', launch)\n\n# add this so we can keep score of the game\nscore(color=WHITE)\n\n# press the r key to reset\nkeydown('r', reset)\n\n\n\n\nSave this code as \ngame.py\n and let's give it a run!\n\n\npred game.py\n\n\n\n\nIf it loads correctly, the following game canvas should display. Have fun!!",
            "title": "Thirsty Zombie"
        },
        {
            "location": "/examples/thirsty/#thirsty-zombie",
            "text": "Our zombie likes sprite and hates code. This game throws soda can sprites at the zombie where the zombie must consume (destroy) them. If the zombie consumes a \"coke\" sprite, it will explode and end the game. If the zombie misses too many \"sprite\" sprites, it will die from dehydration.  The zombie is rewarded one point for every \"sprite\" consumed.  Game Algorithm :   create a game canvas with a width of 30 and height of 20 grid cells  use  callback(function, time)  throw the cans  pick a random probability for throwing a \"coke\"  reward the zombie  1  point for every sprite consumed  destroy the zombie, if  the zombie consumes a coke  the score falls below zero    use random speeds and callback times to throw more or less cans  use effects to make the game fun  reset the game if the  r  key is pressed",
            "title": "Thirsty Zombie"
        },
        {
            "location": "/examples/thirsty/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/thirsty/#getting-started",
            "text": "To get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal:  pred pull thirsty  Then change into the  thirsty  directory.  cd thirsty  Now in the text editor, find and open the file  thirsty/game.py .",
            "title": "Getting Started"
        },
        {
            "location": "/examples/thirsty/#getting-started_1",
            "text": "Here's the first few lines:  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Thirsty Zombie'\n\n# load in the stormy background\nBACKGROUND = 'stormy'  This will build a window of 30x20 grid cells and add a \"stormy\" background image.  Make sure this image is saved in the  backgrounds/  directory .",
            "title": "Getting Started"
        },
        {
            "location": "/examples/thirsty/#zombie-creation",
            "text": "# create a zombie sprite. flip the sprite so the zombie faces to the right\nzombie = image('zombie-2', (5, 15), size = 3).speed(10).flip()\n\n# tell the zombie to follow the mouse movement\nzombie.follow()  We use the  .flip()  function to have the zombie face towards right right side of the screen.  Here's how to throw a sprite object:  def throw():\n    # pick a random position and select the y coordinate\n    y_pos = rand_pos()[1]\n\n    # create a soda and move it from right to left\n    target = 'sprite'\n    if randint(1, 5) == 4:\n        target = 'coke'     \n    s = image(target, (WIDTH+5, y_pos)).speed(2).collides(zombie, consume)\n    s.move_to((-1, y_pos), callback = lambda: miss(s))\n\n    # a callback to call the throw() function again\n    callback(throw, rand(0.5, 2))",
            "title": "Zombie Creation"
        },
        {
            "location": "/examples/thirsty/#callback-functions",
            "text": "Before we draw the code for a beverage, we need to define the logic that describes consumption. Remember, this is because python requires us to define our callback functions before we use them.  # zombie consumes a drink and explodes if it's a coke\ndef consume(target, zombie):\n    # destroy the can\n    target.destroy()\n\n    if target.name == 'coke':\n        # zombies don't like coke. end the game\n        zombie.destroy()\n        image('kaboom', center=(15, 10), size=25)\n        gameover()\n    else:\n        # we added a sprite. increase score\n        score(1)  If we don't consume a beverage, the zombie will need to suffer a little bit. Our second callback describes the \"misses\":  # zombie misses the opportunity to take a drink and is thirsty.\ndef miss(target):\n\n    # destroy the can\n    target.destroy()\n\n    # subtract a point if this was a sprite\n    if target.name == 'sprite':\n        score(-1)\n\n    # we lost\n    if score() < 0:\n        text(\"TOTAL DEHYDRATION\")\n        zombie.rotate(90).pulse(time=2, size=2)\n        gameover()",
            "title": "Callback Functions"
        },
        {
            "location": "/examples/thirsty/#throwing-soda",
            "text": "Throwing cans of soda is also a callback function, but controlled via time. A key to throwing is to mix up the positions a bit. The line of code  y_pos = rand_pos()[1]  is a shorthanded way of randomly picking a y (top/bottom) position. Read through the rest of the code below, we added some documentation to clarify each of the lines.  # this is a callback that throws a sprite or coke across the screen\ndef throw_soda():\n\n    # pick a random position and select the y coordinate\n    y_pos = rand_pos()[1]\n\n    # create a soda and move it from right to left\n    target = 'sprite'\n\n    # roughly 50% of the cans are cokes\n    if randint(1, 2) == 2:\n        target = 'coke'     \n\n    # position the sprite off the right side of the screen\n    # make it move fast (speed 10)\n    # if the zombie hits the can, execute the \"consume\" callback\n    s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume)\n\n    # move the sprite to the left. execute callback \"miss\" if movement finishes\n    s.move_to((-1, y_pos), callback = lambda: miss(s))\n\n    # a callback to call the throw() function again\n    callback(throw_soda, rand(0, 1.5))\n\n# schedule the throw callback to run\ncallback(throw_soda, 1)",
            "title": "Throwing Soda"
        },
        {
            "location": "/examples/thirsty/#final-bits",
            "text": "The final parts of the game enable score keeping and resetting the game if the 'r' key is pressed.  # add this so we can keep score of the game\nscore(color=WHITE)\n\n# press the r key to reset\nkeydown('r', reset)",
            "title": "Final Bits"
        },
        {
            "location": "/examples/thirsty/#complete-code",
            "text": "Below is the complete code for \"thirsty zombie\".  We added an easter egg if the 'b' button is pressed - launch of soccer balls; it's an added obstacle that the zombie will need to avoid.  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Thirsty Zombie'\n\n# load in the stormy background\nBACKGROUND = 'stormy'\n\n# create a zombie sprite. flip the sprite so the zombie faces to the right\nzombie = image('zombie-2', (5, 15), size = 3).speed(10).flip()\n\n# tell the zombie to follow the mouse movement\nzombie.follow()\n\n# keep track if the zombie is spinning\nspinning = False\n\n# zombie consumes a drink and explodes if it's a coke\ndef consume(target, zombie):\n\n    # a spinning zombie cannot consume things\n    if spinning:\n        return\n\n    # destroy the can\n    target.destroy()\n\n    if target.name == 'coke':\n        # zombies don't like coke. end the game\n        zombie.destroy()\n        image('kaboom', center=(15, 10), size=25)\n        gameover()\n    else:\n        # we added a sprite. increase score\n        score(1)\n\n# zombie misses the opportunity to take a drink and is thirsty.\ndef miss(target):\n\n    # destroy the can\n    target.destroy()\n\n    # subtract a point if this was a sprite\n    if target.name == 'sprite':\n        score(-1)\n\n    # we lost\n    if score() < 0:\n        text(\"TOTAL DEHYDRATION\")\n        zombie.rotate(90).pulse(time=2, size=2)\n        gameover()\n\n# this is a callback that throws a sprite or coke across the screen\ndef throw_soda():\n\n    # pick a random position and select the y coordinate\n    y_pos = rand_pos()[1]\n\n    # create a soda and move it from right to left\n    target = 'sprite'\n\n    # roughly 50% of the cans are cokes\n    if randint(1, 2) == 2:\n        target = 'coke'     \n\n    # position the sprite off the right side of the screen\n    # make it move fast (speed 10)\n    # if the zombie hits the can, execute the \"consume\" callback\n    s = image(target, (WIDTH+5, y_pos)).speed(10).collides(zombie, consume)\n\n    # move the sprite to the left. execute callback \"miss\" if movement finishes\n    s.move_to((-1, y_pos), callback = lambda: miss(s))\n\n    # a callback to call the throw() function again\n    callback(throw_soda, rand(0, 1.5))\n\n# schedule the throw callback to run\ncallback(throw_soda, 1)\n\n# this is a callback when the zombie is done spinning\ndef done_spinning():\n\n    # the \"global\" variable is set to False (since we are done spinning)\n    global spinning\n    spinning = False\n\n# this is a callback when the zombie is hit by a ball\ndef spinner(b, z):\n\n    # the \"global\" variable is set to True (since we are spinning)\n    global spinning\n    spinning = True\n\n    # destroy the ball\n    b.destroy()\n\n    # spin the zombie.. time probably can't go much smaller than 0.5\n    # execute callback done_spinning after completing two rotations\n    z.spin(time=0.5, rotations=2, callback=done_spinning)\n\n# this is a callback function to launch the ball\ndef launch():\n\n    # create a ball and position off the right side of the screen\n    random_y_position = rand_pos()[1]\n\n    # position balls off the screen, make them spin and move a little fast\n    ball = image('ball', (WIDTH+5, random_y_position), size=2).spin(0.2).speed(5)\n\n    # move right to left, destroy if movement completes\n    ball.move_to((-5, random_y_position), callback=ball.destroy)\n\n    # make the zombie spin if hit by a ball\n    ball.collides(zombie, spinner)\n\n    # prepare to launch another\n    callback(launch, rand(0.2, 1))\n\n# hitting 'b' starts launching balls!\nkeydown('b', launch)\n\n# add this so we can keep score of the game\nscore(color=WHITE)\n\n# press the r key to reset\nkeydown('r', reset)  Save this code as  game.py  and let's give it a run!  pred game.py  If it loads correctly, the following game canvas should display. Have fun!!",
            "title": "Complete Code"
        },
        {
            "location": "/examples/zombie/",
            "text": "Zombie Madness\n\n\nA coding instructional implementation based on the \nPredigame Platform\n. Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code!\n\n\nAsset Licenses\n\n\nAll static artwork has been obtained from \nOpenGameArt\n or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development.\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal:\n\n\npred pull zombie\n\n\n\n\nThen change into the \nzombie\n directory.\n\n\ncd zombie\n\n\n\n\nGame Story\n\n\n\n\nThis game consists of three \"actors\" - the player (you, depicted as a soldier), red forces (depicted as a zombie), and blue forces (depicted as a wild boar).\n\n\nRed forces launch in the top-right corner and will randomly find and seek the player and blues. Reds will attack upon collision. Death will be imminent. Blue deaths immediately turn into a new red. Player death ends game.\n\n\nBlue forces launch in the top-left corner and try to navigate to their \"home\" destination (bottom-right corner). They don't know anything about the player and zombie, though it is possible to hack the blue forces and add \"self defense\".\n\n\nReds and blues  periodically \"replan\" their routes.\n\n\nPlayers try to ensure as many blues can return home safely while destroying all reds. They have weapons and should not be afraid to use them.\n\n\nThere is a 10% chance of a special level that will require a different strategy.\n\n\n\n\n\n\nInstructional Coverage\n\n\nWe're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform.\n\n\nPredigame Concepts Covered:\n\n\n\n\nCallbacks (timing and keyboard)\n\n\nAnimated Actors\n\n\nLevels\n\n\nScoring and Statistics\n\n\nPreserving Game State\n\n\nInventory Control\n\n\nWeapons!\n\n\n\n\nPython Concepts Covered:\n\n\n\n\nAbstractions\n\n\nLoops\n\n\nClasses\n\n\n\n\nThe game consists of three files:\n\n\n\n\nzombie.py\n - [ADVANCED] contains the bulk of the implementation. Can be modified as desired, but some of the concepts would require prior programming experience.\n\n\nweapons.py\n - [INTERMEDIATE] all game weapons are defined as python classes. We recommend coders with prior experience experiment with the weapons and see the corresponding impacts in the game.\n\n\nzombie_plugins.py\n - [BEGINNER] the game has a bunch of user defined features that can be easily tweaked to change the style and function of the game. The majority of our coders spend their time working in this file. This README walks through some common \nuse cases\n and the underlying code that would be required for implementation. Each example includes a \nLOCATION GUIDE\n that will detail where in the \nzombie_plugins.py\n file to insert and modify the code.\n\n\nFor those looking to start fresh, we've included a file \nzombie_plugins_start.py\n that has the bare minimum for a functioning game. You'll want save this file as \nzombie_plugins.py\n and start coding! Keep in mind that bare minimum means \nNO WEAPONS\n so you'll need to be extra careful and avoid those red forces.\n\n\n\n\n\n\n\n\nRunning the Game\n\n\nWe recommend running all predigames from the command prompt/console/terminal. Be sure to \ncd\n into your game directory run:\n\n\npred zombie.py\n\n\n\n\nState Management\n\n\nUpon completion of a level, the game will write two state files. These files can be deleted to reset state.\n\n\n\n\nplayer.pg\n - consists of player energy, wealth, and inventory.\n\n\nstats.pg\n - consists of key game metrics:\n\n\nNumber of levels completed\n\n\nNumber of blue|red forces launched\n\n\nNumber of red kills\n\n\nNumber of player kills\n\n\nNumber of blue forces that arrive home safely\n\n\n\n\n\n\n\n\nBackground Images\n\n\nStatic backgrounds\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nThis code will provide a single image that is used in ever level. You'll want to add to your setup function.\n\n\n   background('grass')\n\n\n\n\nYou can also just have single color. Here is an example of a gray background.\n\n\n   background(GRAY)\n\n\n\n\nIf you have a particular color in mind, it's possible to also define the background with a \n(red, green, blue)\n tuple.\n\n\n   background((25, 25, 25))\n\n\n\n\nRandom backgrounds\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nIf you interested in changing backgrounds for each level, we'll want to create a list with all of our choices and then use the \nchoice()\n function to randomly select an image file from the list.\n\n\n   choices = ['grass', 'ville']\n   background(choice(choices))\n\n\n\n\nWe also have a pretty cool image service that will randomly pick and use a background from the Internet. This can add a little jazz to your game.\n\n\n   background()\n\n\n\n\nProgressive backgrounds\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nSometimes you'll want to have the same background be used for the same level. This can provide a hint to the user of where they are in the game. In order to accomplish progressive backgrounds, we'll need to evaluate the level and decide which background image to load. Using python, we can accomplish this with an if/else statement.\n\n\n   if level.level == 1:\n      background('grass')\n   elif level.level == 2:\n      background('ville')\n   else:\n      background('stormy')\n\n\n\n\nNotice that the file line is the \"catch all\" statement. This basically means the same \nstormy\n image will be used for the third and beyond levels.\n\n\nMazes\n\n\nGenerated maze\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nIt's possible, also within the \nsetup\n function, to define the type of maze should be drawn on the game service. Assuming that there is an image with the name \n'stone'\n, it's possible to use that to draw the maze.\n\n\n   maze(callback=partial(image, 'stone'))\n\n\n\n\nLikewise, it's also possibly to simply draw a maze with colors. For example,\n\n\n   maze(callback=partial(shape, RECT, BLACK))\n\n\n\n\nRandom maze\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nSometimes it may be desirable to have some randomly placed blocks to create as obstacles. It's possible to tweak the \n2.75\n number to draw more or less blocks. The numbers \n19\n and \n31\n signify the HEIGHT and WIDTH of the window, in terms of grid cells.\n\n\n   for y in range(19):\n      for x in range(31):\n         if rand(1, 3) > 2.75:\n            shape(RECT, RED, (x, y), tag='wall')\n\n\n\n\nPlayer Actions\n\n\nKeyboard Shortcuts\n\n\nNOTE:\n some of these shortcuts use the same keys. They can be easily changed to something else. It is not possible to assign more than one shortcut to the same keyboard key.\n\n\nChange the walking keys\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nThe game uses arrow keys for walking by default. It's possible to change them to something else. The below example changes them to \nw\n, \na\n, \ns\n,  and \nd\n. This code will need to be added to your \nsetup\n function\n\n\n   player.keys(right = 'd', left = 'a', up = 'w', down = 's', precondition=player_physics)\n\n\n\n\nThis code will obey the maze walls. If you want to walk through them, remove the \n, precondition=player_physics\n ending. The resulting code will look like this:\n\n\n   player.keys(right = 'd', left = 'a', up = 'w', down = 's')\n\n\n\n\nChange facing direction (without moving)\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nSometimes you may want to quickly change direction and shoot without having to move. This code will rebind the arrow keys to changing the facing direction. Keep in mind that you'll need to \nchange the walking keys\n or \nregister different keys for the facing direction\n. This code will need to be added to your \nsetup\n function.\n\n\n   def __direction__(player, direction):\n      \"\"\" change the players direction  \"\"\"\n      player.direction = direction\n      player.act(IDLE, FOREVER)\n\n   keydown('left', callback=partial(__direction__,player, LEFT))\n   keydown('right', callback=partial(__direction__,player, RIGHT))\n   keydown('up', callback=partial(__direction__,player, BACK))\n   keydown('down', callback=partial(__direction__,player, FRONT))\n\n\n\n\nInventory Controlled Weapons\n\n\nLOCATION GUIDE (ALL WEAPONS)\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\n\n\n\n\n\n\nweapon\n\n\ncost\n\n\nenergy impact\n\n\n\n\n\n\n\n\n\n\nair gun\n\n\n2\n\n\n0\n\n\n\n\n\n\nc4 explosive\n\n\n50\n\n\n-10\n\n\n\n\n\n\nflame thrower\n\n\n500\n\n\n-50\n\n\n\n\n\n\ngreen rage\n\n\n25\n\n\n10\n\n\n\n\n\n\ngrenade\n\n\n100\n\n\n-50\n\n\n\n\n\n\nlandmine\n\n\n50\n\n\n0\n\n\n\n\n\n\nmachine gun\n\n\n2\n\n\n0\n\n\n\n\n\n\nmustard gas\n\n\n250\n\n\n-10\n\n\n\n\n\n\npunch\n\n\n1\n\n\n-10\n\n\n\n\n\n\nwall builder\n\n\n5\n\n\n-5\n\n\n\n\n\n\nwall buster\n\n\nn/a\n\n\n-0.25\n\n\n\n\n\n\nnuclear bomb\n\n\nmucho grande\n\n\n0\n\n\n\n\n\n\n\n\nCore conceptual language\n - A player \"takes\" a Thing (can be anything) that is later used.\n\n\nInventory Market Place\n\n\nBuy weapons, restore energy at the market place! The market place can be accessed with the \nF1\n key during the game. All activity will be paused while you shop.\n\n\nAir Gun\n\n\nShoots \"air\" bullets. Default activation is with the \nspace\n bar.\n\n\n   player.take(weapons.AirGun(call='space'))\n\n\n\n\nC4 Explosives\n\n\nDrops C4 explosives. Thrown with the \n7\n key, detonated with the \n8\n key. Default throwing distance is \n8\n blocks and blast radius is \n10\n (which is about four blocks). Explosives only kill actors and do not destroy walls.\n\n\n   player.take(weapons.C4(call='7', detonate='8', distance=8, radius=10))\n\n\n\n\nFlame Thrower\n\n\nThrows a devastating ball of fire. It takes quite a bit of energy to generate a the fiery ball, but it's a sure way to clear out the bad guys. The flame had an internal compass that shadows the player's orientation, so move the player around for maximum effect.\n\n\nGenerated and thrown with the \n2\n key. Use player directional keys after thrown to control flame ball.\n\n\n   player.take(weapons.FlameThrower(call='2'))\n\n\n\n\nGreen Rage (Energy Drink)\n\n\nGive your player a dose of caffeine for continued rage! Only accessible from the inventory panel.  \n\n\nGrenade\n\n\nThrow a grenade with the \n3\n key. Default throwing distance is \n6\n blocks and blast radius is \n10\n (which is about four blocks). Grenade destroys anything in it's blasting radius - including walls!\n\n\n   player.take(weapons.Grenade(call='3', distance=6, radius=10))\n\n\n\n\nLandmine\n\n\nPlant a landmine with the \n6\n key. The bomb is activated in one second. \nBE CAREFUL!!\n - your player can fall victim to the explosive.\n\n\n   player.take(weapons.Landmine(call='6', delay=1))\n\n\n\n\nMachine Gun\n\n\nKeep your blue forces safe with the trusty machine gun! Default trigger is the \n5\n key with single bullets that travel \n15\n blocks. Want rapid fire more bullets? Be sure to set the \nrepeat\n parameter.\n\n\n   player.take(weapons.MachineGun(call='5', distance=15, repeat=1))\n\n\n\n\nMustard Gas\n\n\nTake out your enemies with a harmful chemical weapon. Thrown with the \n4\n key, a mustard gas capsule travels \n10\n blocks and has an effective radius of \n20\n (about 5 blocks). The gas capsule only explodes if it hits an actor instance.\n\n\n   player.take(weapons.MustardGas(call='4', distance=10, radius=20))\n\n\n\n\nPunch\n\n\nWhen all else fails, use your hands! The simple punch is activated with the \n1\n key. Make sure you sneak behind your enemy as they can attack you otherwise!\n\n\n   player.take(weapons.Punch(call='1'))\n\n\n\n\nWall Builder\n\n\nHave your player use walls to provide defense from the zombies. The first line sets the wall image, the second sets the directional callback keys.\n\n\n   wall = partial(image, 'stone')\n   player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall))\n\n\n\n\nWant to use colored rectangles instead? Give this a shot:\n\n\n   wall = partial(shape, RECT, BLACK)\n   player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall))\n\n\n\n\nWall Buster\n\n\nLet your player bust through the maze walls. Make sure you reset player walking keys (see above). A player that obeys physics can't bust walls!\n\n\n   player.take(weapons.WallBuster())\n\n\n\n\nNuclear Bomb\n\n\nOH. YEAH! Every game needs this one. Keep in mind that it takes a few seconds to call in the bomb. By default our bomb can be called in with the \nn\n key.\n\n\n   player.take(weapons.NuclearBomb(call='n'))\n\n\n\n\nBonus Sprites\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nThese boost sprites allow your player to earn extra energy and wealth bonuses during the game. Blue and red forces are immune to boost sprites.\n\n\nEnergy Boost\n\n\nThis code will drop \nsprite\n images with a \n5%\n probability. Anytime the player collides with a \nsprite\n image, the player is rewarded with a \n10%\n energy boost.\n\n\n   def drink(soda, player):\n      soda.destroy()\n      player.energy = 10\n   fill(partial(image,'sprite', size=1.0), 0.05, player, drink)\n\n\n\n\nWealth Boost\n\n\nThis code will drop \ncoin\n images with a \n25%\n probability. Anytime the player collides with a \ncoin\n image, the player is rewarded with a \n5\n point wealth boost.\n\n\n   def claim(coin, player):\n      coin.destroy()\n      player.wealth = 5\n   fill(partial(image,'coin', size=1.0), 0.25, player, claim)\n\n\n\n\nFriendlies\n\n\nLOCATION GUIDE\n: \ninsert as a top-level function\n\n\nYour objective is to save the life of friendly forces.\n\n\ndef get_blue():\n   \"\"\" create a blue (friendly) actor \"\"\"\n   # return name of actor and grazing speed\n   return 'Boar', 3\n\n\n\n\nCustom destination image\n\n\nLOCATION GUIDE\n: \ninsert as a top-level function\n\n\nDon't like the default pig pen image? It's possible to create your own with this function and then change \npigpen\n with whatever image you want!\n\n\ndef blue_destination():\n   return 'pigpen'\n\n\n\n\nSelf defense [HARD]\n\n\nLOCATION GUIDE\n: \ninsert as a top-level function and modify \nget_blue\n\n\nIt's possible to have your blue forces automate a self defense. This code is a bit weird and it still may allow hostiles to kill blue forces.\n\n\nStep 1:\n Define a self-defense function\nThis code checks all directions to see if any red forces are within \n5\n blocks. When a red force is nearby, the blue throws some self defense flares -- instantly killing the enemy.\n\n\ndef blue_defend(actor):\n   \"\"\" activate self defense \"\"\"\n   for direction in [BACK, FRONT, LEFT, RIGHT]:\n      things = actor.next_object(direction=direction, distance=5)\n      if things and has_tag(things, 'red'):\n            actor.direction = direction\n            actor.stop = True\n            target = actor.next_object()\n            if target and isinstance(target, Actor):\n               turd = image('turd', pos=actor.pos).speed(15)\n               turd.move_to(target.pos).destruct(2)\n               target.kill()\n            callback(partial(actor.act, IDLE, FOREVER), 5)\n\n\n\n\nStep 2:\n Change the \nget_blue\n function to include the newly added \nblue_defend\n self defense function.\n\n\ndef get_blue():\n   \"\"\" create a blue (friendly) actor \"\"\"\n   # return name of actor, grazing speed, self defense\n   return 'Piggy', 2, blue_defend\n\n\n\n\nSchedule more friendlies\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nIt's easy to schedule more friendlies with a callback function. Here's a couple of variations. All will need to be added to your \nsetup\n function.\n\n\nschedule a single friendly (1 second delay)\n\n\n   callback(level.create_blue, wait=1)\n\n\n\n\nschedule a friendly every 10 seconds and repeat 5 times\n\n\n   callback(level.create_blue, wait=10, repeat=5)\n\n\n\n\nschedule a friendly every 10 seconds and repeat forever\n\n\n   callback(level.create_blue, wait=10, repeat=FOREVER)\n\n\n\n\nHostiles\n\n\nLOCATION GUIDE\n: \ninsert as a top-level function\n\n\nYour object is to eliminate all hostile actors.\n\n\ndef get_red():\n   \"\"\" create a red (hostile) actor \"\"\"\n   # return name of actor, movement speed\n   return 'Zombie-1', 1\n\n\n\n\nSpawn different types of zombies at different speeds!\n\n\ndef get_red():\n   \"\"\" create a red (hostile) actor \"\"\"\n   # return name of actor, movement speed\n   zombies = ['Zombie-1','Zombie-2','Zombie-3']\n   return choice(zombies), randint(1,4)\n\n\n\n\n\nSchedule more hostiles\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nIt's easy to schedule more hostiles with a callback function. Here's a couple of variations. All will need to be added to your \nsetup\n function.\n\n\nschedule a single hostile (1 second delay)\n\n\n   callback(level.create_red, wait=1)\n\n\n\n\nschedule a hostile every 10 seconds and repeat 5 times\n\n\n   callback(level.create_red, wait=10, repeat=5)\n\n\n\n\nschedule a hostile every 10 seconds and repeat forever\n\n\n   callback(level.create_red, wait=10, repeat=FOREVER)\n\n\n\n\nLevels\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nOverriding the default behavior (MUST ADD)\n\n\nIt's possible to change how the story ends! Here's a few possible tricks you can try. Be sure to \nregister\n your \n__completed__\n function first!\n\n\n   def __completed__(self):\n      # promote level by killing all the hostiles\n      if len(get('red')) == 0:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n\n   # register the __completed__ function to control how the level decisions are made\n   level.completed = MethodType(__completed__, level)\n\n\n\n\nYou'll notice that plugging in this code will drastically change how the levels end. What happens if all the blues die? What happens if your player dies?\n\n\nThe rest of the the updates will be specific to the \n__completed__\n function. There is no need to register that function more than once.\n\n\nOption 1: All Blues Go Home\n\n\nThis code will promote the level if all blue forces go home. It will also end the game if one dies. Again, you'll want to replace your existing \n__completed__\n function with this code.\n\n\n   def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif self.blue_killed > 0:\n         text('GAME OVER')\n         gameover()\n\n\n\n\n\nOption 2: Option 1 + Player Survives\n\n\n   def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()\n\n\n\n\nOption 3: Option 2 + Kill all the hostiles\n\n\n   def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif len(get('red')) == 0:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()  \n\n\n\n\nOption 4: Blues go home and their house survives\n\n\n   def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif len(get('destination')) == 0:\n        text('DESTINATION DESTROYED! GAME OVER!')\n        gameover()  \n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()  \n\n\n\n\nOption 5: Option 4 + all reds die\n\n\n   def __completed__(self):\n      if self.blue_spawned == self.blue_safe and len(get('red')) == 0:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif len(get('destination')) == 0:\n        text('DESTINATION DESTROYED! GAME OVER!')\n        gameover()  \n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()  \n\n\n\n\nScoring\n\n\nAdd  countdown timer\n\n\nLOCATION GUIDE\n: \ninsert inside the setup function\n -- \ndef setup(player, level):\n\n\nThis code should be added to the end of the \nsetup\n function.\n\npython\n   timer(color=WHITE, value=30)\n\nIf desired, it's also possible to add a countdown time that adds additional time for each level. The following code will add 30 seconds for each level.\n\npython\n   timer(color=WHITE, value=30*level.level)",
            "title": "Zombie Madness"
        },
        {
            "location": "/examples/zombie/#zombie-madness",
            "text": "A coding instructional implementation based on the  Predigame Platform . Many of the features have been curated by ~75 aspiring innovators (ages 10+) who love to flex their STEM prowess by putting ideas to code!",
            "title": "Zombie Madness"
        },
        {
            "location": "/examples/zombie/#asset-licenses",
            "text": "All static artwork has been obtained from  OpenGameArt  or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development.",
            "title": "Asset Licenses"
        },
        {
            "location": "/examples/zombie/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/zombie/#getting-started",
            "text": "To get things started, we're going download an existing Predigame game that has a few images and sound effects we can use to experiment. This can be done by typing the following the command in the terminal:  pred pull zombie  Then change into the  zombie  directory.  cd zombie",
            "title": "Getting Started"
        },
        {
            "location": "/examples/zombie/#game-story",
            "text": "This game consists of three \"actors\" - the player (you, depicted as a soldier), red forces (depicted as a zombie), and blue forces (depicted as a wild boar).  Red forces launch in the top-right corner and will randomly find and seek the player and blues. Reds will attack upon collision. Death will be imminent. Blue deaths immediately turn into a new red. Player death ends game.  Blue forces launch in the top-left corner and try to navigate to their \"home\" destination (bottom-right corner). They don't know anything about the player and zombie, though it is possible to hack the blue forces and add \"self defense\".  Reds and blues  periodically \"replan\" their routes.  Players try to ensure as many blues can return home safely while destroying all reds. They have weapons and should not be afraid to use them.  There is a 10% chance of a special level that will require a different strategy.",
            "title": "Game Story"
        },
        {
            "location": "/examples/zombie/#instructional-coverage",
            "text": "We're working on some videos to describe Predigame concepts in more detail, but this game illustrates quite a few pretty cool features of the platform.  Predigame Concepts Covered:   Callbacks (timing and keyboard)  Animated Actors  Levels  Scoring and Statistics  Preserving Game State  Inventory Control  Weapons!   Python Concepts Covered:   Abstractions  Loops  Classes   The game consists of three files:   zombie.py  - [ADVANCED] contains the bulk of the implementation. Can be modified as desired, but some of the concepts would require prior programming experience.  weapons.py  - [INTERMEDIATE] all game weapons are defined as python classes. We recommend coders with prior experience experiment with the weapons and see the corresponding impacts in the game.  zombie_plugins.py  - [BEGINNER] the game has a bunch of user defined features that can be easily tweaked to change the style and function of the game. The majority of our coders spend their time working in this file. This README walks through some common  use cases  and the underlying code that would be required for implementation. Each example includes a  LOCATION GUIDE  that will detail where in the  zombie_plugins.py  file to insert and modify the code.  For those looking to start fresh, we've included a file  zombie_plugins_start.py  that has the bare minimum for a functioning game. You'll want save this file as  zombie_plugins.py  and start coding! Keep in mind that bare minimum means  NO WEAPONS  so you'll need to be extra careful and avoid those red forces.",
            "title": "Instructional Coverage"
        },
        {
            "location": "/examples/zombie/#running-the-game",
            "text": "We recommend running all predigames from the command prompt/console/terminal. Be sure to  cd  into your game directory run:  pred zombie.py",
            "title": "Running the Game"
        },
        {
            "location": "/examples/zombie/#state-management",
            "text": "Upon completion of a level, the game will write two state files. These files can be deleted to reset state.   player.pg  - consists of player energy, wealth, and inventory.  stats.pg  - consists of key game metrics:  Number of levels completed  Number of blue|red forces launched  Number of red kills  Number of player kills  Number of blue forces that arrive home safely",
            "title": "State Management"
        },
        {
            "location": "/examples/zombie/#background-images",
            "text": "",
            "title": "Background Images"
        },
        {
            "location": "/examples/zombie/#static-backgrounds",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  This code will provide a single image that is used in ever level. You'll want to add to your setup function.     background('grass')  You can also just have single color. Here is an example of a gray background.     background(GRAY)  If you have a particular color in mind, it's possible to also define the background with a  (red, green, blue)  tuple.     background((25, 25, 25))",
            "title": "Static backgrounds"
        },
        {
            "location": "/examples/zombie/#random-backgrounds",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  If you interested in changing backgrounds for each level, we'll want to create a list with all of our choices and then use the  choice()  function to randomly select an image file from the list.     choices = ['grass', 'ville']\n   background(choice(choices))  We also have a pretty cool image service that will randomly pick and use a background from the Internet. This can add a little jazz to your game.     background()",
            "title": "Random backgrounds"
        },
        {
            "location": "/examples/zombie/#progressive-backgrounds",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  Sometimes you'll want to have the same background be used for the same level. This can provide a hint to the user of where they are in the game. In order to accomplish progressive backgrounds, we'll need to evaluate the level and decide which background image to load. Using python, we can accomplish this with an if/else statement.     if level.level == 1:\n      background('grass')\n   elif level.level == 2:\n      background('ville')\n   else:\n      background('stormy')  Notice that the file line is the \"catch all\" statement. This basically means the same  stormy  image will be used for the third and beyond levels.",
            "title": "Progressive backgrounds"
        },
        {
            "location": "/examples/zombie/#mazes",
            "text": "",
            "title": "Mazes"
        },
        {
            "location": "/examples/zombie/#generated-maze",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  It's possible, also within the  setup  function, to define the type of maze should be drawn on the game service. Assuming that there is an image with the name  'stone' , it's possible to use that to draw the maze.     maze(callback=partial(image, 'stone'))  Likewise, it's also possibly to simply draw a maze with colors. For example,     maze(callback=partial(shape, RECT, BLACK))",
            "title": "Generated maze"
        },
        {
            "location": "/examples/zombie/#random-maze",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  Sometimes it may be desirable to have some randomly placed blocks to create as obstacles. It's possible to tweak the  2.75  number to draw more or less blocks. The numbers  19  and  31  signify the HEIGHT and WIDTH of the window, in terms of grid cells.     for y in range(19):\n      for x in range(31):\n         if rand(1, 3) > 2.75:\n            shape(RECT, RED, (x, y), tag='wall')",
            "title": "Random maze"
        },
        {
            "location": "/examples/zombie/#player-actions",
            "text": "",
            "title": "Player Actions"
        },
        {
            "location": "/examples/zombie/#keyboard-shortcuts",
            "text": "NOTE:  some of these shortcuts use the same keys. They can be easily changed to something else. It is not possible to assign more than one shortcut to the same keyboard key.",
            "title": "Keyboard Shortcuts"
        },
        {
            "location": "/examples/zombie/#change-the-walking-keys",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  The game uses arrow keys for walking by default. It's possible to change them to something else. The below example changes them to  w ,  a ,  s ,  and  d . This code will need to be added to your  setup  function     player.keys(right = 'd', left = 'a', up = 'w', down = 's', precondition=player_physics)  This code will obey the maze walls. If you want to walk through them, remove the  , precondition=player_physics  ending. The resulting code will look like this:     player.keys(right = 'd', left = 'a', up = 'w', down = 's')",
            "title": "Change the walking keys"
        },
        {
            "location": "/examples/zombie/#change-facing-direction-without-moving",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  Sometimes you may want to quickly change direction and shoot without having to move. This code will rebind the arrow keys to changing the facing direction. Keep in mind that you'll need to  change the walking keys  or  register different keys for the facing direction . This code will need to be added to your  setup  function.     def __direction__(player, direction):\n      \"\"\" change the players direction  \"\"\"\n      player.direction = direction\n      player.act(IDLE, FOREVER)\n\n   keydown('left', callback=partial(__direction__,player, LEFT))\n   keydown('right', callback=partial(__direction__,player, RIGHT))\n   keydown('up', callback=partial(__direction__,player, BACK))\n   keydown('down', callback=partial(__direction__,player, FRONT))",
            "title": "Change facing direction (without moving)"
        },
        {
            "location": "/examples/zombie/#inventory-controlled-weapons",
            "text": "LOCATION GUIDE (ALL WEAPONS) :  insert inside the setup function  --  def setup(player, level):     weapon  cost  energy impact      air gun  2  0    c4 explosive  50  -10    flame thrower  500  -50    green rage  25  10    grenade  100  -50    landmine  50  0    machine gun  2  0    mustard gas  250  -10    punch  1  -10    wall builder  5  -5    wall buster  n/a  -0.25    nuclear bomb  mucho grande  0     Core conceptual language  - A player \"takes\" a Thing (can be anything) that is later used.",
            "title": "Inventory Controlled Weapons"
        },
        {
            "location": "/examples/zombie/#inventory-market-place",
            "text": "Buy weapons, restore energy at the market place! The market place can be accessed with the  F1  key during the game. All activity will be paused while you shop.",
            "title": "Inventory Market Place"
        },
        {
            "location": "/examples/zombie/#air-gun",
            "text": "Shoots \"air\" bullets. Default activation is with the  space  bar.     player.take(weapons.AirGun(call='space'))",
            "title": "Air Gun"
        },
        {
            "location": "/examples/zombie/#c4-explosives",
            "text": "Drops C4 explosives. Thrown with the  7  key, detonated with the  8  key. Default throwing distance is  8  blocks and blast radius is  10  (which is about four blocks). Explosives only kill actors and do not destroy walls.     player.take(weapons.C4(call='7', detonate='8', distance=8, radius=10))",
            "title": "C4 Explosives"
        },
        {
            "location": "/examples/zombie/#flame-thrower",
            "text": "Throws a devastating ball of fire. It takes quite a bit of energy to generate a the fiery ball, but it's a sure way to clear out the bad guys. The flame had an internal compass that shadows the player's orientation, so move the player around for maximum effect.  Generated and thrown with the  2  key. Use player directional keys after thrown to control flame ball.     player.take(weapons.FlameThrower(call='2'))",
            "title": "Flame Thrower"
        },
        {
            "location": "/examples/zombie/#green-rage-energy-drink",
            "text": "Give your player a dose of caffeine for continued rage! Only accessible from the inventory panel.",
            "title": "Green Rage (Energy Drink)"
        },
        {
            "location": "/examples/zombie/#grenade",
            "text": "Throw a grenade with the  3  key. Default throwing distance is  6  blocks and blast radius is  10  (which is about four blocks). Grenade destroys anything in it's blasting radius - including walls!     player.take(weapons.Grenade(call='3', distance=6, radius=10))",
            "title": "Grenade"
        },
        {
            "location": "/examples/zombie/#landmine",
            "text": "Plant a landmine with the  6  key. The bomb is activated in one second.  BE CAREFUL!!  - your player can fall victim to the explosive.     player.take(weapons.Landmine(call='6', delay=1))",
            "title": "Landmine"
        },
        {
            "location": "/examples/zombie/#machine-gun",
            "text": "Keep your blue forces safe with the trusty machine gun! Default trigger is the  5  key with single bullets that travel  15  blocks. Want rapid fire more bullets? Be sure to set the  repeat  parameter.     player.take(weapons.MachineGun(call='5', distance=15, repeat=1))",
            "title": "Machine Gun"
        },
        {
            "location": "/examples/zombie/#mustard-gas",
            "text": "Take out your enemies with a harmful chemical weapon. Thrown with the  4  key, a mustard gas capsule travels  10  blocks and has an effective radius of  20  (about 5 blocks). The gas capsule only explodes if it hits an actor instance.     player.take(weapons.MustardGas(call='4', distance=10, radius=20))",
            "title": "Mustard Gas"
        },
        {
            "location": "/examples/zombie/#punch",
            "text": "When all else fails, use your hands! The simple punch is activated with the  1  key. Make sure you sneak behind your enemy as they can attack you otherwise!     player.take(weapons.Punch(call='1'))",
            "title": "Punch"
        },
        {
            "location": "/examples/zombie/#wall-builder",
            "text": "Have your player use walls to provide defense from the zombies. The first line sets the wall image, the second sets the directional callback keys.     wall = partial(image, 'stone')\n   player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall))  Want to use colored rectangles instead? Give this a shot:     wall = partial(shape, RECT, BLACK)\n   player.take(weapons.WallBuilder(left='left', right='right', front='up', back='down', wall=wall))",
            "title": "Wall Builder"
        },
        {
            "location": "/examples/zombie/#wall-buster",
            "text": "Let your player bust through the maze walls. Make sure you reset player walking keys (see above). A player that obeys physics can't bust walls!     player.take(weapons.WallBuster())",
            "title": "Wall Buster"
        },
        {
            "location": "/examples/zombie/#nuclear-bomb",
            "text": "OH. YEAH! Every game needs this one. Keep in mind that it takes a few seconds to call in the bomb. By default our bomb can be called in with the  n  key.     player.take(weapons.NuclearBomb(call='n'))",
            "title": "Nuclear Bomb"
        },
        {
            "location": "/examples/zombie/#bonus-sprites",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  These boost sprites allow your player to earn extra energy and wealth bonuses during the game. Blue and red forces are immune to boost sprites.",
            "title": "Bonus Sprites"
        },
        {
            "location": "/examples/zombie/#energy-boost",
            "text": "This code will drop  sprite  images with a  5%  probability. Anytime the player collides with a  sprite  image, the player is rewarded with a  10%  energy boost.     def drink(soda, player):\n      soda.destroy()\n      player.energy = 10\n   fill(partial(image,'sprite', size=1.0), 0.05, player, drink)",
            "title": "Energy Boost"
        },
        {
            "location": "/examples/zombie/#wealth-boost",
            "text": "This code will drop  coin  images with a  25%  probability. Anytime the player collides with a  coin  image, the player is rewarded with a  5  point wealth boost.     def claim(coin, player):\n      coin.destroy()\n      player.wealth = 5\n   fill(partial(image,'coin', size=1.0), 0.25, player, claim)",
            "title": "Wealth Boost"
        },
        {
            "location": "/examples/zombie/#friendlies",
            "text": "LOCATION GUIDE :  insert as a top-level function  Your objective is to save the life of friendly forces.  def get_blue():\n   \"\"\" create a blue (friendly) actor \"\"\"\n   # return name of actor and grazing speed\n   return 'Boar', 3",
            "title": "Friendlies"
        },
        {
            "location": "/examples/zombie/#custom-destination-image",
            "text": "LOCATION GUIDE :  insert as a top-level function  Don't like the default pig pen image? It's possible to create your own with this function and then change  pigpen  with whatever image you want!  def blue_destination():\n   return 'pigpen'",
            "title": "Custom destination image"
        },
        {
            "location": "/examples/zombie/#self-defense-hard",
            "text": "LOCATION GUIDE :  insert as a top-level function and modify  get_blue  It's possible to have your blue forces automate a self defense. This code is a bit weird and it still may allow hostiles to kill blue forces.  Step 1:  Define a self-defense function\nThis code checks all directions to see if any red forces are within  5  blocks. When a red force is nearby, the blue throws some self defense flares -- instantly killing the enemy.  def blue_defend(actor):\n   \"\"\" activate self defense \"\"\"\n   for direction in [BACK, FRONT, LEFT, RIGHT]:\n      things = actor.next_object(direction=direction, distance=5)\n      if things and has_tag(things, 'red'):\n            actor.direction = direction\n            actor.stop = True\n            target = actor.next_object()\n            if target and isinstance(target, Actor):\n               turd = image('turd', pos=actor.pos).speed(15)\n               turd.move_to(target.pos).destruct(2)\n               target.kill()\n            callback(partial(actor.act, IDLE, FOREVER), 5)  Step 2:  Change the  get_blue  function to include the newly added  blue_defend  self defense function.  def get_blue():\n   \"\"\" create a blue (friendly) actor \"\"\"\n   # return name of actor, grazing speed, self defense\n   return 'Piggy', 2, blue_defend",
            "title": "Self defense [HARD]"
        },
        {
            "location": "/examples/zombie/#schedule-more-friendlies",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  It's easy to schedule more friendlies with a callback function. Here's a couple of variations. All will need to be added to your  setup  function.  schedule a single friendly (1 second delay)     callback(level.create_blue, wait=1)  schedule a friendly every 10 seconds and repeat 5 times     callback(level.create_blue, wait=10, repeat=5)  schedule a friendly every 10 seconds and repeat forever     callback(level.create_blue, wait=10, repeat=FOREVER)",
            "title": "Schedule more friendlies"
        },
        {
            "location": "/examples/zombie/#hostiles",
            "text": "LOCATION GUIDE :  insert as a top-level function  Your object is to eliminate all hostile actors.  def get_red():\n   \"\"\" create a red (hostile) actor \"\"\"\n   # return name of actor, movement speed\n   return 'Zombie-1', 1  Spawn different types of zombies at different speeds!  def get_red():\n   \"\"\" create a red (hostile) actor \"\"\"\n   # return name of actor, movement speed\n   zombies = ['Zombie-1','Zombie-2','Zombie-3']\n   return choice(zombies), randint(1,4)",
            "title": "Hostiles"
        },
        {
            "location": "/examples/zombie/#schedule-more-hostiles",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  It's easy to schedule more hostiles with a callback function. Here's a couple of variations. All will need to be added to your  setup  function.  schedule a single hostile (1 second delay)     callback(level.create_red, wait=1)  schedule a hostile every 10 seconds and repeat 5 times     callback(level.create_red, wait=10, repeat=5)  schedule a hostile every 10 seconds and repeat forever     callback(level.create_red, wait=10, repeat=FOREVER)",
            "title": "Schedule more hostiles"
        },
        {
            "location": "/examples/zombie/#levels",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):",
            "title": "Levels"
        },
        {
            "location": "/examples/zombie/#overriding-the-default-behavior-must-add",
            "text": "It's possible to change how the story ends! Here's a few possible tricks you can try. Be sure to  register  your  __completed__  function first!     def __completed__(self):\n      # promote level by killing all the hostiles\n      if len(get('red')) == 0:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n\n   # register the __completed__ function to control how the level decisions are made\n   level.completed = MethodType(__completed__, level)  You'll notice that plugging in this code will drastically change how the levels end. What happens if all the blues die? What happens if your player dies?  The rest of the the updates will be specific to the  __completed__  function. There is no need to register that function more than once.",
            "title": "Overriding the default behavior (MUST ADD)"
        },
        {
            "location": "/examples/zombie/#option-1-all-blues-go-home",
            "text": "This code will promote the level if all blue forces go home. It will also end the game if one dies. Again, you'll want to replace your existing  __completed__  function with this code.     def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif self.blue_killed > 0:\n         text('GAME OVER')\n         gameover()",
            "title": "Option 1: All Blues Go Home"
        },
        {
            "location": "/examples/zombie/#option-2-option-1-player-survives",
            "text": "def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()",
            "title": "Option 2: Option 1 + Player Survives"
        },
        {
            "location": "/examples/zombie/#option-3-option-2-kill-all-the-hostiles",
            "text": "def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif len(get('red')) == 0:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()",
            "title": "Option 3: Option 2 + Kill all the hostiles"
        },
        {
            "location": "/examples/zombie/#option-4-blues-go-home-and-their-house-survives",
            "text": "def __completed__(self):\n      if self.blue_spawned == self.blue_safe:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif len(get('destination')) == 0:\n        text('DESTINATION DESTROYED! GAME OVER!')\n        gameover()  \n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()",
            "title": "Option 4: Blues go home and their house survives"
        },
        {
            "location": "/examples/zombie/#option-5-option-4-all-reds-die",
            "text": "def __completed__(self):\n      if self.blue_spawned == self.blue_safe and len(get('red')) == 0:\n         self.player.energy = 50\n         self.player.wealth = 250\n         save_state(self.player, 'player.pg')\n         return True\n      elif len(get('destination')) == 0:\n        text('DESTINATION DESTROYED! GAME OVER!')\n        gameover()  \n      elif self.blue_killed > 0 or len(get('player')) == 0:\n         text('GAME OVER')\n         gameover()",
            "title": "Option 5: Option 4 + all reds die"
        },
        {
            "location": "/examples/zombie/#scoring",
            "text": "",
            "title": "Scoring"
        },
        {
            "location": "/examples/zombie/#add-countdown-timer",
            "text": "LOCATION GUIDE :  insert inside the setup function  --  def setup(player, level):  This code should be added to the end of the  setup  function. python\n   timer(color=WHITE, value=30) \nIf desired, it's also possible to add a countdown time that adds additional time for each level. The following code will add 30 seconds for each level. python\n   timer(color=WHITE, value=30*level.level)",
            "title": "Add  countdown timer"
        },
        {
            "location": "/examples/sprites/",
            "text": "Working with Sprites\n\n\nThe Predigame sprite is a generic two-dimensional object that is integrated with other sprites in a larger scene. A sprite can consist of a bitmap (still) image or a basic geometrical shape (circle, rectangle, ellipse). Sprites in Predigame have some fun properties - they can be clicked, collide with other sprites, even fade, spin or pulse.\n\n\nLet's have fun working with Sprites!\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:\n\n\npred new sprites\n\n\n\n\nNow in the text editor, find and open the file \nsprites/game.py\n. This file is used to create a basic Predigame canvas that we'll use to place sprites. The canvas will have a width of 30 grid cells, height of 20 grid cells (we'll discuss what cells mean in a second), and a title of \nSimple Game\n, which we're going to change to \nSprites Demo\n.\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Sprites Demo'\n\n\n\n\nSave your changes. Try running the game from the terminal using the \npred\n command (you'll want to run this command from the directory where you saved the file, e.g. \nsprites\n if you followed the above \npred new\n example).\n\n\npred game.py\n\n\n\n\nNow this program doesn't do much just yet. Just an empty window titled \nSprites Demo\n. So boring. We're going to add some more code, but first let's make sure we understand grid coordinates and how to place sprites within those coordinates.\n\n\nUnderstanding Grid Coordinates\n\n\nProbably the easiest way to understand grid coordinates is to enable the \ngrid()\n overlay in the game code.\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Sprites Demo'\n\ngrid()\n\n\n\n\nSave your code and try running the this version using the same command:\n\n\npred game.py\n\n\n\n\nThe result should look like the figure below. Counting the grid coordinates will show \n30\n from \nleft to right\n and \n20\n from \ntop to bottom\n. This doesn't address how to address sprites using grid coordinates, we'll cover that next.\n\n\n\n\nThe following code will show how to place rectangle sprites in each of the four corners of the window.\n\n\n# top/left\nshape(RECT, RED, (0, 0))\n\n# bottom/left\nshape(RECT, BLUE, (0, HEIGHT-1))\n\n# top/right\nshape(RECT, PINK, (WIDTH-1, 0))\n\n# bottom/right\nshape(RECT, PURPLE, (WIDTH-1, HEIGHT-1))\n\n\n\n\nSaving and running the code will show:\n- a RED rectangle at position \n(0, 0)\n corresponding to the top-left corner\n- a BLUE rectangle at position \n(0, HEIGHT-1)\n corresponding to the bottom-left corner\n- a PINK rectangle at position \n(WIDTH-1,  0)\n corresponding to the top-right corner\n- a PURPLE rectangle at position \n(WIDTH-1, HEIGHT-1)\n corresponding to the bottom-right corner\n\n\nWhy are the corners specified as \nWIDTH-1\n and \nHEIGHT-1\n?\n\n\nComputers always start counting at zero. So if \nWIDTH = 30\n and the first grid is \n0\n the thirtieth cell would be \nWIDTH-1\n or \n29\n.\n\n\nRunning this code should look like the figure below.\n\n\n\nWe added a few labels to make the grid coordinates a little more easier to visualize. It's possible to replace the code from the previous exercise with the one here:\n\n\n# place on center of screen\ntext(\"Understanding Grid Coordinates\", color=BLACK, size = 2.0)\ntext(\"this is a 30 x 20 window\", color=BLACK, pos=(WIDTH/2-7, HEIGHT/2+1), size = 1.75)\n\n# top/left\nshape(RECT, RED, (0, 0))\ntext(\"(0, 0)\", RED, pos = (0,1), size = 1.25)\n\n# bottom/left\nshape(RECT, BLUE, (0, HEIGHT-1))\ntext(\"(0, \" + str(HEIGHT-1) + \")\", BLUE, pos = (0, HEIGHT-2), size=1.25)\n\n# top/right\nshape(RECT, PINK, (WIDTH-1, 0))\ntext(\"(\" + str(WIDTH-1) + \", 0)\", PINK, pos = (WIDTH-2.5,1), size = 1.25)\n\n# bottom/right\nshape(RECT, PURPLE, (WIDTH-1, HEIGHT-1))\ntext(\"(\" + str(WIDTH-1) + \", \" + str(HEIGHT-1) + \")\", PURPLE, pos = (WIDTH-3,HEIGHT-2), size = 1.25)\n\n\n\n\nThe resulting game window will show the following rendering:\n\n\n\nCreating Shapes\n\n\nThere are two types of sprites supported in the Predigame platform - shapes and images. Let's look at shapes. The formal \nfunction definition\n (or signature) for creating a shape is as follows:\n\n\nshape(shape = None, color = None, pos = None, size = (1, 1))\n\n\n\n\nReading this code, there are four \nattributes\n:\n\n\n\n\nshape\n - the type of shape to create. Can be one of RECT, SQUARE, CIRCLE, or ELLIPSE\n\n\ncolor\n - the shape's color. Can be a constant like BLACK, BLUE, or RED, as well as a (red, green, blue) tuple such as (128, 128, 128)\n\n\npos\n   - the grid cell of the shape\n\n\nsize\n  - the size of the shape in terms of grid cells using the form (width, height). For CIRCLE shapes, only the first number is considered.\n\n\n\n\nNotice that each of these attributes have default values. This means that they are option, and if not specified, Predigame will create a random shape type of random color, size, and position.\n\n\n# draw a random shape type of random color, size, and position\nshape()\n\n\n\n\nHere are a few example shapes we can add to our canvas:\n\n\n# red circle at position (2, 2)\nshape(CIRCLE, RED, (2, 2))\n\n# create a big blue circle next to the red one\nshape(CIRCLE, BLUE, (5, 1), 3)\n\n# create a 2x2 ORANGE square at position (10, 2)\nshape(RECT, ORANGE, (10, 2), (2,2))\n\n# create a 6x1 rectangle\nshape(RECT, AQUA, (15, 2), (6, 1))\n\n# create a custom colored (r, g, b) ELLIPSE\nshape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2))\n\n\n\n\nIf we add each of the above shapes to our code, the resulting file will look like this:\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Sprites Demo'\n\n# red circle at position (2, 2)\nshape(CIRCLE, RED, (2, 2))\n\n# create a big blue circle next to the red one\nshape(CIRCLE, BLUE, (5, 1), 3)\n\n# create a 2x2 ORANGE square at position (10, 2)\nshape(RECT, ORANGE, (10, 2), (2,2))\n\n# create a 6x1 rectangle\nshape(RECT, AQUA, (15, 2), (6, 1))\n\n# create a custom colored (r, g, b) ELLIPSE\nshape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2))\n\n\n\n\nSave and run this code. The result should look similar to the image below:\n\n\n\nCreating Images\n\n\nLike shapes, the Predigame platform also supports creating images. The formal \nfunction definition\n (or signature) for creating an image is as follows:\n\n\nimage(name = None, pos = None, center = None, size = 1)\n\n\n\n\nNotice that it is similar, yet slightly different than the code for creating a shape. An image in Predigame is defined by:\n\n\n\n\nname\n - the name (without extension) of the image file. The image file should be stored in the \nimages/\n directory. For example, if we had an image \"coke.png\" in our \nimages/\n directory, the name of the image would be \"coke\".\n\n\npos\n -  the grid cell of the shape. Officially, this will be the top-left cell of the image.\n\n\ncenter\n - used as an alternative to \npos\n to use this position as the center point.\n\n\nsize\n - the size of the shape in terms of grid cells. By default, the image will be fit into a single grid cell.\n\n\n\n\nNotice again that each of these attributes have default values. This means that they are option, and if not specified, PrediGame will select a random image from the \nimages/\n directory of size \n1\n (so it will fit into a single cell) and will be placed at a random position.\n\n\nNow here are a few example shapes we can also add to our canvas:\n\n\n# create a \"sprite\" sprite and place at grid location (2, 8)\nimage('sprite', (2, 8))\n\n# create a \"coke\" sprite of double size and place at grid (7, 8)\nimage('coke', (7, 8), size = 2)\n\n# create a zombie\nimage('zombie-1', (13,9), size = 5)\n\n# create another zombie\nimage('zombie-2', (19,9), size = 5)\n\n\n\n\nAdd the above lines to our code file and save the changes. The result should look similar to the image below:\n\n\n\nSprite Effects\n\n\nDrawing sprites can be a lot of fun, however, we can add some effects to bring them to life. For example, we can make sprites spin, float, and even pulse. Let's look at the some new sprites with effects attached.\n\n\nSpinning\n\n\nimage('sprite', (2,14)).spin(time=1)\n\n\n\n\nThis sprite will spin and complete a revolution every second. It's possible to change \ntime\n to a smaller or larger number to increase or decrease the spin rate.\n\n\nPulsing\n\n\nimage('sprite', (7,14)).pulse(time=0.5, size=3)\n\n\n\n\nHave the sprite execute a pulsing effect - rapidly expand and shrink. The \nsize\n attribute will control the maximum size of the sprite (as a multiplier) during expansion. The \ntime\n attribute sets the amount of time (in seconds) the sprite will take to complete an expansion or contraction.\n\n\nFloating\n\n\nimage('coke', (13, 15), size = 2).speed(1).float(distance=1)\n\n\n\n\nHave the sprite float in place. The \n.speed(1)\n call sets the speed of the movement and the \ndistance\n attribute sets the amount of room (in term of grid cells) the sprite will use to complete a floating operation.\n\n\nSprite Event Callbacks\n\n\nWhen we code a game we sometimes need to create actions that will eventually occur. Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game.\n\n\nThe Python program language requires that we specify our functions before registering them in the code. Let's look at a simple callback example.\n\n\ndef destroy(s):\n    s.destroy()\n\n\n\n\nThis function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered.\n\n\ns = shape(CIRCLE, RED, rand_pos()).clicked(destroy)\n\n\n\n\nThat's right.. We can basically add a \n.clicked(destroy)\n to the end of our shape definition and register a callback function that won't get called until the player clicks on the circle.\n\n\nLet's take a look at few more examples of event callbacks.\n\n\nClick Events\n\n\nWe already briefly covered a click example, but let's look at one that is a little more complicated.\n\n\ndef doit(s):\n    s.destroy()\n    image('kaboom', center=(15, 10), size=25)\n\nimage('clickme', (19, 15), size = 2).pulse(time=0.05, size= 1.25).clicked(doit)\n\n\n\n\nThis example creates a fast pulsing \nclickme\n sprite that is destroyed when clicked and replaced with an oversized  \nkaboom\n image.\n\n\ns = image('coke', (13, 15), size = 2)\ns.speed(1).bouncy().spin().pulse().clicked(s.destroy)\n\n\n\n\nThis example is similar to our first mouse click example on the shape but it recycles the sprites \ndestroy()\n method as a callback - \n.clicked(s.destroy)\n. It also chains a whole bunch of effects that make this sprite bounce around the canvas, pulse, and even spin.\n\n\nKeyboard Events\n\n\nWe can also control a sprite with the keyboard.\n\n\nimage('zombie-1', (28, 18), size = 2).keys()\nimage('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s')\n\n\n\n\nIn this case \nzombie-1\n is registered with the \n.keys()\nfunction which will control the sprite with keyboard arrow buttons. In the case where we'd like to use other keyboard buttons, such as a multi-player game, we can assign new keys - \n.keys(right='d', left='a', up='w', down='s')\n.\n\n\nCollisions\n\n\nIt's common in some games, like FPS, to want to check for sprites that collide with each other.  Let's take our previous keyboard example and check for collisions.\n\n\ndef eatit(z, s):\n    s.destroy()\n    z.scale(1.2)\n\nimage('zombie-1', (28, 18), size = 2).keys().collides(sprites(), eatit)\nimage('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s').collides(sprites(), eatit)\n\n\n\n\nHere we \nchain\n the \n.collides()\n callback which takes in a list of sprites and registers a callback function. As coded, we register both zombies to check for collisions with all sprites, the \nsprites()\n call will return all sprites on the canvas, and invoke the \neatit\n callback function.\n\n\nNext Steps\n\n\nWant to see sprites in action? Take a look at the \nThirsty Zombie\n game.",
            "title": "Drawing Sprites"
        },
        {
            "location": "/examples/sprites/#working-with-sprites",
            "text": "The Predigame sprite is a generic two-dimensional object that is integrated with other sprites in a larger scene. A sprite can consist of a bitmap (still) image or a basic geometrical shape (circle, rectangle, ellipse). Sprites in Predigame have some fun properties - they can be clicked, collide with other sprites, even fade, spin or pulse.  Let's have fun working with Sprites!",
            "title": "Working with Sprites"
        },
        {
            "location": "/examples/sprites/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/sprites/#getting-started",
            "text": "To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:  pred new sprites  Now in the text editor, find and open the file  sprites/game.py . This file is used to create a basic Predigame canvas that we'll use to place sprites. The canvas will have a width of 30 grid cells, height of 20 grid cells (we'll discuss what cells mean in a second), and a title of  Simple Game , which we're going to change to  Sprites Demo .  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Sprites Demo'  Save your changes. Try running the game from the terminal using the  pred  command (you'll want to run this command from the directory where you saved the file, e.g.  sprites  if you followed the above  pred new  example).  pred game.py  Now this program doesn't do much just yet. Just an empty window titled  Sprites Demo . So boring. We're going to add some more code, but first let's make sure we understand grid coordinates and how to place sprites within those coordinates.",
            "title": "Getting Started"
        },
        {
            "location": "/examples/sprites/#understanding-grid-coordinates",
            "text": "Probably the easiest way to understand grid coordinates is to enable the  grid()  overlay in the game code.  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Sprites Demo'\n\ngrid()  Save your code and try running the this version using the same command:  pred game.py  The result should look like the figure below. Counting the grid coordinates will show  30  from  left to right  and  20  from  top to bottom . This doesn't address how to address sprites using grid coordinates, we'll cover that next.   The following code will show how to place rectangle sprites in each of the four corners of the window.  # top/left\nshape(RECT, RED, (0, 0))\n\n# bottom/left\nshape(RECT, BLUE, (0, HEIGHT-1))\n\n# top/right\nshape(RECT, PINK, (WIDTH-1, 0))\n\n# bottom/right\nshape(RECT, PURPLE, (WIDTH-1, HEIGHT-1))  Saving and running the code will show:\n- a RED rectangle at position  (0, 0)  corresponding to the top-left corner\n- a BLUE rectangle at position  (0, HEIGHT-1)  corresponding to the bottom-left corner\n- a PINK rectangle at position  (WIDTH-1,  0)  corresponding to the top-right corner\n- a PURPLE rectangle at position  (WIDTH-1, HEIGHT-1)  corresponding to the bottom-right corner",
            "title": "Understanding Grid Coordinates"
        },
        {
            "location": "/examples/sprites/#why-are-the-corners-specified-as-width-1-and-height-1",
            "text": "Computers always start counting at zero. So if  WIDTH = 30  and the first grid is  0  the thirtieth cell would be  WIDTH-1  or  29 .  Running this code should look like the figure below.  We added a few labels to make the grid coordinates a little more easier to visualize. It's possible to replace the code from the previous exercise with the one here:  # place on center of screen\ntext(\"Understanding Grid Coordinates\", color=BLACK, size = 2.0)\ntext(\"this is a 30 x 20 window\", color=BLACK, pos=(WIDTH/2-7, HEIGHT/2+1), size = 1.75)\n\n# top/left\nshape(RECT, RED, (0, 0))\ntext(\"(0, 0)\", RED, pos = (0,1), size = 1.25)\n\n# bottom/left\nshape(RECT, BLUE, (0, HEIGHT-1))\ntext(\"(0, \" + str(HEIGHT-1) + \")\", BLUE, pos = (0, HEIGHT-2), size=1.25)\n\n# top/right\nshape(RECT, PINK, (WIDTH-1, 0))\ntext(\"(\" + str(WIDTH-1) + \", 0)\", PINK, pos = (WIDTH-2.5,1), size = 1.25)\n\n# bottom/right\nshape(RECT, PURPLE, (WIDTH-1, HEIGHT-1))\ntext(\"(\" + str(WIDTH-1) + \", \" + str(HEIGHT-1) + \")\", PURPLE, pos = (WIDTH-3,HEIGHT-2), size = 1.25)  The resulting game window will show the following rendering:",
            "title": "Why are the corners specified as WIDTH-1 and HEIGHT-1?"
        },
        {
            "location": "/examples/sprites/#creating-shapes",
            "text": "There are two types of sprites supported in the Predigame platform - shapes and images. Let's look at shapes. The formal  function definition  (or signature) for creating a shape is as follows:  shape(shape = None, color = None, pos = None, size = (1, 1))  Reading this code, there are four  attributes :   shape  - the type of shape to create. Can be one of RECT, SQUARE, CIRCLE, or ELLIPSE  color  - the shape's color. Can be a constant like BLACK, BLUE, or RED, as well as a (red, green, blue) tuple such as (128, 128, 128)  pos    - the grid cell of the shape  size   - the size of the shape in terms of grid cells using the form (width, height). For CIRCLE shapes, only the first number is considered.   Notice that each of these attributes have default values. This means that they are option, and if not specified, Predigame will create a random shape type of random color, size, and position.  # draw a random shape type of random color, size, and position\nshape()  Here are a few example shapes we can add to our canvas:  # red circle at position (2, 2)\nshape(CIRCLE, RED, (2, 2))\n\n# create a big blue circle next to the red one\nshape(CIRCLE, BLUE, (5, 1), 3)\n\n# create a 2x2 ORANGE square at position (10, 2)\nshape(RECT, ORANGE, (10, 2), (2,2))\n\n# create a 6x1 rectangle\nshape(RECT, AQUA, (15, 2), (6, 1))\n\n# create a custom colored (r, g, b) ELLIPSE\nshape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2))  If we add each of the above shapes to our code, the resulting file will look like this:  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Sprites Demo'\n\n# red circle at position (2, 2)\nshape(CIRCLE, RED, (2, 2))\n\n# create a big blue circle next to the red one\nshape(CIRCLE, BLUE, (5, 1), 3)\n\n# create a 2x2 ORANGE square at position (10, 2)\nshape(RECT, ORANGE, (10, 2), (2,2))\n\n# create a 6x1 rectangle\nshape(RECT, AQUA, (15, 2), (6, 1))\n\n# create a custom colored (r, g, b) ELLIPSE\nshape(ELLIPSE, (134, 134, 134), (23, 2), (5, 2))  Save and run this code. The result should look similar to the image below:",
            "title": "Creating Shapes"
        },
        {
            "location": "/examples/sprites/#creating-images",
            "text": "Like shapes, the Predigame platform also supports creating images. The formal  function definition  (or signature) for creating an image is as follows:  image(name = None, pos = None, center = None, size = 1)  Notice that it is similar, yet slightly different than the code for creating a shape. An image in Predigame is defined by:   name  - the name (without extension) of the image file. The image file should be stored in the  images/  directory. For example, if we had an image \"coke.png\" in our  images/  directory, the name of the image would be \"coke\".  pos  -  the grid cell of the shape. Officially, this will be the top-left cell of the image.  center  - used as an alternative to  pos  to use this position as the center point.  size  - the size of the shape in terms of grid cells. By default, the image will be fit into a single grid cell.   Notice again that each of these attributes have default values. This means that they are option, and if not specified, PrediGame will select a random image from the  images/  directory of size  1  (so it will fit into a single cell) and will be placed at a random position.  Now here are a few example shapes we can also add to our canvas:  # create a \"sprite\" sprite and place at grid location (2, 8)\nimage('sprite', (2, 8))\n\n# create a \"coke\" sprite of double size and place at grid (7, 8)\nimage('coke', (7, 8), size = 2)\n\n# create a zombie\nimage('zombie-1', (13,9), size = 5)\n\n# create another zombie\nimage('zombie-2', (19,9), size = 5)  Add the above lines to our code file and save the changes. The result should look similar to the image below:",
            "title": "Creating Images"
        },
        {
            "location": "/examples/sprites/#sprite-effects",
            "text": "Drawing sprites can be a lot of fun, however, we can add some effects to bring them to life. For example, we can make sprites spin, float, and even pulse. Let's look at the some new sprites with effects attached.",
            "title": "Sprite Effects"
        },
        {
            "location": "/examples/sprites/#spinning",
            "text": "image('sprite', (2,14)).spin(time=1)  This sprite will spin and complete a revolution every second. It's possible to change  time  to a smaller or larger number to increase or decrease the spin rate.",
            "title": "Spinning"
        },
        {
            "location": "/examples/sprites/#pulsing",
            "text": "image('sprite', (7,14)).pulse(time=0.5, size=3)  Have the sprite execute a pulsing effect - rapidly expand and shrink. The  size  attribute will control the maximum size of the sprite (as a multiplier) during expansion. The  time  attribute sets the amount of time (in seconds) the sprite will take to complete an expansion or contraction.",
            "title": "Pulsing"
        },
        {
            "location": "/examples/sprites/#floating",
            "text": "image('coke', (13, 15), size = 2).speed(1).float(distance=1)  Have the sprite float in place. The  .speed(1)  call sets the speed of the movement and the  distance  attribute sets the amount of room (in term of grid cells) the sprite will use to complete a floating operation.",
            "title": "Floating"
        },
        {
            "location": "/examples/sprites/#sprite-event-callbacks",
            "text": "When we code a game we sometimes need to create actions that will eventually occur. Think of a mouse trap. It doesn't do much until, you know, the mouse comes by and eats the cheese. In code we define callback functions -- they don't do anything until a certain event, like a mouse click, occurs in the game.  The Python program language requires that we specify our functions before registering them in the code. Let's look at a simple callback example.  def destroy(s):\n    s.destroy()  This function will simply destroy a circle anytime one is clicked. Functions don't work until they are called, or in the case of callbacks, until they are registered.  s = shape(CIRCLE, RED, rand_pos()).clicked(destroy)  That's right.. We can basically add a  .clicked(destroy)  to the end of our shape definition and register a callback function that won't get called until the player clicks on the circle.  Let's take a look at few more examples of event callbacks.",
            "title": "Sprite Event Callbacks"
        },
        {
            "location": "/examples/sprites/#click-events",
            "text": "We already briefly covered a click example, but let's look at one that is a little more complicated.  def doit(s):\n    s.destroy()\n    image('kaboom', center=(15, 10), size=25)\n\nimage('clickme', (19, 15), size = 2).pulse(time=0.05, size= 1.25).clicked(doit)  This example creates a fast pulsing  clickme  sprite that is destroyed when clicked and replaced with an oversized   kaboom  image.  s = image('coke', (13, 15), size = 2)\ns.speed(1).bouncy().spin().pulse().clicked(s.destroy)  This example is similar to our first mouse click example on the shape but it recycles the sprites  destroy()  method as a callback -  .clicked(s.destroy) . It also chains a whole bunch of effects that make this sprite bounce around the canvas, pulse, and even spin.",
            "title": "Click Events"
        },
        {
            "location": "/examples/sprites/#keyboard-events",
            "text": "We can also control a sprite with the keyboard.  image('zombie-1', (28, 18), size = 2).keys()\nimage('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s')  In this case  zombie-1  is registered with the  .keys() function which will control the sprite with keyboard arrow buttons. In the case where we'd like to use other keyboard buttons, such as a multi-player game, we can assign new keys -  .keys(right='d', left='a', up='w', down='s') .",
            "title": "Keyboard Events"
        },
        {
            "location": "/examples/sprites/#collisions",
            "text": "It's common in some games, like FPS, to want to check for sprites that collide with each other.  Let's take our previous keyboard example and check for collisions.  def eatit(z, s):\n    s.destroy()\n    z.scale(1.2)\n\nimage('zombie-1', (28, 18), size = 2).keys().collides(sprites(), eatit)\nimage('zombie-2', (25, 18), size = 2).keys(right='d', left='a', up='w', down='s').collides(sprites(), eatit)  Here we  chain  the  .collides()  callback which takes in a list of sprites and registers a callback function. As coded, we register both zombies to check for collisions with all sprites, the  sprites()  call will return all sprites on the canvas, and invoke the  eatit  callback function.",
            "title": "Collisions"
        },
        {
            "location": "/examples/sprites/#next-steps",
            "text": "Want to see sprites in action? Take a look at the  Thirsty Zombie  game.",
            "title": "Next Steps"
        },
        {
            "location": "/examples/actors/",
            "text": "Actor Framework\n\n\nPredigame Actors are Sprites that perform certain \nactions\n - mostly in the form of animations that make the game more realistic. Actors can perform any number of actions (walk, run, jump, attack) which are usually left up to the artist's creation of the sprite.\n\n\nHere are a few example Actors:\n\n\n\n\n\n\nAsset Licenses\n\n\nAll static artwork has been obtained from  \nOpenGameArt\n  or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development.\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal:\n\n\npred pull actors\n\n\n\n\nThen change into the \nactors\n directory.\n\n\ncd actors\n\n\n\n\nHow Actors Work\n\n\nThe artwork we use for actors are called \nfour directional sprites\n in that each of the actions are repeated in each direction of movement (up, down, left, right). Actor animations may seem a bit complicated under the hood, but it is nothing more than just a sequence of still images that are refreshed at a fast enough rate to give the \nillusion of animation\n.\n\n\nIn Predigame we store actors as \n.pga\n files in the \nactors\n directory. Every \n.pga\n file of actions and directions as highlighted in the picture below:\n\n\n\nEach of the highlighted png files capture a single frame.\n\n\n\nAnd when those frames are rotated fast enough the actor (in this case the zombie) appears to be attacking! Pretty cool, right?\n\n\nNow let's explore some animations. We provided a simple animation utility that enumerates through all possible animations for a given actor (just hit the space bar). Want to speed up or slow down the animation? Try using the \n-\n and \n=\n keys.\n\n\nHere's a few examples for running this utility:\n\n\npred animation.py Bee\npred animation.py Skeleton\npred animation.py Soldier-1\npred animation.py Viking\npred animation.py Witch\npred animation.py Zombie-1\n\n\n\n\nNext Steps\n\n\nWant to see actors in action? Take a look at the \nMaking Bacon\n game.",
            "title": "Actor Framework"
        },
        {
            "location": "/examples/actors/#actor-framework",
            "text": "Predigame Actors are Sprites that perform certain  actions  - mostly in the form of animations that make the game more realistic. Actors can perform any number of actions (walk, run, jump, attack) which are usually left up to the artist's creation of the sprite.  Here are a few example Actors:",
            "title": "Actor Framework"
        },
        {
            "location": "/examples/actors/#asset-licenses",
            "text": "All static artwork has been obtained from   OpenGameArt   or from Google with the \"Labeled for reuse\" filtered defined. Animated sprites are licensed to Predicate Academy (Predigame's developer) for use limited to non-commercial Predigame development.",
            "title": "Asset Licenses"
        },
        {
            "location": "/examples/actors/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/actors/#getting-started",
            "text": "To get things started, we're going download an existing Predigame game that has a few actors we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal:  pred pull actors  Then change into the  actors  directory.  cd actors",
            "title": "Getting Started"
        },
        {
            "location": "/examples/actors/#how-actors-work",
            "text": "The artwork we use for actors are called  four directional sprites  in that each of the actions are repeated in each direction of movement (up, down, left, right). Actor animations may seem a bit complicated under the hood, but it is nothing more than just a sequence of still images that are refreshed at a fast enough rate to give the  illusion of animation .  In Predigame we store actors as  .pga  files in the  actors  directory. Every  .pga  file of actions and directions as highlighted in the picture below:  Each of the highlighted png files capture a single frame.  And when those frames are rotated fast enough the actor (in this case the zombie) appears to be attacking! Pretty cool, right?  Now let's explore some animations. We provided a simple animation utility that enumerates through all possible animations for a given actor (just hit the space bar). Want to speed up or slow down the animation? Try using the  -  and  =  keys.  Here's a few examples for running this utility:  pred animation.py Bee\npred animation.py Skeleton\npred animation.py Soldier-1\npred animation.py Viking\npred animation.py Witch\npred animation.py Zombie-1",
            "title": "How Actors Work"
        },
        {
            "location": "/examples/actors/#next-steps",
            "text": "Want to see actors in action? Take a look at the  Making Bacon  game.",
            "title": "Next Steps"
        },
        {
            "location": "/examples/levels/",
            "text": "Levels\n\n\nPredigame utilizes \nPython Classes\n to implement a game with levels. If you're new to the \nclass abstraction\n be sure to click on the previous link and learn about a pretty cool way of organizing your code.  \n\n\nA Predigame level consists of three key ingredients:\n\n\n\n\na \nsetup()\n member containing any code that should run prior to the start of a given level.\n\n\na \ncompleted()\n member that assesses if a given objective has been established.\n\n\na \nnext()\n member that instructs Predigame on the next level to load.\n\n\n\n\nWith that in mind, let's take a look at two mini-game examples.\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:\n\n\npred new levels\n\n\n\n\nNow in the text editor, find and open the file \nlevels/game.py\n. Now let's get started!\n\n\nStatically Defined Levels\n\n\nThis example is pretty basic. We introduce game with two statically defined levels - level 1 draws one circle, level 2 draws two circles. Yup. Pretty basic, but it illustrates the mechanics of what it takes to create a level.\n\n\n# This is a simple game with two levels\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Simple Two Level Example'\n\n# hold a reference to the current level\ncurrent_level = None\n\n# support functions used in every level\ndef pop(s):\n    # destroy the circle\n    s.destroy()\n    # tally the hit\n    current_level.hit()\n\nclass PopLevel1(Level):\n    def __init__(self, duration):\n        self.hits = 0\n        self.duration = duration\n\n    def hit(self):\n        # update the number of hits\n        self.hits += 1\n\n        # refresh the score\n        score(self.hits)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n\n        # Hold a reference to this level\n        global current_level\n        current_level = self\n\n        # create one target at a random location\n        shape(CIRCLE).clicked(pop)\n\n        # SCORE BOARD\n        score(0, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" level is complete when all targets have been destroyed \"\"\"\n        # completed if one circle clicked\n        if self.hits == 1:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" load the next level \"\"\"\n        # preserve the time\n        return PopLevel2(duration=score(pos=LOWER_RIGHT))\n\nclass PopLevel2(Level):\n    def __init__(self, duration):\n        self.hits = 0\n        self.duration = duration\n\n    def hit(self):\n        # update the number of hits\n        self.hits += 1\n\n        # refresh the score\n        score(self.hits)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n\n        # Hold a reference to this level\n        global current_level\n        current_level = self\n\n        # create two circles at random locations\n        shape(CIRCLE).clicked(pop)\n        shape(CIRCLE).clicked(pop)\n\n        # SCORE BOARD\n        score(0, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" level is complete when all targets have been destroyed \"\"\"\n        # completed if two circles clicked\n        if self.hits == 2:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" end the game.. there is no next level \"\"\"\n        text(\"YOU SOLVED ALL LEVELS!\")\n        gameover()\n\n# start the game at level 1\nlevel(PopLevel1(1))\n\n\n\n\nDynamic Levels\n\n\nThis example builds on the previous but now increases the number of circles that are drawn with each level. We've also introduced a countdown timer. The objective of this game is to see how many levels the player can reach by clicking all circles within \n10\n seconds. You'll notice that there is much less code in this examples. Dynamic levels are fun!\n\n\n# Create a basic game that demonstrates how to create levels\n# In each level, the player has to pop all the circles in 10 seconds\n# A new circle will be added for each level\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Simple Levels Example'\n\ncurrent_level = None\n\ndef timer():\n    text(\"You survived \" + str(current_level.get_duration()) + \" seconds.\")\n    gameover()\n\ndef pop(s):\n    s.destroy()\n    current_level.hit()\n\nclass PopLevel(Level):\n    def __init__(self, level=1, duration=0):\n        self.level = level\n        self.hits = 0\n        self.time_remaining = 10\n        self.duration = duration\n\n    def hit(self):\n        # update the number of hits\n        self.hits += 1\n\n        # refresh the score\n        score(self.hits)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n\n        # Hold a reference to this level\n        global current_level\n        current_level = self\n\n        # TARGETS\n        for x in range(self.level):\n            shape(CIRCLE).clicked(pop)\n\n        # SCORE BOARD\n        score(0, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_LEFT, color=BLACK, value=self.time_remaining, method=TIMER,\n              step=-1, goal=0, callback=timer, prefix='Time Remaining: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n        score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ')\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" level is complete when all targets have been destroyed \"\"\"\n        if self.hits == self.level:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" load the next level \"\"\"\n        return PopLevel(level=self.level+1, duration=score(pos=LOWER_RIGHT))\n\nlevel(PopLevel(1))\n\n\n\n\n\nNext Steps\n\n\nWant to see levels in action? Take a look at the \nClick Ninja\n and \nZombie Madness\n games.",
            "title": "Levels"
        },
        {
            "location": "/examples/levels/#levels",
            "text": "Predigame utilizes  Python Classes  to implement a game with levels. If you're new to the  class abstraction  be sure to click on the previous link and learn about a pretty cool way of organizing your code.    A Predigame level consists of three key ingredients:   a  setup()  member containing any code that should run prior to the start of a given level.  a  completed()  member that assesses if a given objective has been established.  a  next()  member that instructs Predigame on the next level to load.   With that in mind, let's take a look at two mini-game examples.",
            "title": "Levels"
        },
        {
            "location": "/examples/levels/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete these examples. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/levels/#getting-started",
            "text": "To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:  pred new levels  Now in the text editor, find and open the file  levels/game.py . Now let's get started!",
            "title": "Getting Started"
        },
        {
            "location": "/examples/levels/#statically-defined-levels",
            "text": "This example is pretty basic. We introduce game with two statically defined levels - level 1 draws one circle, level 2 draws two circles. Yup. Pretty basic, but it illustrates the mechanics of what it takes to create a level.  # This is a simple game with two levels\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Simple Two Level Example'\n\n# hold a reference to the current level\ncurrent_level = None\n\n# support functions used in every level\ndef pop(s):\n    # destroy the circle\n    s.destroy()\n    # tally the hit\n    current_level.hit()\n\nclass PopLevel1(Level):\n    def __init__(self, duration):\n        self.hits = 0\n        self.duration = duration\n\n    def hit(self):\n        # update the number of hits\n        self.hits += 1\n\n        # refresh the score\n        score(self.hits)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n\n        # Hold a reference to this level\n        global current_level\n        current_level = self\n\n        # create one target at a random location\n        shape(CIRCLE).clicked(pop)\n\n        # SCORE BOARD\n        score(0, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" level is complete when all targets have been destroyed \"\"\"\n        # completed if one circle clicked\n        if self.hits == 1:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" load the next level \"\"\"\n        # preserve the time\n        return PopLevel2(duration=score(pos=LOWER_RIGHT))\n\nclass PopLevel2(Level):\n    def __init__(self, duration):\n        self.hits = 0\n        self.duration = duration\n\n    def hit(self):\n        # update the number of hits\n        self.hits += 1\n\n        # refresh the score\n        score(self.hits)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n\n        # Hold a reference to this level\n        global current_level\n        current_level = self\n\n        # create two circles at random locations\n        shape(CIRCLE).clicked(pop)\n        shape(CIRCLE).clicked(pop)\n\n        # SCORE BOARD\n        score(0, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" level is complete when all targets have been destroyed \"\"\"\n        # completed if two circles clicked\n        if self.hits == 2:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" end the game.. there is no next level \"\"\"\n        text(\"YOU SOLVED ALL LEVELS!\")\n        gameover()\n\n# start the game at level 1\nlevel(PopLevel1(1))",
            "title": "Statically Defined Levels"
        },
        {
            "location": "/examples/levels/#dynamic-levels",
            "text": "This example builds on the previous but now increases the number of circles that are drawn with each level. We've also introduced a countdown timer. The objective of this game is to see how many levels the player can reach by clicking all circles within  10  seconds. You'll notice that there is much less code in this examples. Dynamic levels are fun!  # Create a basic game that demonstrates how to create levels\n# In each level, the player has to pop all the circles in 10 seconds\n# A new circle will be added for each level\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Simple Levels Example'\n\ncurrent_level = None\n\ndef timer():\n    text(\"You survived \" + str(current_level.get_duration()) + \" seconds.\")\n    gameover()\n\ndef pop(s):\n    s.destroy()\n    current_level.hit()\n\nclass PopLevel(Level):\n    def __init__(self, level=1, duration=0):\n        self.level = level\n        self.hits = 0\n        self.time_remaining = 10\n        self.duration = duration\n\n    def hit(self):\n        # update the number of hits\n        self.hits += 1\n\n        # refresh the score\n        score(self.hits)\n\n    def get_duration(self):\n        return score(pos=LOWER_RIGHT)\n\n    def setup(self):\n        \"\"\" setup the level \"\"\"\n\n        # Hold a reference to this level\n        global current_level\n        current_level = self\n\n        # TARGETS\n        for x in range(self.level):\n            shape(CIRCLE).clicked(pop)\n\n        # SCORE BOARD\n        score(0, color=BLACK, method=VALUE, prefix='Hits: ')\n        score(pos=LOWER_LEFT, color=BLACK, value=self.time_remaining, method=TIMER,\n              step=-1, goal=0, callback=timer, prefix='Time Remaining: ')\n        score(pos=LOWER_RIGHT, color=BLACK, value=self.duration, method=TIMER,\n              step=1, goal=1000, prefix='Duration: ')\n        score(self.level, pos=UPPER_RIGHT, color=BLACK, method=VALUE, prefix='Level: ')\n\n        # KEYBOARD EVENTS\n        keydown('r', reset)\n\n    def completed(self):\n        \"\"\" level is complete when all targets have been destroyed \"\"\"\n        if self.hits == self.level:\n            return True\n        else:\n            return False\n\n    def next(self):\n        \"\"\" load the next level \"\"\"\n        return PopLevel(level=self.level+1, duration=score(pos=LOWER_RIGHT))\n\nlevel(PopLevel(1))",
            "title": "Dynamic Levels"
        },
        {
            "location": "/examples/levels/#next-steps",
            "text": "Want to see levels in action? Take a look at the  Click Ninja  and  Zombie Madness  games.",
            "title": "Next Steps"
        },
        {
            "location": "/examples/mazes/",
            "text": "Drawing Mazes\n\n\nWe can code a number of games with mazes. From Pacman to avoiding the zombie apocalypse, mazes are a fun and easy way to plant obstacles or walls.  The Predigame platform supports a number of maze options that we'll explore in this README. For those familiar with the Predigame Sprite, mazes are nothing more than a collection of sprites, normally all of the same type and size.\n\n\nLet's explore how to code mazes!\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going download an existing Predigame game that has a few maxes we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal:\n\n\npred pull mazes\n\n\n\n\nThen change into the \nmazes\n directory.\n\n\ncd mazes\n\n\n\n\nNow let's create a basic Predigame canvas that we'll use to build the maze. The canvas will have a width of 30 grid cells and a height of 20 grid cells.\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'MAZE'\n\n\n\n\nSave your changes. Let's call the file \ngame.py\n.  Try running the game from the terminal using the \npred\n command (you'll want to run this command from the directory where you saved the file).\n\n\npred game.py\n\n\n\n\nThis program doesn't do much just yet. Just an empty window titled \"MAZE\" - that is missing the maze! Let's add that now.\n\n\nRandom Mazes\n\n\nThe first type of maze we'll create is the computer generated randomized maze. The code below will iterate over every cell in the game and make a random decision to draw a maze.\n\n\n# these two nested for loops iterate over\n# every grid cell on the canvas\nfor y in range(HEIGHT):\n    for x in range(WIDTH):\n        # don't create a block on the location of\n        # the player OR the location of the green cell\n        if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue\n        # make a random decision to color the cell red\n        # this number can be adjusted to make the cells\n        # smaller or larger.\n        if rand(1, 3) > 2.5:\n            shape(RECT, RED, (x, y))\n\n\n\n\nThe line \nrand(1, 3) > 2.5\n represents the probability of drawing a maze. There is about a 16.6667% chance that a given cell will have a \nRED\n cell colored. Try adjusting the \n2.5\n to a larger (but less than 3) or smaller (but greater than 1) and see what happens.\n\n\nYou'll also notice that with the if condition:\n\n\n        if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue\n\n\n\n\nWill never consider placing a \nRED\n cell at position \n(0, 0)\n (top left corner) or \n(29, 16)\n (bottom right corner). This where we will put the player and a green destination block.\n\n\nNow that we can draw a random maze, lets add a player sprite at the top of the code, under the \nTITLE\n line.\n\n\n# create a sprite based on the \"player\" image\n# position at the top left corner\n# control the sprite with the arrow keys\n# the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys()\n\n\n\n\nFinally, to complete our simple game, let's add a \nGREEN\n destination block. We'll also add a callback to end the game when the player sprite collides with the destination block. Let's add this code to the bottom of the file.\n\n\n# a callback function for when the player reaches\n# the green destination\ndef win(b, p):\n    text('YOU WIN', BLUE)\n    gameover()\n\n# draw a green destination cell on the bottom right\nd = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination')\n\n# if the player reaches this cell, execute the 'win' callback\nd.collides(p, win)\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)\n\n\n\n\nFor context, here is the complete code:\n\n\nWIDTH = 30\nHEIGHT = 18\nTITLE = 'MAZE'\n\n# create a sprite based on the \"player\" image\n# position at the top left corner\n# control the sprite with the arrow keys\n# the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys()\n\n# center the player on the 0,0 grid cell\np.move_to((0, 0))\n\n# these two nested for loops iterate over\n# every grid cell on the canvas\nfor y in range(HEIGHT):\n    for x in range(WIDTH):\n        # don't create a block on the location of\n        # the player OR the location of the green cell\n        if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue\n        # make a random decision to color the cell red\n        # this number can be adjusted to make the cells\n        # smaller or larger.\n        if rand(1, 3) > 2.5:\n            shape(RECT, RED, (x, y))\n\n# a callback function for when the player reaches\n# the green destination\ndef win(b, p):\n    text('YOU WIN', BLUE)\n    gameover()\n\n# draw a green destination cell on the bottom right\nd = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination')\n\n# if the player reaches this cell, execute the 'win' callback\nd.collides(p, win)\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)\n\n\n\n\nSave the changes and try running the code:\n\n\nmy_machine$ pred maze.py\n\n\n\nNotice that player sprite can walk through walls? That's a bit silly. We'll fix that in a few minutes. Can't reach the destination? Try hitting \nr\n to reset the game.\n\n\nDon't hit the walls!\n\n\nNow let's modify the code to end the game if the player sprite bumps into a wall. It's a small insertion we can add to the end of the file.\n\n\n# a callback function for when the player runs into a red cell\ndef lose(player, block):\n    if block.tag != 'destination':\n        text('GAME OVER', BLACK)\n        gameover()\n\n# if the player 'collides' with any cell, execute the 'lose' callback\np.collides(sprites(), lose)\n\n\n\n\nSave the changes and try running the code:\n\n\nmy_machine$ pred maze.py\n\n\n\nWall Avoidance\n\n\nIn a real game, we don't want the player sprite to walk into walls. It's possible to check the destination of where the player is about to move prior to making the move. We'll call this a \nprecondition\n - Predigame handles this as a callback function.\n\n\nAdd the following code to the type of your file, under the \nTITLE\n line:\n\n\n# a callback that keeps the player from running\n# into walls. it's only acceptable to walk into\n# an object marked as a \"destination\"\ndef evaluate(action, sprite, pos):\n    obj = at(pos)\n    if obj:\n        if obj.tag == 'destination':\n            return True\n        else:\n            return False\n    else:\n        return True\n\n\n\n\nThis code calls the \nat(pos)\n function that returns any objects that are \nat\n a given location - the location the sprite is about to move to. If there is an object at the location \nAND\n  that object doesn't have the tag named \ndestination\n, it must be a wall, so \nevaluate\n will return \nFalse\n, an indication it is not safe to complete the movement. In all other conditions - either nothing is there or something with the name \ndestination\n, permit the move to complete.\n\n\nNext we'll set the \nevaluate\n callback function and assign to execute on \nkeys()\n function. Let's make a change to our player sprite:\n\n\n# create a sprite based on the \"player\" image\n# position at the top left corner. control the\n# sprite with the arrow keys while checking a\n# precondition to make sure we don't walk into\n# walls. the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys(precondition=evaluate)\n\n\n\n\nThe code from the prior step can be removed since it won't be called anymore. For context, here's the complete file in case you get a little lost making changes in the right locations.\n\n\nWIDTH = 30\nHEIGHT = 18\nTITLE = 'MAZE'\n\n# a callback that keeps the player from running\n# into walls. it's only acceptable to walk into\n# an object marked as a \"destination\"\ndef evaluate(action, sprite, pos):\n    obj = at(pos)\n    if obj:\n        if obj.tag == 'destination':\n            return True\n        else:\n            return False\n    else:\n        return True\n\n\n# create a sprite based on the \"player\" image\n# position at the top left corner. control the\n# sprite with the arrow keys while checking a\n# precondition to make sure we don't walk into\n# walls. the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys(precondition=evaluate)\n\n# these two nested for loops iterate over\n# every grid cell on the canvas\nfor y in range(HEIGHT):\n    for x in range(WIDTH):\n        # don't create a block on the location of\n        # the player OR the location of the green cell\n        if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue\n        # make a random decision to color the cell red\n        # this number can be adjusted to make the cells\n        # smaller or larger.\n        if rand(1, 3) > 2.5:\n            shape(RECT, RED, (x, y))\n\n# a callback function for when the player reaches\n# the green destination\ndef win(b, p):\n    text('YOU WIN', BLUE)\n    gameover()\n\n# draw a green destination cell on the bottom right\nd = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination')\n\n# if the player reaches this cell, execute the 'win' callback\nd.collides(p, win)\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)\n\n\n\n\nMaze Editor\n\n\nRandom mazes can be a little challenging to work with since we don't have any control where the obstacles are created. We'll now walk through how to create mazes.\n\n\nTo help illustrate mazes, the Predigame platform includes a maze editor example that can be used to create, preview, and delete mazes. Try running the code and create some mazes.\n\n\nmy_machine$ pred maze-editor.py\n\n\n\nThe code includes some debugging information on start up that documents how to use the maze  editor.\n\n\nLeft Click to draw / Right Click to undo a selection\np - preview saved mazes (hit again for next)\nd - delete the current saved maze\ns - save the current maze in a new file\nr - reset and clear screen\n\n\n\n\nIt's possible to create some pretty cool mazes. Give it a try and see what you can create! Here's an example maze:\n\n\n\n\nLoading Saved Mazes\n\n\nOnce a few mazes have been created, it's possible to load them into a new game. Let's take a look at a simple example. This code assumes that two mazes \"1\" and \"2\" are available in the \nmazes/\n directory.\n\n\nWIDTH = 30\nHEIGHT = 18\nTITLE = 'MAZE From File'\n\n# load a sample maze\nmaze('1', partial(shape, RECT, RED))\n\n# load another sample maze\nmaze('2', partial(image, 'stone'))\n\n# center the player on the 0,0 grid cell\np = image('player', (0, 0)).speed(5).keys()\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)\n\n\n\n\nThis example loads two separate mazes into the game - one containing \nRED\n shapes, the other \nstone\n images. The code uses a concept called a \"partial\".  This is like a callback function, but provides the coder additional controls for how that callback can be used.\n\n\nUnderstanding Partials\n\n\nHere's an example shape sprite that will create a \nRED\n rectangle at a random position.\n\n\nshape(RECT, RED)\n\n\n\n\nNow, here's the above example coded as a partial definition:\n\n\npartial(shape, RECT, RED)\n\n\n\n\nNotice the similarities? Predigame and python will unpack the partial into the shape once it's ready to create the shape.\n\n\nMaze Generator\n\n\nWe can also randomly generate mazes that are pretty close to a Pacman-style game with the basic function all:\n\n\nmaze()\n\n\n\n\nNotice this is \nthe exact same\n function as before? This means that if the filename of a maze is not provide, Predigame will create a random maze instead.\n\n\nAs with any maze, it's possible to provide a \npartial\n callback to describe the type of walls to create. For example, this maze will be constructed out of \n'stone'\n images:\n\n\nmaze(callback=partial(image, 'stone'))\n\n\n\n\nand this maze will be constructed out of black rectangles:\n\n\nmaze(callback=partial(shape, RECT, BLACK))\n\n\n\n\nMaze Examples\n\n\nWe've included a few examples to illustrate some mini-games that can be created with Mazes:\n\n\n\n\nmaze-1.py\n - randomly placed blocks where the player must navigate to the bottom right corner. Notice that they player can walk through walls.\n\n\nmaze-2.py\n - continuation of \nmaze-1.py\n where the player must avoid walls.\n\n\nmaze-3.py\n - variation of \nmaze-2.py\n but the player respects physics and is not able to walk through walls.\n\n\nmaze-4.py\n - load a maze from a file.\n\n\nmaze-5.py\n - continuation of \nmaze-4.py\n but all whitespace is filled with coins.\n\n\nmaze-6.py\n - random maze that fills all whitespace with coins.\n\n\n\n\nNext Steps\n\n\nWant to see actors in action? Take a look at the \nMaking Bacon\n game.",
            "title": "Mazes"
        },
        {
            "location": "/examples/mazes/#drawing-mazes",
            "text": "We can code a number of games with mazes. From Pacman to avoiding the zombie apocalypse, mazes are a fun and easy way to plant obstacles or walls.  The Predigame platform supports a number of maze options that we'll explore in this README. For those familiar with the Predigame Sprite, mazes are nothing more than a collection of sprites, normally all of the same type and size.  Let's explore how to code mazes!",
            "title": "Drawing Mazes"
        },
        {
            "location": "/examples/mazes/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/mazes/#getting-started",
            "text": "To get things started, we're going download an existing Predigame game that has a few maxes we can use to experiment with animations (you'll need an Internet connection to complete the download). This can be done by typing the following the command in the terminal:  pred pull mazes  Then change into the  mazes  directory.  cd mazes  Now let's create a basic Predigame canvas that we'll use to build the maze. The canvas will have a width of 30 grid cells and a height of 20 grid cells.  WIDTH = 30\nHEIGHT = 20\nTITLE = 'MAZE'  Save your changes. Let's call the file  game.py .  Try running the game from the terminal using the  pred  command (you'll want to run this command from the directory where you saved the file).  pred game.py  This program doesn't do much just yet. Just an empty window titled \"MAZE\" - that is missing the maze! Let's add that now.",
            "title": "Getting Started"
        },
        {
            "location": "/examples/mazes/#random-mazes",
            "text": "The first type of maze we'll create is the computer generated randomized maze. The code below will iterate over every cell in the game and make a random decision to draw a maze.  # these two nested for loops iterate over\n# every grid cell on the canvas\nfor y in range(HEIGHT):\n    for x in range(WIDTH):\n        # don't create a block on the location of\n        # the player OR the location of the green cell\n        if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue\n        # make a random decision to color the cell red\n        # this number can be adjusted to make the cells\n        # smaller or larger.\n        if rand(1, 3) > 2.5:\n            shape(RECT, RED, (x, y))  The line  rand(1, 3) > 2.5  represents the probability of drawing a maze. There is about a 16.6667% chance that a given cell will have a  RED  cell colored. Try adjusting the  2.5  to a larger (but less than 3) or smaller (but greater than 1) and see what happens.  You'll also notice that with the if condition:          if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue  Will never consider placing a  RED  cell at position  (0, 0)  (top left corner) or  (29, 16)  (bottom right corner). This where we will put the player and a green destination block.  Now that we can draw a random maze, lets add a player sprite at the top of the code, under the  TITLE  line.  # create a sprite based on the \"player\" image\n# position at the top left corner\n# control the sprite with the arrow keys\n# the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys()  Finally, to complete our simple game, let's add a  GREEN  destination block. We'll also add a callback to end the game when the player sprite collides with the destination block. Let's add this code to the bottom of the file.  # a callback function for when the player reaches\n# the green destination\ndef win(b, p):\n    text('YOU WIN', BLUE)\n    gameover()\n\n# draw a green destination cell on the bottom right\nd = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination')\n\n# if the player reaches this cell, execute the 'win' callback\nd.collides(p, win)\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)  For context, here is the complete code:  WIDTH = 30\nHEIGHT = 18\nTITLE = 'MAZE'\n\n# create a sprite based on the \"player\" image\n# position at the top left corner\n# control the sprite with the arrow keys\n# the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys()\n\n# center the player on the 0,0 grid cell\np.move_to((0, 0))\n\n# these two nested for loops iterate over\n# every grid cell on the canvas\nfor y in range(HEIGHT):\n    for x in range(WIDTH):\n        # don't create a block on the location of\n        # the player OR the location of the green cell\n        if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue\n        # make a random decision to color the cell red\n        # this number can be adjusted to make the cells\n        # smaller or larger.\n        if rand(1, 3) > 2.5:\n            shape(RECT, RED, (x, y))\n\n# a callback function for when the player reaches\n# the green destination\ndef win(b, p):\n    text('YOU WIN', BLUE)\n    gameover()\n\n# draw a green destination cell on the bottom right\nd = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination')\n\n# if the player reaches this cell, execute the 'win' callback\nd.collides(p, win)\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)  Save the changes and try running the code:  my_machine$ pred maze.py  Notice that player sprite can walk through walls? That's a bit silly. We'll fix that in a few minutes. Can't reach the destination? Try hitting  r  to reset the game.",
            "title": "Random Mazes"
        },
        {
            "location": "/examples/mazes/#dont-hit-the-walls",
            "text": "Now let's modify the code to end the game if the player sprite bumps into a wall. It's a small insertion we can add to the end of the file.  # a callback function for when the player runs into a red cell\ndef lose(player, block):\n    if block.tag != 'destination':\n        text('GAME OVER', BLACK)\n        gameover()\n\n# if the player 'collides' with any cell, execute the 'lose' callback\np.collides(sprites(), lose)  Save the changes and try running the code:  my_machine$ pred maze.py",
            "title": "Don't hit the walls!"
        },
        {
            "location": "/examples/mazes/#wall-avoidance",
            "text": "In a real game, we don't want the player sprite to walk into walls. It's possible to check the destination of where the player is about to move prior to making the move. We'll call this a  precondition  - Predigame handles this as a callback function.  Add the following code to the type of your file, under the  TITLE  line:  # a callback that keeps the player from running\n# into walls. it's only acceptable to walk into\n# an object marked as a \"destination\"\ndef evaluate(action, sprite, pos):\n    obj = at(pos)\n    if obj:\n        if obj.tag == 'destination':\n            return True\n        else:\n            return False\n    else:\n        return True  This code calls the  at(pos)  function that returns any objects that are  at  a given location - the location the sprite is about to move to. If there is an object at the location  AND   that object doesn't have the tag named  destination , it must be a wall, so  evaluate  will return  False , an indication it is not safe to complete the movement. In all other conditions - either nothing is there or something with the name  destination , permit the move to complete.  Next we'll set the  evaluate  callback function and assign to execute on  keys()  function. Let's make a change to our player sprite:  # create a sprite based on the \"player\" image\n# position at the top left corner. control the\n# sprite with the arrow keys while checking a\n# precondition to make sure we don't walk into\n# walls. the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys(precondition=evaluate)  The code from the prior step can be removed since it won't be called anymore. For context, here's the complete file in case you get a little lost making changes in the right locations.  WIDTH = 30\nHEIGHT = 18\nTITLE = 'MAZE'\n\n# a callback that keeps the player from running\n# into walls. it's only acceptable to walk into\n# an object marked as a \"destination\"\ndef evaluate(action, sprite, pos):\n    obj = at(pos)\n    if obj:\n        if obj.tag == 'destination':\n            return True\n        else:\n            return False\n    else:\n        return True\n\n\n# create a sprite based on the \"player\" image\n# position at the top left corner. control the\n# sprite with the arrow keys while checking a\n# precondition to make sure we don't walk into\n# walls. the speed of the sprite enables \"graceful\"\n# movement with the keyboard\np = image('player', (0, 0)).speed(5).keys(precondition=evaluate)\n\n# these two nested for loops iterate over\n# every grid cell on the canvas\nfor y in range(HEIGHT):\n    for x in range(WIDTH):\n        # don't create a block on the location of\n        # the player OR the location of the green cell\n        if (x, y) == (0, 0) or (x, y) == (29, 16):\n            continue\n        # make a random decision to color the cell red\n        # this number can be adjusted to make the cells\n        # smaller or larger.\n        if rand(1, 3) > 2.5:\n            shape(RECT, RED, (x, y))\n\n# a callback function for when the player reaches\n# the green destination\ndef win(b, p):\n    text('YOU WIN', BLUE)\n    gameover()\n\n# draw a green destination cell on the bottom right\nd = shape(RECT, GREEN, (WIDTH-1, HEIGHT-1), tag='destination')\n\n# if the player reaches this cell, execute the 'win' callback\nd.collides(p, win)\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)",
            "title": "Wall Avoidance"
        },
        {
            "location": "/examples/mazes/#maze-editor",
            "text": "Random mazes can be a little challenging to work with since we don't have any control where the obstacles are created. We'll now walk through how to create mazes.  To help illustrate mazes, the Predigame platform includes a maze editor example that can be used to create, preview, and delete mazes. Try running the code and create some mazes.  my_machine$ pred maze-editor.py  The code includes some debugging information on start up that documents how to use the maze  editor.  Left Click to draw / Right Click to undo a selection\np - preview saved mazes (hit again for next)\nd - delete the current saved maze\ns - save the current maze in a new file\nr - reset and clear screen  It's possible to create some pretty cool mazes. Give it a try and see what you can create! Here's an example maze:",
            "title": "Maze Editor"
        },
        {
            "location": "/examples/mazes/#loading-saved-mazes",
            "text": "Once a few mazes have been created, it's possible to load them into a new game. Let's take a look at a simple example. This code assumes that two mazes \"1\" and \"2\" are available in the  mazes/  directory.  WIDTH = 30\nHEIGHT = 18\nTITLE = 'MAZE From File'\n\n# load a sample maze\nmaze('1', partial(shape, RECT, RED))\n\n# load another sample maze\nmaze('2', partial(image, 'stone'))\n\n# center the player on the 0,0 grid cell\np = image('player', (0, 0)).speed(5).keys()\n\n# register the 'r' key for resetting the game\nkeydown('r', reset)  This example loads two separate mazes into the game - one containing  RED  shapes, the other  stone  images. The code uses a concept called a \"partial\".  This is like a callback function, but provides the coder additional controls for how that callback can be used.",
            "title": "Loading Saved Mazes"
        },
        {
            "location": "/examples/mazes/#understanding-partials",
            "text": "Here's an example shape sprite that will create a  RED  rectangle at a random position.  shape(RECT, RED)  Now, here's the above example coded as a partial definition:  partial(shape, RECT, RED)  Notice the similarities? Predigame and python will unpack the partial into the shape once it's ready to create the shape.",
            "title": "Understanding Partials"
        },
        {
            "location": "/examples/mazes/#maze-generator",
            "text": "We can also randomly generate mazes that are pretty close to a Pacman-style game with the basic function all:  maze()  Notice this is  the exact same  function as before? This means that if the filename of a maze is not provide, Predigame will create a random maze instead.  As with any maze, it's possible to provide a  partial  callback to describe the type of walls to create. For example, this maze will be constructed out of  'stone'  images:  maze(callback=partial(image, 'stone'))  and this maze will be constructed out of black rectangles:  maze(callback=partial(shape, RECT, BLACK))",
            "title": "Maze Generator"
        },
        {
            "location": "/examples/mazes/#maze-examples",
            "text": "We've included a few examples to illustrate some mini-games that can be created with Mazes:   maze-1.py  - randomly placed blocks where the player must navigate to the bottom right corner. Notice that they player can walk through walls.  maze-2.py  - continuation of  maze-1.py  where the player must avoid walls.  maze-3.py  - variation of  maze-2.py  but the player respects physics and is not able to walk through walls.  maze-4.py  - load a maze from a file.  maze-5.py  - continuation of  maze-4.py  but all whitespace is filled with coins.  maze-6.py  - random maze that fills all whitespace with coins.",
            "title": "Maze Examples"
        },
        {
            "location": "/examples/mazes/#next-steps",
            "text": "Want to see actors in action? Take a look at the  Making Bacon  game.",
            "title": "Next Steps"
        },
        {
            "location": "/examples/score/",
            "text": "Keeping Score\n\n\nEvery game needs a way to keep score. This examples showcases a few of the current scoring options that are included in Predigame. While it's always possible to write your own scoring code, we've found these options cover many common use cases.\n\n\nPrerequisites\n\n\nYou'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit \nhttp://predigame.io\n for installation instructions.\n\n\nGetting Started\n\n\nTo get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:\n\n\npred new score\n\n\n\n\nNow in the text editor, find and open the file \nscore/game.py\n. This file is used to create a basic Predigame canvas that we'll use to place sprites. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title.\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Scoring Demo'\n\n\n\n\nAccumulator\n\n\nThe first score box we'll define will go to the upper left corner of the screen.\n\n\nscore(color=WHITE)\n\n\n\n\nYou can try running your game now and you'll notice the scoring box. Without any options, the \ndefault\n scoring box is a simple numeric score counter.\n\n\npred game.py\n\n\n\n\nValue\n\n\nThe next score box is a numeric value holder. Unlike the previous example, this score box will not count the score, but rather display a value.\n\n\nscore(pos=UPPER_RIGHT, method=VALUE)\n\n\n\n\nTimer (countdown)\n\n\nSome games may have a countdown timer where the player must complete an operation within a designated amount of time. This example adds a \ntimer()\n callback function that is executed when the value reaches the goal of \n0\n.\n\n\n# a callback used for a timer\ndef timer():\n   text('GAME OVER')\n   gameover()\n\n# position this scoreboard in the bottom right corner\n# run as a timer from 30 to 0 (step is -1 so the counter \"steps down\")\n# when the goal of 0 is reached, execute the timer callback function\nscore(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:')\n\n\n\n\nTimer (duration)\n\n\nSimilar to the countdown timer, is a duration timer that displays the amount time the player has been playing the game (or level). As with the countdown timer, it is possible to define a \ngoal\n and a callback, but we elect to simply show the time.\n\n\n# position this scoreboard in the bottom left corner\n# run as a timer from 0 to 10 (the goal), in increments of 1\n# add a prefix \"Duration:\"\n# since there is no callback registered, the counter will simply when the goal is obtained\nscore(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:')\n\n\n\n\nA Silly Scoring Example\n\n\nTo showcase all of our scoring boxes in operation, let's create a simple circle clicking game. Here's the complete version that also includes the previously defined timers.\n\n\nWIDTH = 30\nHEIGHT = 20\nTITLE = 'Scoring Demo'\n\n# default scoring box (upper left corner)\nscore(color=WHITE)\n\n# place this scoreboard in the upper right corner and just show the value\n# this means the scoreboard will not accumulate the score\nscore(pos=UPPER_RIGHT, method=VALUE)\n\n# position this scoreboard in the bottom left corner\n# run as a timer from 0 to 10 (the goal), in increments of 1\n# add a prefix \"Duration:\"\n# since there is no callback registered, the counter will simply when the goal is obtained\nscore(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:')\n\n# a callback used for a timer\ndef timer():\n   text('GAME OVER')\n   gameover()\n\n# position this scoreboard in the bottom right corner\n# run as a timer from 30 to 0 (step is -1 so the counter \"steps down\")\n# when the goal of 0 is reached, execute the timer callback function\nscore(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:')\n\n# a simple sprite callback for popping circles and executing the score Options\n# every three pops will reset the scoreboard in the upper right corner\ndef pop(s):\n   s.destroy()\n   score(1)\n   score(100, pos=UPPER_RIGHT)\n   if score() % 3 == 0:\n      reset_score(pos=UPPER_RIGHT, method=VALUE)\n\n# silly circle drawer\ndef show():\n   shape(CIRCLE, RED).clicked(pop)\n   callback(show, rand(0,2))\ncallback(show, 0.5)\n\n# register a 'r' keydown method to reset\nkeydown('r', reset)\n\n\n\n\nNext Steps\n\n\nWant to see scoring in action? Take a look at the \nClick Ninja\n and \nZombie Madness\n games.",
            "title": "Scoring"
        },
        {
            "location": "/examples/score/#keeping-score",
            "text": "Every game needs a way to keep score. This examples showcases a few of the current scoring options that are included in Predigame. While it's always possible to write your own scoring code, we've found these options cover many common use cases.",
            "title": "Keeping Score"
        },
        {
            "location": "/examples/score/#prerequisites",
            "text": "You'll need to have the Predigame platform installed, a trusty text editor handy, and the command prompt (or terminal) open to complete this tutorial. Visit  http://predigame.io  for installation instructions.",
            "title": "Prerequisites"
        },
        {
            "location": "/examples/score/#getting-started",
            "text": "To get things started, we're going to create a new Predigame game. This can be done by typing the following the command in the terminal:  pred new score  Now in the text editor, find and open the file  score/game.py . This file is used to create a basic Predigame canvas that we'll use to place sprites. For the code, we'll start by defining our screen dimensions (30 x 20 grid cells) and provide a title.  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Scoring Demo'",
            "title": "Getting Started"
        },
        {
            "location": "/examples/score/#accumulator",
            "text": "The first score box we'll define will go to the upper left corner of the screen.  score(color=WHITE)  You can try running your game now and you'll notice the scoring box. Without any options, the  default  scoring box is a simple numeric score counter.  pred game.py",
            "title": "Accumulator"
        },
        {
            "location": "/examples/score/#value",
            "text": "The next score box is a numeric value holder. Unlike the previous example, this score box will not count the score, but rather display a value.  score(pos=UPPER_RIGHT, method=VALUE)",
            "title": "Value"
        },
        {
            "location": "/examples/score/#timer-countdown",
            "text": "Some games may have a countdown timer where the player must complete an operation within a designated amount of time. This example adds a  timer()  callback function that is executed when the value reaches the goal of  0 .  # a callback used for a timer\ndef timer():\n   text('GAME OVER')\n   gameover()\n\n# position this scoreboard in the bottom right corner\n# run as a timer from 30 to 0 (step is -1 so the counter \"steps down\")\n# when the goal of 0 is reached, execute the timer callback function\nscore(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:')",
            "title": "Timer (countdown)"
        },
        {
            "location": "/examples/score/#timer-duration",
            "text": "Similar to the countdown timer, is a duration timer that displays the amount time the player has been playing the game (or level). As with the countdown timer, it is possible to define a  goal  and a callback, but we elect to simply show the time.  # position this scoreboard in the bottom left corner\n# run as a timer from 0 to 10 (the goal), in increments of 1\n# add a prefix \"Duration:\"\n# since there is no callback registered, the counter will simply when the goal is obtained\nscore(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:')",
            "title": "Timer (duration)"
        },
        {
            "location": "/examples/score/#a-silly-scoring-example",
            "text": "To showcase all of our scoring boxes in operation, let's create a simple circle clicking game. Here's the complete version that also includes the previously defined timers.  WIDTH = 30\nHEIGHT = 20\nTITLE = 'Scoring Demo'\n\n# default scoring box (upper left corner)\nscore(color=WHITE)\n\n# place this scoreboard in the upper right corner and just show the value\n# this means the scoreboard will not accumulate the score\nscore(pos=UPPER_RIGHT, method=VALUE)\n\n# position this scoreboard in the bottom left corner\n# run as a timer from 0 to 10 (the goal), in increments of 1\n# add a prefix \"Duration:\"\n# since there is no callback registered, the counter will simply when the goal is obtained\nscore(pos=LOWER_LEFT, method=TIMER, step=1, goal=10, prefix='Duration:')\n\n# a callback used for a timer\ndef timer():\n   text('GAME OVER')\n   gameover()\n\n# position this scoreboard in the bottom right corner\n# run as a timer from 30 to 0 (step is -1 so the counter \"steps down\")\n# when the goal of 0 is reached, execute the timer callback function\nscore(30, pos=LOWER_RIGHT, method=TIMER, step=-1, goal=0, callback=timer, prefix='Time Left:')\n\n# a simple sprite callback for popping circles and executing the score Options\n# every three pops will reset the scoreboard in the upper right corner\ndef pop(s):\n   s.destroy()\n   score(1)\n   score(100, pos=UPPER_RIGHT)\n   if score() % 3 == 0:\n      reset_score(pos=UPPER_RIGHT, method=VALUE)\n\n# silly circle drawer\ndef show():\n   shape(CIRCLE, RED).clicked(pop)\n   callback(show, rand(0,2))\ncallback(show, 0.5)\n\n# register a 'r' keydown method to reset\nkeydown('r', reset)",
            "title": "A Silly Scoring Example"
        },
        {
            "location": "/examples/score/#next-steps",
            "text": "Want to see scoring in action? Take a look at the  Click Ninja  and  Zombie Madness  games.",
            "title": "Next Steps"
        }
    ]
}